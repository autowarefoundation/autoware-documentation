{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#autoware-documentation","title":"Autoware Documentation","text":"<p>Welcome to the Autoware Documentation! Here, you'll find comprehensive information about Autoware, the forefront of open-source autonomous driving software.</p> <p></p>"},{"location":"#about-autoware","title":"About Autoware","text":"<p>Autoware is the world\u2019s leading open-source project dedicated to autonomous driving technology. Built on the Robot Operating System (ROS 2), Autoware facilitates the commercial deployment of autonomous vehicles across various platforms and applications. Discover more about our innovative project at the Autoware Foundation website.</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#step-into-the-world-of-autoware","title":"Step into the World of Autoware","text":"<p>Discover the Concept: Start your Autoware journey by exploring the Concept pages. Here, you'll delve into the core ideas behind Autoware, understand its unique features and how it stands out in the field of autonomous driving technology. Learn about the principles guiding its development and the innovative solutions it offers.</p>"},{"location":"#set-up-your-environment","title":"Set Up Your Environment","text":"<p>Install Autoware: Once you have a grasp of the Autoware philosophy, it's time to bring it into your world. Visit our Installation section for detailed, step-by-step instructions to seamlessly install Autoware and related tools in your environment. Whether you're a beginner or an expert, these pages are designed to guide you through a smooth setup process.</p>"},{"location":"#dive-deeper","title":"Dive Deeper","text":"<p>Hands-on Experience: After installation, head over to the Tutorials pages. These tutorials are designed to provide you with hands-on experience with some simulations, allowing you to apply what you've learned and gain practical skills. From basic operations to advanced applications, these tutorials cover a wide range of topics to enhance your understanding of Autoware.</p> <p>Advanced Topics: As you become more familiar with Autoware, the How-to Guides will be your next destination. These pages delve into more advanced topics, offering deeper insights and more complex scenarios. They're perfect for those looking to expand their knowledge and expertise in specific areas of Autoware. Additionally, this section also covers methods for integrating Autoware with real vehicles, providing practical guidance for those seeking to apply Autoware in real-world settings.</p>"},{"location":"#understand-the-design","title":"Understand the Design","text":"<p>Design Concepts: For those interested in the architecture and design philosophy of Autoware, the Design pages are a treasure trove. Learn about the architectural decisions, design patterns, and the rationale behind the development of Autoware's various components.</p>"},{"location":"#more-information","title":"More Information","text":"<p>Datasets: The Datasets pages are a crucial resource for anyone working with Autoware. Here, you'll find a collection of datasets that are compatible with Autoware, providing real-world scenarios and data to test and refine your autonomous driving solutions.</p> <p>Support: As you dive deeper into Autoware, you might encounter challenges or have questions. The Support section is designed to assist you in these moments. This area includes FAQs, community forums, and contact information for getting help with Autoware. It's also a great place to connect with other Autoware users and contributors, sharing experiences and solutions.</p> <p>Competitions: The Competitions pages are where excitement meets innovation. Autoware regularly hosts or participates in various competitions and challenges, providing a platform for users to test their skills, showcase their work, and contribute to the community. These competitions range from local to global scale, offering opportunities for both beginners and experts to engage and excel. Stay updated with upcoming events and take part in the advancement of autonomous driving technologies.</p>"},{"location":"#contribute-and-collaborate","title":"Contribute and Collaborate","text":"<p>Become a Part of the Autoware Story: Your journey with Autoware isn't just about learning and using; it's also about contributing and shaping the future of autonomous driving. The Contributing section is more than just a guide; it's an invitation to be part of something bigger. Whether you're a coder, a writer, or an enthusiast, your contributions can propel Autoware forward. Join us, and let's build the future together.</p>"},{"location":"#related-documentations","title":"Related Documentations","text":"<p>In addition to this page, there are several related documentations to further your knowledge and understanding of Autoware:</p> <ul> <li>Autoware Universe Documentation contains technical documentations of each component/function such as localization, planning, etc.</li> <li>Autoware Tools Documentation contains technical documentations of each tools for autonomous driving such as performance analysis, calibration, etc.</li> </ul>"},{"location":"autoware-competitions/","title":"Autoware Competitions","text":""},{"location":"autoware-competitions/#autoware-competitions","title":"Autoware Competitions","text":"<p>This page is a collection of the links to the competitions that are related to the Autoware Foundation.</p> Title Status Description Ongoing Autoware / TIER IV Challenge 2023 Date: May 15, 2023 - Nov. 1st, 2023  As one of the main contributors of Autoware, TIER IV has been facing many difficult challenges through development, and TIER IV would like to sponsor a challenge to solve such engineering challenges. Any researchers, students, individuals or organizations are welcome to participate and submit their solution to any of the challenges we propose. Finished Japan Automotive AI Challenge 2023 (Integration) Registration: June 5, 2023 - July 14, 2023 Qualifiers: July 3, 2023 - Aug. 31, 2023 Finals: Nov. 12, 2023 In this competition, we focus on challenging tasks posed by autonomous driving in factory environments and aim to develop Autoware-based AD software that can overcome them. The qualifiers use the digital twin autonomous driving simulator AWSIM to complete specific tasks within a virtual environment. Teams that make it to the finals have the opportunity to run their software on actual vehicles in a test course in Japan. Ongoing Japan Automotive AI Challenge 2023 (Simulation) Registration: Nov 6, 2023 - Dec 28, 2023 Date: Dec 4, 2023 - Jan. 31, 2024  This contest is a software development contest with a motorsports theme. Participants will develop autonomous driving software based on Autoware.Universe, and integrate it into a racing car that runs in the End to End simulation space (AWSIM). The goal is simple, win the race while driving safely!"},{"location":"autoware-competitions/#proposing-new-competition","title":"Proposing New Competition","text":"<p>If you want add a new competition to this page, please propose it in a TSC meeting and get confirmation from the AWF.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Thank you for your interest in contributing! Autoware is supported by people like you, and all types and sizes of contribution are welcome.</p> <p>As a contributor, here are the guidelines that we would like you to follow for Autoware and its associated repositories.</p> <ul> <li>Code of Conduct</li> <li>What should I know before I get started?<ul> <li>Autoware concepts</li> <li>Contributing to open source projects</li> </ul> </li> <li>How can I get help?</li> <li>How can I contribute?<ul> <li>Participate in discussions</li> <li>Join a working group</li> <li>Report bugs</li> <li>Make a pull request</li> </ul> </li> </ul> <p>Like Autoware itself, these guidelines are being actively developed and suggestions for improvement are always welcome! Guideline changes can be proposed by creating a discussion in the Ideas category.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>To ensure the Autoware community stays open and inclusive, please follow the Code of Conduct.</p> <p>If you believe that someone in the community has violated the Code of Conduct, please make a report by emailing conduct@autoware.org.</p>"},{"location":"contributing/#what-should-i-know-before-i-get-started","title":"What should I know before I get started?","text":""},{"location":"contributing/#autoware-concepts","title":"Autoware concepts","text":"<p>To gain a high-level understanding of Autoware's architecture and design, the following pages provide a brief overview:</p> <ul> <li>Autoware architecture</li> <li>Autoware concepts</li> </ul> <p>For experienced developers, the Autoware interfaces and individual component pages should also be reviewed to understand the inputs and outputs for each component or module at a more detailed level.</p>"},{"location":"contributing/#contributing-to-open-source-projects","title":"Contributing to open source projects","text":"<p>If you are new to open source projects, we recommend reading GitHub's How to Contribute to Open Source guide for an overview of why people contribute to open source projects, what it means to contribute and much more besides.</p>"},{"location":"contributing/#how-can-i-get-help","title":"How can I get help?","text":"<p>Do not open issues for general support questions as we want to keep GitHub issues for confirmed bug reports. Instead, open a discussion in the Q&amp;A category. For more details on the support mechanisms for Autoware, refer to the Support guidelines.</p> <p>Note</p> <p>Issues created for questions or unconfirmed bugs will be moved to GitHub discussions by the maintainers.</p>"},{"location":"contributing/#how-can-i-contribute","title":"How can I contribute?","text":""},{"location":"contributing/#discussions","title":"Discussions","text":"<p>You can contribute to Autoware by facilitating and participating in discussions, such as:</p> <ul> <li>Proposing a new feature to enhance Autoware</li> <li>Joining an existing discussion and expressing your opinion</li> <li>Organizing discussions for other contributors</li> <li>Answering questions and supporting other contributors</li> </ul>"},{"location":"contributing/#working-groups","title":"Working groups","text":"<p>The various working groups within the Autoware Foundation are responsible for accomplishing goals set by the Technical Steering Committee. These working groups are open to everyone, and joining a particular working group will allow you to gain an understanding of current projects, see how those projects are managed within each group and to contribute to issues that will help progress a particular project.</p> <p>To see the schedule for upcoming working group meetings, refer to the Autoware Foundation events calendar.</p>"},{"location":"contributing/#bug-reports","title":"Bug reports","text":"<p>Before you report a bug, please search the issue tracker for the appropriate repository. It is possible that someone has already reported the same issue and that workarounds exist. If you can't determine the appropriate repository, ask the maintainers for help by creating a new discussion in the Q&amp;A category.</p> <p>When reporting a bug, you should provide a minimal set of instructions to reproduce the issue. Doing so allows us to quickly confirm and focus on the right problem.</p> <p>If you want to fix the bug by yourself that will be appreciated, but you should discuss possible approaches with the maintainers in the issue before submitting a pull request.</p> <p>Creating an issue is straightforward, but if you happen to experience any problems then create a Q&amp;A discussion to ask for help.</p>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>You can submit pull requests for small changes such as:</p> <ul> <li>Minor documentation updates</li> <li>Fixing spelling mistakes</li> <li>Fixing CI failures</li> <li>Fixing warnings detected by compilers or analysis tools</li> <li>Making small changes to a single package</li> </ul> <p>If your pull request is a large change, the following process should be followed:</p> <ol> <li> <p>Create a GitHub Discussion to propose the change. Doing so allows you to get feedback from other members and the Autoware maintainers and to ensure that the proposed change is in line with Autoware's design philosophy and current development plans. If you're not sure where to have that conversation, then create a new Q&amp;A discussion.</p> </li> <li> <p>Create an issue following consensus in the discussions</p> </li> <li> <p>Create a pull request to implement the changes that references the Issue created in step 2</p> </li> <li> <p>Create documentation for the new addition (if relevant)</p> </li> </ol> <p>Examples of large changes include:</p> <ul> <li>Adding a new feature to Autoware</li> <li>Adding a new documentation page or section</li> </ul> <p>For more information on how to submit a good pull request, have a read of the pull request guidelines and don't forget to review the required license notations!</p>"},{"location":"contributing/license/","title":"License","text":""},{"location":"contributing/license/#license","title":"License","text":"<p>Autoware is licensed under Apache License 2.0. Thus all contributions will be licensed as such as per clause 5 of the Apache License 2.0:</p> <pre><code>5. Submission of Contributions. Unless You explicitly state otherwise,\n   any Contribution intentionally submitted for inclusion in the Work\n   by You to the Licensor shall be under the terms and conditions of\n   this License, without any additional terms or conditions.\n   Notwithstanding the above, nothing herein shall supersede or modify\n   the terms of any separate license agreement you may have executed\n   with Licensor regarding such Contributions.\n</code></pre> <p>Here is an example copyright header to add to the top of a new file:</p> <pre><code>Copyright [first year of contribution] The Autoware Contributors\nSPDX-License-Identifier: Apache-2.0\n</code></pre> <p>We don't write copyright notations of each contributor here. Instead, we place them in the <code>NOTICE</code> file like the following.</p> <pre><code>This product includes code developed by [company name].\nCopyright [first year of contribution] [company name]\n</code></pre> <p>Let us know if your legal department has a special request for the copyright notation.</p> <p>Currently, the old formats explained here are also acceptable. Those old formats can be replaced by this new format if the original authors agree. Note that we won't write their copyrights to the <code>NOTICE</code> file unless they agree with the new format.</p> <p>References:</p> <ul> <li>https://opensource.google/docs/copyright/#the-year</li> <li>https://www.linuxfoundation.org/blog/copyright-notices-in-open-source-software-projects/</li> <li>https://www.apache.org/licenses/LICENSE-2.0</li> <li>https://www.apache.org/legal/src-headers.html</li> <li>https://www.apache.org/foundation/license-faq.html</li> <li>https://infra.apache.org/licensing-howto.html</li> </ul>"},{"location":"contributing/coding-guidelines/","title":"Coding guidelines","text":""},{"location":"contributing/coding-guidelines/#coding-guidelines","title":"Coding guidelines","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"contributing/coding-guidelines/#common-guidelines","title":"Common guidelines","text":"<p>Refer to the following links for now:</p> <ul> <li>https://docs.ros.org/en/humble/Contributing/Developer-Guide.html</li> </ul> <p>Also, keep in mind the following concepts.</p> <ul> <li>Keep things consistent.</li> <li>Automate where possible, using simple checks for formatting, syntax, etc.</li> <li>Write comments and documentation in English.</li> <li>Functions that are too complex (low cohesion) should be appropriately split into smaller functions (e.g. less than 40 lines in one function is recommended in the google style guideline).</li> <li>Try to minimize the use of member variables or global variables that have a large scope.</li> <li>Whenever possible, break large pull requests into smaller, manageable PRs (less than 200 lines of change is recommended in some research e.g. here).</li> <li>When it comes to code reviews, don't spend too much time on trivial disagreements. For details see:<ul> <li>https://en.wikipedia.org/wiki/Law_of_triviality</li> <li>https://steemit.com/programming/@emrebeyler/code-reviews-and-parkinson-s-law-of-triviality</li> </ul> </li> <li>Please follow the guidelines for each language.<ul> <li>C++</li> <li>Python</li> <li>Shell script</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/#autoware-style-guide","title":"Autoware Style Guide","text":"<p>For Autoware-specific styles, refer to the following:</p> <ul> <li>Use the <code>autoware_</code> prefix for package names.<ul> <li>cf. Directory structure guideline, Package name</li> <li>cf. Prefix packages with autoware_</li> </ul> </li> <li>Add implementations within the <code>autoware</code> namespace.<ul> <li>cf. Class design guideline, Namespaces</li> <li>cf. Prefix packages with autoware_, Option 3:</li> </ul> </li> <li>The header files to be exported must be placed in the <code>PACKAGE_NAME/include/autoware/</code> directory.<ul> <li>cf. Directory structure guideline, Exporting headers</li> </ul> </li> <li>In <code>CMakeLists.txt</code>, use <code>autoware_package()</code>.<ul> <li>cf. autoware_cmake README</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/languages/cmake/","title":"CMake","text":""},{"location":"contributing/coding-guidelines/languages/cmake/#cmake","title":"CMake","text":"<p>Warning</p> <p>Under Construction</p> <p>Refer to the following links for now:</p> <ul> <li>https://docs.ros.org/en/humble/Contributing/Code-Style-Language-Versions.html#cmake</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cmake/#use-the-autoware_package-macro","title":"Use the autoware_package macro","text":"<p>To reduce duplications in CMakeLists.txt, there is the <code>autoware_package()</code> macro. See the README and use it in your package.</p>"},{"location":"contributing/coding-guidelines/languages/cpp/","title":"C++","text":""},{"location":"contributing/coding-guidelines/languages/cpp/#c","title":"C++","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"contributing/coding-guidelines/languages/cpp/#references","title":"References","text":"<p>Follow the guidelines below if a rule is not defined on this page.</p> <ol> <li>https://docs.ros.org/en/humble/Contributing/Code-Style-Language-Versions.html</li> <li>https://www.autosar.org/fileadmin/standards/adaptive/22-11/AUTOSAR_RS_CPP14Guidelines.pdf</li> <li>https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines</li> </ol> <p>Also, it is encouraged to apply Clang-Tidy to each file. For the usage, see Applying Clang-Tidy to ROS packages.</p> <p>Note that not all rules are covered by Clang-Tidy.</p>"},{"location":"contributing/coding-guidelines/languages/cpp/#style-rules","title":"Style rules","text":""},{"location":"contributing/coding-guidelines/languages/cpp/#include-header-files-in-the-defined-order-required-partially-automated","title":"Include header files in the defined order (required, partially automated)","text":""},{"location":"contributing/coding-guidelines/languages/cpp/#rationale","title":"Rationale","text":"<ul> <li>Due to indirect dependencies, the include system of C++ makes different behaviors if the header order is different.</li> <li>To reduce unintended bugs, local header files should come first.</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#reference","title":"Reference","text":"<ul> <li>https://llvm.org/docs/CodingStandards.html#include-style</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#example","title":"Example","text":"<p>Include the headers in the following order:</p> <ul> <li>Main module header</li> <li>Local package headers</li> <li>Other package headers</li> <li>Message headers</li> <li>Boost headers</li> <li>C system headers</li> <li>C++ system headers</li> </ul> <pre><code>// Compliant\n#include \"my_header.hpp\"\n\n#include \"my_package/foo.hpp\"\n\n#include &lt;package1/foo.hpp&gt;\n#include &lt;package2/bar.hpp&gt;\n\n#include &lt;std_msgs/msg/header.hpp&gt;\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n</code></pre> <p>If you use <code>\"\"</code> and <code>&lt;&gt;</code> properly, <code>ClangFormat</code> in <code>pre-commit</code> sorts headers automatically.</p> <p>Do not define macros between <code>#include</code> lines because it prevents automatic sorting.</p> <pre><code>// Non-compliant\n#include &lt;package1/foo.hpp&gt;\n#include &lt;package2/bar.hpp&gt;\n\n#define EIGEN_MPL2_ONLY\n#include \"my_header.hpp\"\n#include \"my_package/foo.hpp\"\n\n#include &lt;Eigen/Core&gt;\n\n#include &lt;std_msgs/msg/header.hpp&gt;\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n</code></pre> <p>Instead, define macros before <code>#include</code> lines.</p> <pre><code>// Compliant\n#define EIGEN_MPL2_ONLY\n\n#include \"my_header.hpp\"\n\n#include \"my_package/foo.hpp\"\n\n#include &lt;Eigen/Core&gt;\n#include &lt;package1/foo.hpp&gt;\n#include &lt;package2/bar.hpp&gt;\n\n#include &lt;std_msgs/msg/header.hpp&gt;\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n</code></pre> <p>If there are any reasons for defining macros at a specific position, write a comment before the macro.</p> <pre><code>// Compliant\n#include \"my_header.hpp\"\n\n#include \"my_package/foo.hpp\"\n\n#include &lt;package1/foo.hpp&gt;\n#include &lt;package2/bar.hpp&gt;\n\n#include &lt;std_msgs/msg/header.hpp&gt;\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// For the foo bar reason, the FOO_MACRO must be defined here.\n#define FOO_MACRO\n#include &lt;foo/bar.hpp&gt;\n</code></pre>"},{"location":"contributing/coding-guidelines/languages/cpp/#use-lower-snake-case-for-function-names-required-partially-automated","title":"Use lower snake case for function names (required, partially automated)","text":""},{"location":"contributing/coding-guidelines/languages/cpp/#rationale_1","title":"Rationale","text":"<ul> <li>It is consistent with the C++ standard library.</li> <li>It is consistent with other programming languages such as Python and Rust.</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#exception","title":"Exception","text":"<ul> <li>For member functions of classes inherited from external project classes such as Qt, follow that naming convention.</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#reference_1","title":"Reference","text":"<ul> <li>https://docs.ros.org/en/humble/The-ROS2-Project/Contributing/Code-Style-Language-Versions.html#function-and-method-naming</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#example_1","title":"Example","text":"<pre><code>void function_name()\n{\n}\n</code></pre>"},{"location":"contributing/coding-guidelines/languages/cpp/#use-upper-camel-case-for-enum-names-required-partially-automated","title":"Use upper camel case for enum names (required, partially automated)","text":""},{"location":"contributing/coding-guidelines/languages/cpp/#rationale_2","title":"Rationale","text":"<ul> <li>It is consistent with ROS 2 core packages.</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#exception_1","title":"Exception","text":"<ul> <li>Enums defined in the <code>rosidl</code> file can use other naming conventions.</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#reference_2","title":"Reference","text":"<ul> <li>http://wiki.ros.org/CppStyleGuide (Refer to \"15. Enumerations\")</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#example_2","title":"Example","text":"<pre><code>enum class Color\n{\nRed, Green, Blue\n}\n</code></pre>"},{"location":"contributing/coding-guidelines/languages/cpp/#use-lower-snake-case-for-constant-names-required-partially-automated","title":"Use lower snake case for constant names (required, partially automated)","text":""},{"location":"contributing/coding-guidelines/languages/cpp/#rationale_3","title":"Rationale","text":"<ul> <li>It is consistent with ROS 2 core packages.</li> <li>It is consistent with <code>std::numbers</code>.</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#exception_2","title":"Exception","text":"<ul> <li>Constants defined in the <code>rosidl</code> file can use other naming conventions.</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#reference_3","title":"Reference","text":"<ul> <li>https://en.cppreference.com/w/cpp/numeric/constants</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#example_3","title":"Example","text":"<pre><code>constexpr double gravity = 9.80665;\n</code></pre>"},{"location":"contributing/coding-guidelines/languages/cpp/#count-acronyms-and-contractions-of-compound-words-as-one-word-required-partially-automated","title":"Count acronyms and contractions of compound words as one word (required, partially automated)","text":""},{"location":"contributing/coding-guidelines/languages/cpp/#rationale_4","title":"Rationale","text":"<ul> <li>To clarify the boundaries of words when acronyms are consecutive.</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#reference_4","title":"Reference","text":"<ul> <li>https://rust-lang.github.io/api-guidelines/naming.html#casing-conforms-to-rfc-430-c-case</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#example_4","title":"Example","text":"<pre><code>class RosApi;\nRosApi ros_api;\n</code></pre>"},{"location":"contributing/coding-guidelines/languages/cpp/#do-not-use-the-auto-keywords-with-eigens-expressions-required","title":"Do not use the auto keywords with Eigen's expressions (required)","text":""},{"location":"contributing/coding-guidelines/languages/cpp/#rationale_5","title":"Rationale","text":"<ul> <li>Avoid using auto with <code>Eigen::Matrix</code> or <code>Eigen::Vector</code> variables, as it can lead to bugs.</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#reference_5","title":"Reference","text":"<ul> <li>Eigen, C++11 and the auto keyword</li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#use-rclcpp_-eg-rclcpp_info-macros-instead-of-printf-or-stdcout-for-logging-required","title":"Use RCLCPP_* (e.g. RCLCPP_INFO) macros instead of printf or std::cout for logging (required)","text":""},{"location":"contributing/coding-guidelines/languages/cpp/#rationale_6","title":"Rationale","text":"<ul> <li>Reasons include the following:<ul> <li>It allows for consistent log level management. For instance, with RCLCPP_* macros, you can simply set --log_level to adjust the log level uniformly across the application.</li> <li>You can standardize the format using RCUTILS_CONSOLE_OUTPUT_FORMAT.</li> <li>With RCLCPP_* macros, logs are automatically recorded to /rosout. These logs can be saved to a rosbag, which can then be replayed to review the log data.</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/languages/cpp/#reference_6","title":"Reference","text":"<ul> <li>Autoware Documentation for Console logging in ROS Node</li> </ul>"},{"location":"contributing/coding-guidelines/languages/docker/","title":"Docker","text":""},{"location":"contributing/coding-guidelines/languages/docker/#docker","title":"Docker","text":"<p>Warning</p> <p>Under Construction</p> <p>Refer to the following links for now:</p> <ul> <li>https://github.com/hadolint/hadolint</li> </ul>"},{"location":"contributing/coding-guidelines/languages/github-actions/","title":"GitHub Actions","text":""},{"location":"contributing/coding-guidelines/languages/github-actions/#github-actions","title":"GitHub Actions","text":"<p>Warning</p> <p>Under Construction</p> <p>Refer to the following links for now:</p> <ul> <li>https://docs.github.com/en/actions/guides</li> </ul>"},{"location":"contributing/coding-guidelines/languages/markdown/","title":"Markdown","text":""},{"location":"contributing/coding-guidelines/languages/markdown/#markdown","title":"Markdown","text":"<p>Warning</p> <p>Under Construction</p> <p>Refer to the following links for now:</p> <ul> <li>https://docs.ros.org/en/foxy/Contributing/Code-Style-Language-Versions.html#markdown-restructured-text-docblocks</li> <li>https://github.com/DavidAnson/markdownlint</li> </ul>"},{"location":"contributing/coding-guidelines/languages/package-xml/","title":"package.xml","text":""},{"location":"contributing/coding-guidelines/languages/package-xml/#packagexml","title":"package.xml","text":"<p>Warning</p> <p>Under Construction</p> <p>Refer to the following links for now:</p> <ul> <li>https://ros.org/reps/rep-0149.html</li> <li>https://github.com/tier4/pre-commit-hooks-ros#prettier-package-xml</li> </ul>"},{"location":"contributing/coding-guidelines/languages/python/","title":"Python","text":""},{"location":"contributing/coding-guidelines/languages/python/#python","title":"Python","text":"<p>Warning</p> <p>Under Construction</p> <p>Refer to the following links for now:</p> <ul> <li>https://docs.ros.org/en/foxy/Contributing/Code-Style-Language-Versions.html#python</li> <li>https://github.com/psf/black</li> <li>https://github.com/PyCQA/isort</li> </ul>"},{"location":"contributing/coding-guidelines/languages/shell-scripts/","title":"Shell scripts","text":""},{"location":"contributing/coding-guidelines/languages/shell-scripts/#shell-scripts","title":"Shell scripts","text":"<p>Warning</p> <p>Under Construction</p> <p>Refer to the following links for now:</p> <ul> <li>https://google.github.io/styleguide/shellguide.html</li> <li>https://github.com/koalaman/shellcheck</li> <li>https://github.com/mvdan/sh</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/class-design/","title":"Class design","text":""},{"location":"contributing/coding-guidelines/ros-nodes/class-design/#class-design","title":"Class design","text":"<p>We'll use the <code>autoware_gnss_poser</code> package as an example.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/class-design/#namespaces","title":"Namespaces","text":"<pre><code>namespace autoware::gnss_poser\n{\n...\n} // namespace autoware::gnss_poser\n</code></pre> <ul> <li>Everything should be under <code>autoware::gnss_poser</code> namespace.</li> <li>Closing braces must contain a comment with the namespace name. (Automated with <code>cpplint</code>)</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/class-design/#classes","title":"Classes","text":""},{"location":"contributing/coding-guidelines/ros-nodes/class-design/#nodes","title":"Nodes","text":""},{"location":"contributing/coding-guidelines/ros-nodes/class-design/#gnss_poser_nodehpp","title":"<code>gnss_poser_node.hpp</code>","text":"<pre><code>class GNSSPoser : public rclcpp::Node\n{\npublic:\nexplicit GNSSPoser(const rclcpp::NodeOptions &amp; node_options);\n...\n}\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/class-design/#gnss_poser_nodecpp","title":"<code>gnss_poser_node.cpp</code>","text":"<pre><code>GNSSPoser::GNSSPoser(const rclcpp::NodeOptions &amp; node_options)\n: Node(\"gnss_poser\", node_options)\n{\n...\n}\n</code></pre> <ul> <li>The class name should be in <code>CamelCase</code>.</li> <li>Node classes should inherit from <code>rclcpp::Node</code>.</li> <li>The constructor must be marked be explicit.</li> <li>The constructor must take <code>rclcpp::NodeOptions</code> as an argument.</li> <li>Default node name:<ul> <li>should not have <code>autoware_</code> prefix.</li> <li>should NOT have <code>_node</code> suffix.<ul> <li>Rationale: Node names are useful in the runtime. And output of <code>ros2 node list</code> will show only nodes anyway. Having <code>_node</code> is redundant.</li> </ul> </li> <li>Example: <code>gnss_poser</code>.</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/class-design/#component-registration","title":"Component registration","text":"<pre><code>...\n} // namespace autoware::gnss_poser\n\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\nRCLCPP_COMPONENTS_REGISTER_NODE(autoware::gnss_poser::GNSSPoser)\n</code></pre> <ul> <li>The component should be registered at the end of the <code>gnss_poser_node.cpp</code> file, outside the namespaces.</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/class-design/#libraries","title":"Libraries","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/","title":"Console logging","text":""},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#console-logging","title":"Console logging","text":"<p>ROS 2 logging is a powerful tool for understanding and debugging ROS nodes.</p> <p>This page focuses on how to design console logging in Autoware and shows several practical examples. To comprehensively understand how ROS 2 logging works, refer to the logging documentation.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#logging-use-cases-in-autoware","title":"Logging use cases in Autoware","text":"<ul> <li>Developers debug code by seeing the console logs.</li> <li>Vehicle operators take appropriate risk-avoiding actions depending on the console logs.</li> <li>Log analysts analyze the console logs that are recorded in rosbag files.</li> </ul> <p>To efficiently support these use cases, clean and highly visible logs are required. For that, several rules are defined below.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#rules","title":"Rules","text":""},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#choose-appropriate-severity-levels-required-non-automated","title":"Choose appropriate severity levels (required, non-automated)","text":""},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#rationale","title":"Rationale","text":"<p>It's confusing if severity levels are inappropriate as follows:</p> <ul> <li>Useless messages are marked as <code>FATAL</code>.</li> <li>Very important error messages are marked as <code>INFO</code>.</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#example","title":"Example","text":"<p>Use the following criteria as a reference:</p> <ul> <li>DEBUG: Use this level to show debug information for developers. Note that logs with this level is hidden by default.</li> <li>INFO: Use this level to notify events (cyclic notifications during initialization, state changes, service responses, etc.) to operators.</li> <li>WARN: Use this level when a node can continue working correctly, but unintended behaviors might happen.<ul> <li>For example, \"path optimization failed but the previous data can be used\", \"the localization score is low\", etc.</li> </ul> </li> <li>ERROR: Use this level when a node can't continue working correctly, and unintended behaviors would happen.<ul> <li>For example, \"path optimization failed and the path is empty\", \"the vehicle will trigger an emergency stop\", etc.</li> </ul> </li> <li>FATAL: Use this level when the entire system can't continue working correctly, and the system must be stopped.<ul> <li>For example, \"the vehicle control ECU doesn't respond\", \"the system storage crashed\", etc.</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#filter-out-unnecessary-logs-by-setting-logging-options-required-non-automated","title":"Filter out unnecessary logs by setting logging options (required, non-automated)","text":""},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#rationale_1","title":"Rationale","text":"<p>Some third-party nodes such as drivers may not follow the Autoware's guidelines. If the logs are noisy, unnecessary logs should be filtered out.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#example_1","title":"Example","text":"<p>Use the <code>--log-level {level}</code> option to change the minimum level of logs to be displayed:</p> <pre><code>&lt;launch&gt;\n&lt;!-- This outputs only FATAL level logs. --&gt;\n&lt;node pkg=\"demo_nodes_cpp\" exec=\"talker\" ros_args=\"--log-level fatal\" /&gt;\n&lt;/launch&gt;\n</code></pre> <p>If you want to disable only specific output targets, use the <code>--disable-stdout-logs</code>, <code>--disable-rosout-logs</code>, and/or <code>--disable-external-lib-logs</code> options:</p> <pre><code>&lt;launch&gt;\n&lt;!-- This outputs to rosout and disk. --&gt;\n&lt;node pkg=\"demo_nodes_cpp\" exec=\"talker\" ros_args=\"--disable-stdout-logs\" /&gt;\n&lt;/launch&gt;\n</code></pre> <pre><code>&lt;launch&gt;\n&lt;!-- This outputs to stdout. --&gt;\n&lt;node pkg=\"demo_nodes_cpp\" exec=\"talker\" ros_args=\"--disable-rosout-logs --disable-external-lib-logs\" /&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#use-throttled-logging-when-the-log-is-unnecessarily-shown-repeatedly-required-non-automated","title":"Use throttled logging when the log is unnecessarily shown repeatedly (required, non-automated)","text":""},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#rationale_2","title":"Rationale","text":"<p>If tons of logs are shown on the console, people miss important message.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#example_2","title":"Example","text":"<p>While waiting for some messages, throttled logs are usually enough. In such cases, wait about 5 seconds as a reference value.</p> <pre><code>// Compliant\nvoid FooNode::on_timer() {\nif (!current_pose_) {\nRCLCPP_ERROR_THROTTLE(get_logger(), *get_clock(), 5000, \"Waiting for current_pose_.\");\nreturn;\n}\n}\n\n// Non-compliant\nvoid FooNode::on_timer() {\nif (!current_pose_) {\nRCLCPP_ERROR(get_logger(), \"Waiting for current_pose_.\");\nreturn;\n}\n}\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#exception","title":"Exception","text":"<p>The following cases are acceptable even if it's not throttled.</p> <ul> <li>The message is really worth displaying every time.</li> <li>The message level is DEBUG.</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#do-not-depend-on-rclcppnode-in-core-library-classes-but-depend-only-on-rclcpplogginghpp-advisory-non-automated","title":"Do not depend on rclcpp::Node in core library classes but depend only on rclcpp/logging.hpp (advisory, non-automated)","text":""},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#rationale_3","title":"Rationale","text":"<p>Core library classes, which contain reusable algorithms, may also be used for non-ROS platforms. When porting libraries to other platforms, fewer dependencies are preferred.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#example_3","title":"Example","text":"<pre><code>// Compliant\n#include &lt;rclcpp/logging.hpp&gt;\n\nclass FooCore {\npublic:\nexplicit FooCore(const rclcpp::Logger &amp; logger) : logger_(logger) {}\n\nvoid process() {\nRCLCPP_INFO(logger_, \"message\");\n}\n\nprivate:\nrclcpp::Logger logger_;\n};\n\n// Compliant\n// Note that logs aren't published to `/rosout` if the logger name is different from the node name.\n#include &lt;rclcpp/logging.hpp&gt;\n\nclass FooCore {\nvoid process() {\nRCLCPP_INFO(rclcpp::get_logger(\"foo_core_logger\"), \"message\");\n}\n};\n\n\n// Non-compliant\n#include &lt;rclcpp/node.hpp&gt;\n\nclass FooCore {\npublic:\nexplicit FooCore(const rclcpp::NodeOptions &amp; node_options) : node_(\"foo_core_node\", node_options) {}\n\nvoid process() {\nRCLCPP_INFO(node_.get_logger(), \"message\");\n}\n\nprivate:\nrclcpp::Node node_;\n};\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#tips","title":"Tips","text":""},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#use-rqt_console-to-filter-logs","title":"Use rqt_console to filter logs","text":"<p>To filter logs, using <code>rqt_console</code> is useful:</p> <pre><code>ros2 run rqt_console rqt_console\n</code></pre> <p>For more details, refer to ROS 2 Documentation.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/console-logging/#useful-marco-expressions","title":"Useful marco expressions","text":"<p>To debug program, sometimes you need to see which functions and lines of code are executed. In that case, you can use <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code> macro:</p> <pre><code>void FooNode::on_timer() {\nRCLCPP_DEBUG(get_logger(), \"file: %s, line: %s, function: %s\" __FILE__, __LINE__, __FUNCTION__);\n}\n</code></pre> <p>The example output is as follows:</p> <p>[DEBUG] [1671720414.395456931] [foo]: file: /path/to/file.cpp, line: 100, function: on_timer</p>"},{"location":"contributing/coding-guidelines/ros-nodes/coordinate-system/","title":"Coordinate system","text":""},{"location":"contributing/coding-guidelines/ros-nodes/coordinate-system/#coordinate-system","title":"Coordinate system","text":""},{"location":"contributing/coding-guidelines/ros-nodes/coordinate-system/#overview","title":"Overview","text":"<p>The commonly used coordinate systems include the world coordinate system, the vehicle coordinate system, and the sensor coordinate system.</p> <ul> <li>The world coordinate system is a fixed coordinate system that defines the physical space in the environment where the vehicle is located.</li> </ul> <ul> <li>The vehicle coordinate system is the vehicle's own coordinate system, which defines the vehicle's position and orientation in the world coordinate system.</li> </ul> <ul> <li>The sensor coordinate system is the sensor's own coordinate system, which is used to define the sensor's position and orientation in the vehicle coordinate system.</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/coordinate-system/#how-coordinates-are-used-in-autoware","title":"How coordinates are used in Autoware","text":"<p>In Autoware, coordinate systems are typically used to represent the position and movement of vehicles and obstacles in space. Coordinate systems are commonly used for path planning, perception and control, can help the vehicle decide how to avoid obstacles and to plan a safe and efficient path of travel.</p> <ol> <li> <p>Transformation of sensor data</p> <p>In Autoware, each sensor has a unique coordinate system and their data is expressed in terms of the coordinates. In order to correlate the independent data between different sensors, we need to find the position relationship between each sensor and the vehicle body. Once the installation position of the sensor on the vehicle body is determined, it will remain fixed during running, so the offline calibration method can be used to determine the precise position of each sensor relative to the vehicle body.</p> </li> <li> <p>ROS TF2</p> <p>The <code>TF2</code> system maintains a tree of coordinate transformations to represent the relationships between different coordinate systems. Each coordinate system is given a unique name and they are connected by coordinate transformations. How to use <code>TF2</code>, refer to the TF2 tutorial.</p> </li> </ol>"},{"location":"contributing/coding-guidelines/ros-nodes/coordinate-system/#tf-tree","title":"TF tree","text":"<p>In Autoware, a common coordinate system structure is shown below:</p> <pre><code>graph TD\n    /earth --&gt; /map\n    /map --&gt; /base_link\n    /base_link --&gt; /imu\n    /base_link --&gt; /lidar\n    /base_link --&gt; /gnss\n    /base_link --&gt; /radar\n    /base_link --&gt; /camera_link\n    /camera_link --&gt; /camera_optical_link</code></pre> <ul> <li>earth: <code>earth</code> coordinate system describe the position of any point on the earth in terms of geodetic longitude, latitude, and altitude. In Autoware, the <code>earth</code> frame is only used in the <code>GnssInsPositionStamped</code> message.</li> </ul> <ul> <li>map: <code>map</code> coordinate system is used to represent the location of points on a local map. Geographical coordinate system are mapped into plane rectangular coordinate system using UTM or MGRS. The <code>map</code> frame`s axes point to the East, North, Up directions as explained in Coordinate Axes Conventions.</li> </ul> <ul> <li>base_link: vehicle coordinate system, the origin of the coordinate system is the center of the rear axle of the vehicle.</li> </ul> <ul> <li>imu, lidar, gnss, radar: these are sensor frames, transfer to vehicle coordinate system through mounting relationship.</li> </ul> <ul> <li>camera_link: <code>camera_link</code> is ROS standard camera coordinate system .</li> </ul> <ul> <li>camera_optical_link: <code>camera_optical_link</code> is image standard camera coordinate system.</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/coordinate-system/#estimating-the-base_link-frame-by-using-the-other-sensors","title":"Estimating the <code>base_link</code> frame by using the other sensors","text":"<p>Generally we don't have the localization sensors physically at the <code>base_link</code> frame. So various sensors localize with respect to their own frames, let's call it <code>sensor</code> frame.</p> <p>We introduce a new frame naming convention: <code>x_by_y</code>:</p> <pre><code>x: estimated frame name\ny: localization method/source\n</code></pre> <p>We cannot directly get the <code>sensor</code> frame. Because we would need the EKF module to estimate the <code>base_link</code> frame first.</p> <p>Without the EKF module the best we can do is to estimate <code>Map[map] --&gt; sensor_by_sensor --&gt; base_link_by_sensor</code> using this sensor.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/coordinate-system/#example-by-the-gnssins-sensor","title":"Example by the GNSS/INS sensor","text":"<p>For the integrated GNSS/INS we use the following frames:</p> <pre><code>flowchart LR\n    earth --&gt; Map[map] --&gt; gnss_ins_by_gnss_ins --&gt; base_link_by_gnss_ins</code></pre> <p>The <code>gnss_ins_by_gnss_ins</code> frame is obtained by the coordinates from GNSS/INS sensor. The coordinates are converted to <code>map</code> frame using the <code>gnss_poser</code> node.</p> <p>Finally <code>gnss_ins_by_gnss_ins</code> frame represents the position of the <code>gnss_ins</code> estimated by the <code>gnss_ins</code> sensor in the <code>map</code>.</p> <p>Then by using the static transformation between <code>gnss_ins</code> and the <code>base_link</code> frame, we can obtain the <code>base_link_by_gnss_ins</code> frame. Which represents the <code>base_link</code> estimated by the <code>gnss_ins</code> sensor.</p> <p>References:</p> <ul> <li>https://www.ros.org/reps/rep-0105.html#earth</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/coordinate-system/#coordinate-axes-conventions","title":"Coordinate Axes Conventions","text":"<p>We are using East, North, Up (ENU) coordinate axes convention by default throughout the stack.</p> <pre><code>X+: East\nY+: North\nZ+: Up\n</code></pre> <p>The position, orientation, velocity, acceleration are all defined in the same axis convention.</p> <p>Position by the GNSS/INS sensor is expected to be in <code>earth</code> frame.</p> <p>Orientation, velocity, acceleration by the GNSS/INS sensor are expected to be in the sensor frame. Axes parallel to the <code>map</code> frame.</p> <p>If roll, pitch, yaw is provided, they correspond to rotation around X, Y, Z axes respectively.</p> <pre><code>Rotation around:\nX+: roll\nY+: pitch\nZ+: yaw\n</code></pre> <p>References:</p> <ul> <li>https://www.ros.org/reps/rep-0103.html#axis-orientation</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/coordinate-system/#how-they-can-be-created","title":"How they can be created","text":"<ol> <li> <p>Calibration of sensor</p> <p>The conversion relationship between every sensor coordinate system and <code>base_link</code> can be obtained through sensor calibration technology.  Please consult the following link  calibrating your sensors for instructions  on how to calibrate your sensors.</p> </li> <li> <p>Localization</p> <p>The relationship between the <code>base_link</code> coordinate system and the <code>map</code> coordinate system is determined by the position and orientation of the vehicle, and can be obtained from the vehicle localization result.</p> </li> <li> <p>Geo-referencing of map data</p> <p>The geo-referencing information can get the transformation relationship of <code>earth</code> coordinate system to local <code>map</code> coordinate system.</p> </li> </ol>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/","title":"Directory structure","text":""},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#directory-structure","title":"Directory structure","text":"<p>This document describes the directory structure of ROS nodes within Autoware.</p> <p>We'll use the package <code>autoware_gnss_poser</code> as an example.</p> <p>Note that this example does not reflect the actual <code>autoware_gnss_poser</code> and includes extra files and directories to demonstrate all possible package structures.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#c-package","title":"C++ package","text":""},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#entire-structure","title":"Entire structure","text":"<ul> <li>This is a reference on how the entire package might be structured.</li> <li>A package may not have all the directories shown here.</li> </ul> <pre><code>autoware_gnss_poser\n\u251c\u2500 package.xml\n\u251c\u2500 CMakeLists.txt\n\u251c\u2500 README.md\n\u2502\n\u251c\u2500 config\n\u2502   \u251c\u2500 gnss_poser.param.yaml\n\u2502   \u2514\u2500 another_non_ros_config.yaml\n\u2502\n\u251c\u2500 schema\n\u2502   \u2514\u2500 gnss_poser.schema.json\n\u2502\n\u251c\u2500 doc\n\u2502   \u251c\u2500 foo_document.md\n\u2502   \u2514\u2500 foo_diagram.svg\n\u2502\n\u251c\u2500 include  # for exporting headers\n\u2502   \u2514\u2500 autoware\n\u2502       \u2514\u2500 gnss_poser\n\u2502           \u2514\u2500 exported_header.hpp\n\u2502\n\u251c\u2500 src\n\u2502   \u251c\u2500 include\n\u2502   \u2502   \u251c\u2500 gnss_poser_node.hpp\n\u2502   \u2502   \u2514\u2500 foo.hpp\n\u2502   \u251c\u2500 gnss_poser_node.cpp\n\u2502   \u2514\u2500 bar.cpp\n\u2502\n\u251c\u2500 launch\n\u2502   \u251c\u2500 gnss_poser.launch.xml\n\u2502   \u2514\u2500 gnss_poser.launch.py\n\u2502\n\u2514\u2500 test\n    \u251c\u2500 test_foo.hpp  # or place under an `include` folder here\n    \u2514\u2500 test_foo.cpp\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#package-name","title":"Package name","text":"<ul> <li>All the packages in Autoware should be prefixed with <code>autoware_</code>.</li> <li>Even if the package is exports a node, the package name should NOT have the <code>_node</code> suffix.</li> <li>The package name should be in <code>snake_case</code>.</li> </ul> Package Name OK Alternative path_smoother \u274c autoware_path_smoother autoware_trajectory_follower_node \u274c autoware_trajectory_follower autoware_geography_utils \u2705 -"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#package-folder","title":"Package folder","text":"<pre><code>autoware_gnss_poser\n\u251c\u2500 package.xml\n\u251c\u2500 CMakeLists.txt\n\u2514\u2500 README.md\n</code></pre> <p>The package folder name should be the same as the package name.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#packagexml","title":"<code>package.xml</code>","text":"<ul> <li>The package name should be entered within the <code>&lt;name&gt;</code> tag.<ul> <li><code>&lt;name&gt;autoware_gnss_poser&lt;/name&gt;</code></li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#cmakeliststxt","title":"<code>CMakeLists.txt</code>","text":"<ul> <li>The <code>project()</code> command should call the package name.<ul> <li>Example: <code>project(autoware_gnss_poser)</code></li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#exporting-a-composable-node-component-executables","title":"Exporting a composable node component executables","text":"<p>For best practices and system efficiency, it is recommended to primarily use composable node components.</p> <p>This method facilitates easier deployment and maintenance within ROS environments.</p> <pre><code>ament_auto_add_library(${PROJECT_NAME} SHARED\nsrc/gnss_poser_node.cpp\n)\n\nrclcpp_components_register_node(${PROJECT_NAME}\nPLUGIN \"autoware::gnss_poser::GNSSPoser\"\nEXECUTABLE ${PROJECT_NAME}_node\n)\n</code></pre> <ul> <li>If you are building:<ul> <li>only a single composable node component, the executable name should start with <code>${PROJECT_NAME}</code></li> <li>multiple composable node components, the executable name is up to the developer.</li> </ul> </li> <li>All composable node component executables should have the <code>_node</code> suffix.</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#exporting-a-standalone-node-executable-without-composition-discouraged-for-most-cases","title":"Exporting a standalone node executable without composition (discouraged for most cases)","text":"<p>Use of standalone executables should be limited to cases where specific needs such as debugging or tooling are required.</p> <p>Exporting a composable node component executables is generally preferred for standard operational use due its flexibility and scalability within the ROS ecosystem.</p> <p>Assuming:</p> <ul> <li><code>src/gnss_poser.cpp</code> has the <code>GNSSPoser</code> class.</li> <li><code>src/gnss_poser_node.cpp</code> has the <code>main</code> function.</li> <li>There is no composable node component registration.</li> </ul> <pre><code>ament_auto_add_library(${PROJECT_NAME} SHARED\nsrc/gnss_poser.cpp\n)\n\nament_auto_add_executable(${PROJECT_NAME}_node src/gnss_poser_node.cpp)\n</code></pre> <ul> <li>The node executable:<ul> <li>should have <code>_node</code> suffix.</li> <li>should start with `${PROJECT_NAME}</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#config-and-schema","title":"<code>config</code> and <code>schema</code>","text":"<pre><code>autoware_gnss_poser\n\u2502\u2500 config\n\u2502   \u251c\u2500 gnss_poser.param.yaml\n\u2502   \u2514\u2500 another_non_ros_config.yaml\n\u2514\u2500 schema\n    \u2514\u2500 gnss_poser.schema.json\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#config","title":"<code>config</code>","text":"<ul> <li>ROS parameters uses the extension <code>.param.yaml</code>.</li> <li>Non-ROS parameters use the extension <code>.yaml</code>.</li> </ul> <p>Rationale: Different linting rules are used for ROS parameters and non-ROS parameters.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#schema","title":"<code>schema</code>","text":"<p>Place parameter definition files. See Parameters for details.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#doc","title":"<code>doc</code>","text":"<pre><code>autoware_gnss_poser\n\u2514\u2500 doc\n    \u251c\u2500 foo_document.md\n    \u2514\u2500 foo_diagram.svg\n</code></pre> <p>Place documentation files and link them from the README file.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#include-and-src","title":"<code>include</code> and <code>src</code>","text":"<ul> <li>Unless you specifically need to export headers, you shouldn't have a <code>include</code> directory under the package directory.</li> <li>For most cases, follow Not exporting headers.</li> <li>Library packages that export headers may follow Exporting headers.</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#not-exporting-headers","title":"Not exporting headers","text":"<pre><code>autoware_gnss_poser\n\u2514\u2500 src\n    \u251c\u2500 include\n    \u2502   \u251c\u2500 gnss_poser_node.hpp\n    \u2502   \u2514\u2500 foo.hpp\n    \u2502\u2500 gnss_poser_node.cpp\n    \u2514\u2500 bar.cpp\n\nOR\n\nautoware_gnss_poser\n\u2514\u2500 src\n    \u251c\u2500 gnss_poser_node.hpp\n    \u251c\u2500 gnss_poser_node.cpp\n    \u251c\u2500 foo.hpp\n    \u2514\u2500 bar.cpp\n</code></pre> <ul> <li>The source file exporting the node should:<ul> <li>have <code>_node</code> suffix.<ul> <li>Rationale: To distinguish from other source files.</li> </ul> </li> <li>NOT have <code>autoware_</code> prefix.<ul> <li>Rationale: To avoid verbosity.</li> </ul> </li> </ul> </li> <li>See Class design for more details on how to construct <code>gnss_poser_node.hpp</code> and <code>gnss_poser_node.cpp</code> files.</li> <li>It is up to developer how to organize the source files under <code>src</code>.<ul> <li>Note: The <code>include</code> folder under <code>src</code> is optional.</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#exporting-headers","title":"Exporting headers","text":"<pre><code>autoware_gnss_poser\n\u2514\u2500 include\n    \u2514\u2500 autoware\n        \u2514\u2500 gnss_poser\n            \u2514\u2500 exported_header.hpp\n</code></pre> <ul> <li><code>autoware_gnss_poser/include</code> folder should contain ONLY the <code>autoware</code> folder.<ul> <li>Rationale: When installing ROS debian packages, the headers are copied to the <code>/opt/ros/$ROS_DISTRO/include/</code> directory. This structure is used to avoid conflicts with non-Autoware packages.</li> </ul> </li> <li><code>autoware_gnss_poser/include/autoware</code> folder should contain ONLY the <code>gnss_poser</code> folder.<ul> <li>Rationale: Similarly, this structure is used to avoid conflicts with other packages.</li> </ul> </li> <li><code>autoware_gnss_poser/include/autoware/gnss_poser</code> folder should contain the header files to be exported.</li> </ul> <p>Note: If <code>ament_auto_package()</code> command is used in the <code>CMakeLists.txt</code> file and <code>autoware_gnss_poser/include</code> folder exists, this <code>include</code> folder will be exported to the <code>install</code> folder as part of ament_auto_package.cmake</p> <p>Reference: https://docs.ros.org/en/humble/How-To-Guides/Ament-CMake-Documentation.html#adding-targets</p>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#launch","title":"<code>launch</code>","text":"<pre><code>autoware_gnss_poser\n\u2514\u2500 launch\n    \u251c\u2500 gnss_poser.launch.xml\n    \u2514\u2500 gnss_poser.launch.py\n</code></pre> <ul> <li>You may have multiple launch files here.</li> <li>Unless you have a specific reason, use the <code>.launch.xml</code> extension.<ul> <li>Rationale: While the <code>.launch.py</code> extension is more flexible, it comes with a readability cost.</li> </ul> </li> <li>Avoid <code>autoware_</code> prefix in the launch file names.<ul> <li>Rationale: To avoid verbosity.</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#test","title":"<code>test</code>","text":"<pre><code>autoware_gnss_poser\n\u2514\u2500 test\n    \u251c\u2500 test_foo.hpp  # or place under an `include` folder here\n    \u2514\u2500 test_foo.cpp\n</code></pre> <p>Place source files for testing. See unit testing for details.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/directory-structure/#python-package","title":"Python package","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"contributing/coding-guidelines/ros-nodes/launch-files/","title":"Launch files","text":""},{"location":"contributing/coding-guidelines/ros-nodes/launch-files/#launch-files","title":"Launch files","text":""},{"location":"contributing/coding-guidelines/ros-nodes/launch-files/#overview","title":"Overview","text":"<p>Autoware use ROS 2 launch system to startup the software. Please see the official documentation to get a basic understanding about ROS 2 Launch system if you are not familiar with it.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/launch-files/#guideline","title":"Guideline","text":""},{"location":"contributing/coding-guidelines/ros-nodes/launch-files/#the-organization-of-launch-files-in-autoware","title":"The organization of launch files in Autoware","text":"<p>Autoware mainly has two repositories related to launch file organization: the autoware.universe and the autoware_launch.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/launch-files/#autowareuniverse","title":"autoware.universe","text":"<p>the <code>autoware.universe</code> contains the code of the main Autoware modules, and its <code>launch</code> directory is responsible for launching the nodes of each module. Autoware software stack is organized based on the architecture, so you may find that we try to match the launch structure similar to the architecture (splitting of files, namespace). For example, the <code>tier4_map_launch</code> subdirectory corresponds to the map module, so do the other <code>tier4_*_launch</code> subdirectories.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/launch-files/#autoware_launch","title":"autoware_launch","text":"<p>The <code>autoware_launch</code> is a repository referring to <code>autoware.universe</code>. The mainly purpose of introducing this repository is to provide the general entrance to start the Autoware software stacks, i.e, calling the launch file of each module.</p> <ul> <li> <p>The <code>autoware.launch.xml</code> is the basic launch file for road driving scenarios.</p> <p>As can be seen from the content, the entire launch file is divided into several different modules, including Vehicle, System, Map, Sensing, Localization, Perception, Planning, Control, etc. By setting the <code>launch_*</code> argument equals to <code>true</code> or <code>false</code> , we can determine which modules to be loaded.</p> </li> </ul> <ul> <li>The <code>logging_simulator.launch.xml</code> is often used together with the recorded ROS bag to debug if the target module (e.g, Sensing, Localization or Perception) functions normally.</li> </ul> <ul> <li>The <code>planning_simulator.launch.xml</code> is based on the Planning Simulator tool, mainly used for testing/validation of Planning module by simulating traffic rules, interactions with dynamic objects and control commands to the ego vehicle.</li> </ul> <ul> <li>The <code>e2e_simulator.launch.xml</code> is the launcher for digital twin simulation environment.</li> </ul> <pre><code>graph LR\nA11[logging_simulator.launch.xml]-.-&gt;A10[autoware.launch.xml]\nA12[planning_simulator.launch.xml]-.-&gt;A10[autoware.launch.xml]\nA13[e2e_simulator.launch.xml]-.-&gt;A10[autoware.launch.xml]\n\nA10--&gt;A21[tier4_map_component.launch.xml]\nA10--&gt;A22[xxx.launch.py]\nA10--&gt;A23[tier4_localization_component.launch.xml]\nA10--&gt;A24[xxx.launch.xml]\nA10--&gt;A25[tier4_sensing_component.launch.xml]\n\nA23--&gt;A30[localization.launch.xml]\nA30--&gt;A31[pose_estimator.launch.xml]\nA30--&gt;A32[util.launch.xml]\nA30--&gt;A33[pose_twist_fusion_filter.launch.xml]\nA30--&gt;A34[xxx.launch.xml]\nA30--&gt;A35[twist_estimator.launch.xml]\n\nA33--&gt;A41[stop_filter.launch.xml]\nA33--&gt;A42[ekf_localizer.launch.xml]\nA33--&gt;A43[twist2accel.launch.xml]</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/launch-files/#add-a-new-package-in-autoware","title":"Add a new package in Autoware","text":"<p>If a newly created package has executable node, we expect sample launch file and configuration within the package, just like the recommended structure shown in previous directory structure page.</p> <p>In order to automatically load the newly added package when starting Autoware, you need to make some necessary changes to the corresponding launch file. For example, if using ICP instead of NDT as the pointcloud registration algorithm, you can modify the <code>autoware.universe/launch/tier4_localization_launch/launch/pose_estimator/pose_estimator.launch.xml</code> file to load the newly added ICP package.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/launch-files/#parameter-management","title":"Parameter management","text":"<p>Another purpose of introducing the <code>autoware_launch</code> repository is to facilitate the parameter management of Autoware. Thinking about this situation: if we want to integrate Autoware to a specific vehicle and modify parameters, we have to fork <code>autoware.universe</code> which also has a lot of code other than parameters and is frequently updated by developers. By integrating these parameters in <code>autoware_launch</code>, we can customize the Autoware parameters just by forking <code>autoware_launch</code> repository. Taking the localization module as an examples:</p> <ol> <li>all the \u201claunch parameters\u201d for localization component is listed in the files under <code>autoware_launch/autoware_launch/config/localization</code>.</li> <li>the \"launch parameters\" file paths are set in the <code>autoware_launch/autoware_launch/launch/components/tier4_localization_component.launch.xml</code> file.</li> <li>in <code>autoware.universe/launch/tier4_localization_launch/launch</code>, the launch files loads the \u201claunch parameters\u201d if the argument is given in the parameter configuration file. You can still use the default parameters in each packages to launch <code>tier4_localization_launch</code> within <code>autoware.universe</code>.</li> </ol>"},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/","title":"Message guidelines","text":""},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#message-guidelines","title":"Message guidelines","text":""},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#format","title":"Format","text":"<p>All messages should follow ROS message description specification.</p> <p>The accepted formats are:</p> <ul> <li><code>.msg</code></li> <li><code>.srv</code></li> <li><code>.action</code></li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#naming","title":"Naming","text":"<p>Under Construction</p> <p>Use <code>Array</code> as a suffix when creating a plural type of a message. This suffix is commonly used in common_interfaces.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#default-units","title":"Default units","text":"<p>All the fields by default have the following units depending on their types:</p> type default unit distance meter (m) angle radians (rad) time second (s) speed m/s velocity m/s acceleration m/s\u00b2 angular vel. rad/s angular accel. rad/s\u00b2 <p>If a field in a message has any of these default units, don't add any suffix or prefix denoting the type.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#non-default-units","title":"Non-default units","text":"<p>For non-default units, use following suffixes:</p> type non-default unit suffix distance nanometer <code>_nm</code> distance micrometer <code>_um</code> distance millimeter <code>_mm</code> distance kilometer <code>_km</code> angle degree (deg) <code>_deg</code> time nanosecond <code>_ns</code> time microsecond <code>_us</code> time millisecond <code>_ms</code> time minute <code>_min</code> time hour (h) <code>_hour</code> velocity km/h <code>_kmph</code> <p>If a unit that you'd like to use doesn't exist here, create an issue/PR to add it to this list.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#message-field-types","title":"Message field types","text":"<p>For list of types supported by the ROS interfaces see here.</p> <p>Also copied here for convenience:</p> Message Field Type C++ equivalent <code>bool</code> <code>bool</code> <code>byte</code> <code>uint8_t</code> <code>char</code> <code>char</code> <code>float32</code> <code>float</code> <code>float64</code> <code>double</code> <code>int8</code> <code>int8_t</code> <code>uint8</code> <code>uint8_t</code> <code>int16</code> <code>int16_t</code> <code>uint16</code> <code>uint16_t</code> <code>int32</code> <code>int32_t</code> <code>uint32</code> <code>uint32_t</code> <code>int64</code> <code>int64_t</code> <code>uint64</code> <code>uint64_t</code> <code>string</code> <code>std::string</code> <code>wstring</code> <code>std::u16string</code>"},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#arrays","title":"Arrays","text":"<p>For arrays, use <code>unbounded dynamic array</code> type.</p> <p>Example:</p> <pre><code>int32[] unbounded_integer_array\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#enumerations","title":"Enumerations","text":"<p>ROS 2 interfaces don't support enumerations directly.</p> <p>It is possible to define integers constants and assign them to a non-constant integer parameter.</p> <p>Constants are written in <code>CONSTANT_CASE</code>.</p> <p>Assign a different value to each element of a constant.</p> <p>Example from shape_msgs/msg/SolidPrimitive.msg</p> <pre><code>uint8 BOX=1\nuint8 SPHERE=2\nuint8 CYLINDER=3\nuint8 CONE=4\nuint8 PRISM=5\n\n# The type of the shape\nuint8 type\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#comments","title":"Comments","text":"<p>On top of the message, briefly explain what the message contains and/or what it is used for. For an example, see sensor_msgs/msg/Imu.msg.</p> <p>If necessary, add line comments before the fields that explain the context and/or meaning.</p> <p>For simple fields like <code>x, y, z, w</code> you might not need to add comments.</p> <p>Even though it is not strictly checked, try not to pass 100 characters in a line.</p> <p>Example:</p> <pre><code># Number of times the vehicle performed an emergency brake\nuint32 count_emergency_brake\n\n# Seconds passed since the last emergency brake\nuint64 duration\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/message-guidelines/#example-usages","title":"Example usages","text":"<ul> <li>Don't use unit suffixes for default types:<ul> <li>Bad: <code>float32 path_length_m</code></li> <li>Good: <code>float32 path_length</code></li> </ul> </li> <li>Don't prefix the units:<ul> <li>Bad: <code>float32 kmph_velocity_vehicle</code></li> <li>Good: <code>float32 velocity_vehicle_kmph</code></li> </ul> </li> <li>Use recommended suffixes if they are available in the table:<ul> <li>Bad: <code>float32 velocity_vehicle_km_h</code></li> <li>Good: <code>float32 velocity_vehicle_kmph</code></li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/parameters/","title":"Parameters","text":""},{"location":"contributing/coding-guidelines/ros-nodes/parameters/#parameters","title":"Parameters","text":"<p>Autoware ROS nodes have declared parameters which values are provided during the node start up in the form of a parameter file. All the expected parameters with corresponding values should exist in the parameter file. Depending on the application, the parameter values might need to be modified.</p> <p>Find more information on parameters from the official ROS documentation:</p> <ul> <li>Understanding ROS 2 Parameters</li> <li>About ROS 2 Parameters</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/parameters/#workflow","title":"Workflow","text":"<p>A ROS package which uses the declare_parameter(...) function should:</p> <ul> <li>use the declare_parameter(...) without a default value</li> <li>create a parameter file</li> <li>create a schema file</li> </ul> <p>The rationale behind this workflow is to have a verified single source of truth to pass to the ROS node and to be used in the web documentation. The approach reduces the risk of using invalid parameter values and makes maintenance of documentation easier. This is achieved by:</p> <ul> <li>declare_parameter(...) throws an exception if an expected parameter is missing in the parameter file</li> <li> <p>the schema validates the parameter file in the CI and renders a parameter table, as depicted in the graphics below</p> <pre><code>flowchart TD\n    NodeSchema[Schema file: *.schema.json]\n    ParameterFile[Parameter file: *.param.yaml]\n    WebDocumentation[Web documentation table]\n\n    NodeSchema --&gt;|Validation| ParameterFile\n    NodeSchema --&gt;|Generate| WebDocumentation</code></pre> </li> </ul> <p>Note: a parameter value can still be modified and bypass the validation, as there is no validation during runtime.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/parameters/#declare-parameter-function","title":"Declare Parameter Function","text":"<p>It is the declare_parameter(...) function which sets the parameter values during a node startup.</p> <pre><code>declare_parameter&lt;INSERT_TYPE&gt;(\"INSERT_PARAMETER_1_NAME\"),\ndeclare_parameter&lt;INSERT_TYPE&gt;(\"INSERT_PARAMETER_N_NAME\")\n</code></pre> <p>As there is no default_value provided, the function throws an exception if a parameter were to be missing in the provided <code>*.param.yaml</code> file. Use a type from the C++ Type column in the table below for the declare_parameter(...) function, replacing INSERT_TYPE.</p> ParameterType Enum C++ Type <code>PARAMETER_BOOL</code> <code>bool</code> <code>PARAMETER_INTEGER</code> <code>int64_t</code> <code>PARAMETER_DOUBLE</code> <code>double</code> <code>PARAMETER_STRING</code> <code>std::string</code> <code>PARAMETER_BYTE_ARRAY</code> <code>std::vector&lt;uint8_t&gt;</code> <code>PARAMETER_BOOL_ARRAY</code> <code>std::vector&lt;bool&gt;</code> <code>PARAMETER_INTEGER_ARRAY</code> <code>std::vector&lt;int64_t&gt;</code> <code>PARAMETER_DOUBLE_ARRAY</code> <code>std::vector&lt;double&gt;</code> <code>PARAMETER_STRING_ARRAY</code> <code>std::vector&lt;std::string&gt;</code> <p>The table has been derived from Parameter Type and Parameter Value.</p> <p>See example: Lidar Apollo Segmentation TVM Nodes declare function</p>"},{"location":"contributing/coding-guidelines/ros-nodes/parameters/#parameter-file","title":"Parameter File","text":"<p>The parameter file is minimal as there is no need to provide the user with additional information, e.g., description or type. This is because the associated schema file provides the additional information. Use the template below as a starting point for a ROS node.</p> <pre><code>/**:\nros__parameters:\nINSERT_PARAMETER_1_NAME: INSERT_PARAMETER_1_VALUE\nINSERT_PARAMETER_N_NAME: INSERT_PARAMETER_N_VALUE\n</code></pre> <p>Note: <code>/**</code> is used instead of the explicit node namespace, this allows the parameter file to be passed to a ROS node which has been remapped.</p> <p>To adapt the template to the ROS node, replace each <code>INSERT_PARAMETER_..._NAME</code> and <code>INSERT_PARAMETER_..._VALUE</code> for all parameters. Each declare_parameter(...) takes one parameter as input. All the parameter files should have the <code>.param.yaml</code> suffix so that the auto-format can be applied properly.</p> <p>Autoware has the following two types of parameter files for ROS packages:</p> <ul> <li>Node parameter file<ul> <li>Node parameter files store the default parameters provided for each package in Autoware.<ul> <li>For example, the parameter of <code>behavior_path_planner</code></li> </ul> </li> <li>All nodes in Autoware must have a parameter file if ROS parameters are declared in the node.</li> <li>For <code>FOO_package</code>, the parameter is expected to be stored in <code>FOO_package/config</code>.</li> <li>The launch file for individual packages must load node parameter by default:</li> </ul> </li> </ul> <pre><code>&lt;launch&gt;\n&lt;arg name=\"foo_node_param_path\" default=\"$(find-pkg-share FOO_package)/config/foo_node.param.yaml\" /&gt;\n\n&lt;node pkg=\"FOO_package\" exec=\"foo_node\"&gt;\n...\n    &lt;param from=\"$(var foo_node_param_path)\" /&gt;\n&lt;/node&gt;\n&lt;/launch&gt;\n</code></pre> <ul> <li>Launch parameter file<ul> <li>When a user creates a launch package for the user's vehicle, the user should copy node parameter files for the nodes that are called in the launch file as \"launch parameter files\".</li> <li>Launch parameter files are then customized specifically for user's vehicle.<ul> <li>For example, the customized parameter of <code>behavior_path_planner</code> stored under <code>autoware_launch</code></li> </ul> </li> <li>The examples for launch parameter files are stored under <code>autoware_launch</code>.</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/parameters/#json-schema","title":"JSON Schema","text":"<p>JSON Schema is used the validate the parameter file(s) ensuring that it has the correct structure and content. Using JSON Schema for this purpose is considered best practice for cloud-native development. The schema template below shall be used as a starting point when defining the schema for a ROS node.</p> <pre><code>{\n\"$schema\": \"http://json-schema.org/draft-07/schema#\",\n\"title\": \"INSERT_TITLE\",\n\"type\": \"object\",\n\"definitions\": {\n\"INSERT_ROS_NODE_NAME\": {\n\"type\": \"object\",\n\"properties\": {\n\"INSERT_PARAMETER_1_NAME\": {\n\"type\": \"INSERT_TYPE\",\n\"description\": \"INSERT_DESCRIPTION\",\n\"default\": \"INSERT_DEFAULT\",\n\"INSERT_BOUND_CONDITION(S)\": INSERT_BOUND_VALUE(S)\n},\n\"INSERT_PARAMETER_N_NAME\": {\n\"type\": \"INSERT_TYPE\",\n\"description\": \"INSERT_DESCRIPTION\",\n\"default\": \"INSERT_DEFAULT\",\n\"INSERT_BOUND_CONDITION(S)\": INSERT_BOUND_VALUE(S)\n}\n},\n\"required\": [\"INSERT_PARAMETER_1_NAME\", \"INSERT_PARAMETER_N_NAME\"],\n\"additionalProperties\": false\n}\n},\n\"properties\": {\n\"/**\": {\n\"type\": \"object\",\n\"properties\": {\n\"ros__parameters\": {\n\"$ref\": \"#/definitions/INSERT_ROS_NODE_NAME\"\n}\n},\n\"required\": [\"ros__parameters\"],\n\"additionalProperties\": false\n}\n},\n\"required\": [\"/**\"],\n\"additionalProperties\": false\n}\n</code></pre> <p>The schema file path is <code>INSERT_PATH_TO_PACKAGE/schema/</code> and the schema file name is <code>INSERT_NODE_NAME.schema.json</code>. To adapt the template to the ROS node, replace each <code>INSERT_...</code> and add all parameters <code>1..N</code>.</p> <p>See example: Lidar Apollo Segmentation TVM Nodes schema</p>"},{"location":"contributing/coding-guidelines/ros-nodes/parameters/#attributes","title":"Attributes","text":"<p>Parameters have several attributes, some are required and some optional. The optional attributes are highly encouraged when applicable, as they provide useful information about a parameter and can ensure the value of the parameter is within its bounds.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/parameters/#required","title":"Required","text":"<ul> <li>name</li> <li>type<ul> <li>see JSON Schema types</li> </ul> </li> <li>description</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/parameters/#optional","title":"Optional","text":"<ul> <li>default<ul> <li>a tested and verified value, see JSON Schema default</li> </ul> </li> <li>bound(s)<ul> <li>type dependent, e.g., integer, range and size</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/parameters/#tips-and-tricks","title":"Tips and Tricks","text":"<p>Using well established standards enables the use of conventional tooling. Below is an example of how to link a schema to the parameter file(s) using VS Code. This enables a developer with convenient features such as auto-complete and parameter bound validation.</p> <p>In the root directory of where the project is hosted, create a <code>.vscode</code> folder with two files; <code>extensions.json</code> containing</p> <pre><code>{\n\"recommendations\": [\"redhat.vscode-yaml\"]\n}\n</code></pre> <p>and <code>settings.json</code> containing</p> <pre><code>{\n\"yaml.schemas\": {\n\"./INSERT_PATH_TO_PACKAGE/schema/INSERT_NODE_NAME.schema.json\": \"**/INSERT_NODE_NAME/config/*.param.yaml\"\n}\n}\n</code></pre> <p>The RedHat YAML extension enables validation of YAML files using JSON Schema and the <code>\"yaml.schemas\"</code> setting associates the <code>*.schema.json</code> file with all <code>*.param.yaml</code> files in the <code>config/</code> folder.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/task-scheduling/","title":"Task scheduling","text":""},{"location":"contributing/coding-guidelines/ros-nodes/task-scheduling/#task-scheduling","title":"Task scheduling","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-namespaces/","title":"Topic namespaces","text":""},{"location":"contributing/coding-guidelines/ros-nodes/topic-namespaces/#topic-namespaces","title":"Topic namespaces","text":""},{"location":"contributing/coding-guidelines/ros-nodes/topic-namespaces/#overview","title":"Overview","text":"<p>ROS allows topics, parameters and nodes to be namespaced which provides the following benefits:</p> <ul> <li>Multiple instances of the same node type will not cause naming clashes.</li> <li>Topics published by a node can be automatically namespaced with the node's namespace providing a meaningful and easily-visible connection.</li> <li>Keeps from cluttering the root namespace.</li> <li>Helps to maintain separation-of-concerns.</li> </ul> <p>This page focuses on how to use namespaces in Autoware and shows some useful examples. For basic information on topic namespaces, refer to this tutorial.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-namespaces/#how-topics-should-be-named-in-node","title":"How topics should be named in node","text":"<p>Autoware divides the node into the following functional categories, and adds the start namespace for the nodes according to the categories.</p> <ul> <li>localization</li> <li>perception</li> <li>planning</li> <li>control</li> <li>sensing</li> <li>vehicle</li> <li>map</li> <li>system</li> </ul> <p>When a node is run in a namespace, all topics which that node publishes are given that same namespace. All nodes in the Autoware stack must support namespaces by avoiding practices such as publishing topics in the global namespace.</p> <p>In general, topics should be namespaced based on the function of the node which produces them and not the node (or nodes) which consume them.</p> <p>Classify topics as input or output topics based on they are subscribed or published by the node. In the node, input topic is named <code>input/topic_name</code> and output topic is named <code>output/topic_name</code>.</p> <p>Configure the topic in the node's launch file. Take the <code>joy_controller</code> node as an example, in the following example, set the input and output topics and remap topics in the <code>joy_controller.launch.xml</code> file.</p> <pre><code>&lt;launch&gt;\n&lt;arg name=\"input_joy\" default=\"/joy\"/&gt;\n&lt;arg name=\"input_odometry\" default=\"/localization/kinematic_state\"/&gt;\n\n&lt;arg name=\"output_control_command\" default=\"/external/$(var external_cmd_source)/joy/control_cmd\"/&gt;\n&lt;arg name=\"output_external_control_command\" default=\"/api/external/set/command/$(var external_cmd_source)/control\"/&gt;\n&lt;arg name=\"output_shift\" default=\"/api/external/set/command/$(var external_cmd_source)/shift\"/&gt;\n&lt;arg name=\"output_turn_signal\" default=\"/api/external/set/command/$(var external_cmd_source)/turn_signal\"/&gt;\n&lt;arg name=\"output_heartbeat\" default=\"/api/external/set/command/$(var external_cmd_source)/heartbeat\"/&gt;\n&lt;arg name=\"output_gate_mode\" default=\"/control/gate_mode_cmd\"/&gt;\n&lt;arg name=\"output_vehicle_engage\" default=\"/vehicle/engage\"/&gt;\n\n&lt;node pkg=\"joy_controller\" exec=\"joy_controller\" name=\"joy_controller\" output=\"screen\"&gt;\n&lt;remap from=\"input/joy\" to=\"$(var input_joy)\"/&gt;\n&lt;remap from=\"input/odometry\" to=\"$(var input_odometry)\"/&gt;\n\n&lt;remap from=\"output/control_command\" to=\"$(var output_control_command)\"/&gt;\n&lt;remap from=\"output/external_control_command\" to=\"$(var output_external_control_command)\"/&gt;\n&lt;remap from=\"output/shift\" to=\"$(var output_shift)\"/&gt;\n&lt;remap from=\"output/turn_signal\" to=\"$(var output_turn_signal)\"/&gt;\n&lt;remap from=\"output/gate_mode\" to=\"$(var output_gate_mode)\"/&gt;\n&lt;remap from=\"output/heartbeat\" to=\"$(var output_heartbeat)\"/&gt;\n&lt;remap from=\"output/vehicle_engage\" to=\"$(var output_vehicle_engage)\"/&gt;\n&lt;/node&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-namespaces/#topic-names-in-the-code","title":"Topic names in the code","text":"<ol> <li> <p>Have <code>~</code> so that namespace in launch configuration is applied(should not start from root <code>/</code>).</p> </li> <li> <p>Have <code>~/input</code> <code>~/output</code> namespace before topic name used to communicate with other nodes.</p> <p>e.g., In node <code>obstacle_avoidance_planner</code>, using topic names of type <code>~/input/topic_name</code> to subscribe to topics.</p> <pre><code>objects_sub_ = create_subscription&lt;PredictedObjects&gt;(\n\"~/input/objects\", rclcpp::QoS{10},\nstd::bind(&amp;ObstacleAvoidancePlanner::onObjects, this, std::placeholders::_1));\n</code></pre> <p>e.g., In node <code>obstacle_avoidance_planner</code>, using topic names of type <code>~/output/topic_name</code> to publish topic.</p> <pre><code>traj_pub_ = create_publisher&lt;Trajectory&gt;(\"~/output/path\", 1);\n</code></pre> </li> <li> <p>Visualization or debug purpose topics should have <code>~/debug/</code> namespace.</p> <p>e.g., In node <code>obstacle_avoidance_planner</code>, in order to debug or visualizing topics, using topic names of type <code>~/debug/topic_name</code> to publish information.</p> <pre><code>debug_markers_pub_ =\ncreate_publisher&lt;visualization_msgs::msg::MarkerArray&gt;(\"~/debug/marker\", durable_qos);\n\ndebug_msg_pub_ =\ncreate_publisher&lt;tier4_debug_msgs::msg::StringStamped&gt;(\"~/debug/calculation_time\", 1);\n</code></pre> <p>The launch configured namespace will be add the topics before, so the topic names will be as following:</p> <p><code>/planning/scenario_planning/lane_driving/motion_planning/obstacle_avoidance_planner/debug/marker /planning/scenario_planning/lane_driving/motion_planning/obstacle_avoidance_planner/debug/calculation_time</code></p> </li> <li> <p>Rationale: we want to make topic names remapped and configurable from launch files.</p> </li> </ol>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/","title":"Topic message handling guideline","text":""},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#topic-message-handling-guideline","title":"Topic message handling guideline","text":""},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#introduction","title":"Introduction","text":"<p>Here is coding guideline for topic message handling in Autoware. It includes the recommended manner than conventional one, which is roughly explained in Discussions page. Refer to the page to understand the basic concept of the recommended manner. You can find sample source code in ros2_subscription_examples referred from this document.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#conventional-message-handling-manner","title":"Conventional message handling manner","text":"<p>At first, let us see a conventional manner of handling messages that is commonly used. ROS 2 Tutorials is one of the most cited references for ROS 2 applications, including Autoware. It implicitly recommends that each of messages received by subscriptions should be referred to and processed by a dedicated callback function. Autoware follows that manner thoroughly.</p> <pre><code>  steer_sub_ = create_subscription&lt;SteeringReport&gt;(\n\"input/steering\", 1,\n[this](SteeringReport::SharedPtr msg) { current_steer_ = msg-&gt;steering_tire_angle; });\n</code></pre> <p>In the code above, when a topic message whose name is <code>input/steering</code> is received, an anonymous function whose description is <code>{current_steer_ = msg-&gt;steering_tier_angle;}</code> is executed as a callback in a thread. The callback function is always executed when the message is received, which leads to waste computing resource if the message is not always necessary. Besides, waking up a thread costs computational overhead.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#recommended-manner","title":"Recommended manner","text":"<p>This section introduces a recommended manner to take a message using <code>Subscription-&gt;take()</code> method only when the message is needed. The sample code given below shows that <code>Subscription-&gt;take()</code> method is called during execution of any callback function. In most cases, <code>Subscription-&gt;take()</code> method is called before a received message is consumed by a main logic. In this case, a topic message is retrieved from the subscription queue, the queue embedded in the subscription object, instead of using a callback function. To be precise, you have to program your code so that a callback function is not automatically called.</p> <pre><code>  SteeringReport msg;\nrclcpp::MessageInfo msg_info;\nif (sub_-&gt;take(msg, msg_info)) {\n// processing and publishing after this\n</code></pre> <p>Using this manner has the following benefits.</p> <ul> <li>It can reduce the number of calls to subscription callback functions</li> <li>There is no need to take a topic message from a subscription that a main logic does not consume</li> <li>There is no mandatory thread waking for the callback function, which leads to multi-threaded programming, data races and exclusive locking</li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#manners-to-handle-topic-message-data","title":"Manners to handle topic message data","text":"<p>This section introduces four manners, including the recommended ones.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#1-obtain-data-by-calling-subscription-take","title":"1. Obtain data by calling <code>Subscription-&gt;take()</code>","text":"<p>To use the recommended manner using <code>Subscription-&gt;take()</code>, you basically need to do two things below.</p> <ol> <li>Prevent a callback function from being called when a topic message is received</li> <li>Call <code>take()</code> method of a subscription object when a topic message is needed</li> </ol> <p>You can see an example of the typical use of <code>take()</code> method in ros2_subscription_examples/simple_examples/src/timer_listener.cpp.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#prevent-calling-a-callback-function","title":"Prevent calling a callback function","text":"<p>To prevent a callback function from being called automatically, the callback function has to belong a callback group whose callback functions are not added to any executor. According to the API specification of <code>create_subscription</code>, registering a callback function to a <code>rclcpp::Subscription</code> based object is mandatory even if the callback function has no operation. Here is a sample code snippet from ros2_subscription_examples/simple_examples/src/timer_listener.cpp.</p> <pre><code>    rclcpp::CallbackGroup::SharedPtr cb_group_not_executed = this-&gt;create_callback_group(\nrclcpp::CallbackGroupType::MutuallyExclusive, false);\nauto subscription_options = rclcpp::SubscriptionOptions();\nsubscription_options.callback_group = cb_group_not_executed;\n\nrclcpp::QoS qos(rclcpp::KeepLast(10));\nif (use_transient_local) {\nqos = qos.transient_local();\n}\n\nsub_ = create_subscription&lt;std_msgs::msg::String&gt;(\"chatter\", qos, not_executed_callback, subscription_options);\n</code></pre> <p>In the code above, <code>cb_group_not_executed</code> is created by calling <code>create_callback_group</code> with the second argument <code>false</code>. Any callback function which belongs to the callback group will not be called by an executor. If the <code>callback_group</code> member of <code>subscription_options</code> is set to <code>cb_group_not_executed</code>, then <code>not_executed_callback</code> will not be called when a corresponding topic message <code>chatter</code> is received. The second argument to <code>create_callback_group</code> is defined as follows.</p> <pre><code>rclcpp::CallbackGroup::SharedPtr create_callback_group(rclcpp::CallbackGroupType group_type, \\\n                                  bool automatically_add_to_executor_with_node = true)\n</code></pre> <p>When <code>automatically_add_to_executor_with_node</code> is set to <code>true</code>, callback functions included in a node that is added to an executor will be automatically called by the executor.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#call-take-method-of-subscription-object","title":"Call <code>take()</code> method of Subscription object","text":"<p>To take a topic message from the <code>Subscription</code> based object, the <code>take()</code> method is called at the expected time. Here is a sample code snippet from ros2_subscription_examples/simple_examples/src/timer_listener.cpp using <code>take()</code> method.</p> <pre><code>  std_msgs::msg::String msg;\nrclcpp::MessageInfo msg_info;\nif (sub_-&gt;take(msg, msg_info)) {\nRCLCPP_INFO(this-&gt;get_logger(), \"Catch message\");\nRCLCPP_INFO(this-&gt;get_logger(), \"I heard: [%s]\", msg.data.c_str());\n</code></pre> <p>In the code above, <code>take(msg, msg_info)</code> is called by <code>sub_</code> object instantiated from the <code>rclcpp::Subscription</code> class. It is called in a timer driven callback function. <code>msg</code> and <code>msg_info</code> indicate a message body and its metadata respectively. If there is a message in the subscription queue when <code>take(msg, msg_info)</code> is called, then the message is copied to <code>msg</code>. <code>take(msg, msg_info)</code> returns <code>true</code> if a message is successfully taken from the subscription. In this case, the above code prints out a string data of the message from <code>RCLCPP_INFO</code>. <code>take(msg, msg_info)</code> returns <code>false</code> if a message is not taken from the subscription. When <code>take(msg, msg_info)</code> is called, if the size of the subscription queue is greater than one and there are two or more messages in the queue, then the oldest message is copied to <code>msg</code>. If the size of the queue is one, the latest message is always obtained.</p> <p>Note</p> <p>You can check the presence of incoming message with the returned value of <code>take()</code> method. However, you have to take care of the destructive nature of the take() method. The <code>take()</code> method modifies the subscription queue. Also, the <code>take()</code> method is irreversible and there is no undo operation against the <code>take()</code> method. Checking the incoming message with only the <code>take()</code> method always changes the subscription queue. If you want to check without changing the subscription queue, rclcpp::WaitSet is recommended. Refer to [supplement] Use rclcpp::WaitSet for more detail.</p> <p>Note</p> <p>The <code>take()</code> method is supported to only obtain a message which is passed through DDS as an inter-process communication. You must not use it for an intra-process communication because intra-process communication is based on another software stack of <code>rclcpp</code>. Refer to [supplement] Obtain a received message through intra-process communication in case of intra-process communication.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#11-obtain-serialized-message-from-subscription","title":"1.1 Obtain Serialized Message from Subscription","text":"<p>ROS 2 provides Serialized Message function which supports communication with arbitrary message types as described in Class SerializedMessage. It is used by <code>topic_state_monitor</code> in Autoware. You have to use the <code>take_serialized()</code> method instead of the <code>take()</code> method to obtain a <code>rclcpp::SerializedMessage</code> based message from a subscription.</p> <p>Here is a sample code snippet from ros2_subscription_examples/simple_examples/src/timer_listener_serialized_message.cpp.</p> <pre><code>      // receive the serialized message.\nrclcpp::MessageInfo msg_info;\nauto msg = sub_-&gt;create_serialized_message();\n\nif (sub_-&gt;take_serialized(*msg, msg_info) == false) {\nreturn;\n}\n</code></pre> <p>In the code above, <code>msg</code> is created by <code>create_serialized_message()</code> to store a received message, whose type is <code>std::shared_ptr&lt;rclcpp::SerializedMessage&gt;</code>. You can obtain a message of type <code>rclcpp::SerializedMessage</code> using the <code>take_serialized()</code> method. Note that the <code>take_serialized()</code> method needs reference type data as its first argument. Since <code>msg</code> is a pointer, <code>*msg</code> should be passed as the first argument to the `take_serialized().</p> <p>Note</p> <p>ROS 2's <code>rclcpp</code> supports both <code>rclcpp::LoanedMessage</code> and <code>rclcpp::SerializedMessage</code>. If zero copy communication via loaned messages is introduced to Autoware, <code>take_loaned()</code> method should be used for communication via loaned messages instead. In this document, the explanation of the <code>take_loaned()</code> method is omitted because it is not used for Autoware in this time (May. 2024).</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#2-obtain-multiple-data-stored-in-subscription-queue","title":"2. Obtain multiple data stored in Subscription Queue","text":"<p>A subscription object can hold multiple messages in its queue if multiple queue size is configured with the QoS setting. The conventional manner using callback function forces a callback function to be executed per message. In other words, there is a constraint; a single cycle of callback function processes a single message . Note that with the conventional manner, if there are one or more messages in the subscription queue, the oldest one is taken and a thread is assigned to execute a callback function, which continues until the queue is empty. The <code>take()</code> method would alleviate this limitation. The <code>take()</code> method can be called in multiple iterations, so that a single cycle of the callback function processes multiple messages taken by <code>take()</code> methods.</p> <p>Here is a sample code, taken from ros2_subscription_examples/simple_examples/src/timer_batch_listener.cpp which calls the <code>take()</code> method in a single cycle of a callback function.</p> <pre><code>      std_msgs::msg::String msg;\nrclcpp::MessageInfo msg_info;\nwhile (sub_-&gt;take(msg, msg_info))\n{\nRCLCPP_INFO(this-&gt;get_logger(), \"Catch message\");\nRCLCPP_INFO(this-&gt;get_logger(), \"I heard: [%s]\", msg.data.c_str());\n</code></pre> <p>In the code above, <code>while(sub-&gt;take(msg, msg_info))</code> continues to take messages from the subscription queue until the queue is empty. Each message taken is processed per iteration. Note that you must determine size of a subscription queue by considering both frequency of a callback function and frequency of a message reception. For example, if a callback function is invoked at 10Hz and topic messages are received at 50Hz, the size of the subscription queue must be at least 5 to avoid losing received messages.</p> <p>Assigning a thread to execute a callback function per message will cause performance overhead. You can use the manner introduced in this section to avoid the unexpected overhead. The manner will be effective when there is a large difference between reception frequency and consumption frequency. For example, even if a message, such as a CAN message, is received at higher than 100 Hz, a user logic consumes messages at slower frequency such as 10 Hz. In such a case, the user logic should retrieve the required number of messages with the <code>take()</code> method to avoid the unexpected overhead.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#3-obtain-data-by-calling-subscription-take-and-then-call-a-callback-function","title":"3. Obtain data by calling <code>Subscription-&gt;take</code> and then call a callback function","text":"<p>You can combine the <code>take()</code> (strictly <code>take_type_erased()</code>) method and the callback function to process received messages in a consistent way. Using this combination does not require waking up a thread. Here is a sample code snippet from ros2_subscription_examples/simple_examples/src/timer_listener_using_callback.cpp.</p> <pre><code>      auto msg = sub_-&gt;create_message();\nrclcpp::MessageInfo msg_info;\nif (sub_-&gt;take_type_erased(msg.get(), msg_info)) {\nsub_-&gt;handle_message(msg, msg_info);\n</code></pre> <p>In the code above, a message is taken by the <code>take_type_erased()</code> method before a registered callback function is called via the <code>handle_message()</code> method. Note that you must use <code>take_type_erased()</code> instead of <code>take()</code>. <code>take_type_erased()</code> needs <code>void</code> type data as its first argument. You must use the <code>get()</code> method to convert <code>msg</code> whose type is <code>shared_ptr&lt;void&gt;</code> to <code>void</code> type. Then the <code>handle_message()</code> method is called with the obtained message. A registered callback function is called within <code>handle_message()</code>. You don't need to take care of message type which is passed to <code>take_type_erased()</code> and <code>handle_message()</code>. You can define the message variable as <code>auto msg = sub_-&gt;create_message();</code>. You can also refer to the API document as for <code>create_message()</code>, <code>take_type_erased()</code> and <code>handle_message()</code>.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#4-obtain-data-by-a-callback-function","title":"4. Obtain data by a callback function","text":"<p>A conventional manner, typically used in ROS 2 application, is a message reference using a callback function, is available. If you don't use a callback group with <code>automatically_add_to_executor_with_node = false</code>, a registered callback function will be called automatically by an executor when a topic message is received. One of the advantages of this manner is that you don't have to take care whether a topic message is passed through inter-process or intra-process. Remember that <code>take()</code> can only be used for inter-process communication via DDS, while another manner provided by <code>rclcpp</code> can be used for intra-process communication via <code>rclcpp</code>.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/#appendix","title":"Appendix","text":"<p>A callback function is used to obtain a topic message in many of ROS 2 applications. It is as like a rule or a custom. As this document page explains, you can use the <code>Subscription-&gt;take()</code> method to obtain a topic message without calling a subscription callback function. This manner is also documented in Template Class Subscription \u2014 rclcpp 16.0.8 documentation.</p> <p>Many of ROS 2 users may be afraid to use the <code>take()</code> method because they may not be so familiar with it and there is a lack of documentation about <code>take()</code>, but it is widely used in the <code>rclcpp::Executor</code> implementation as shown in rclcpp/executor.cpp shown below. So it turns out that you are indirectly using the <code>take()</code> method, whether you know it or not.</p> <pre><code>    std::shared_ptr&lt;void&gt; message = subscription-&gt;create_message();\ntake_and_do_error_handling(\n\"taking a message from topic\",\nsubscription-&gt;get_topic_name(),\n[&amp;]() {return subscription-&gt;take_type_erased(message.get(), message_info);},\n[&amp;]() {subscription-&gt;handle_message(message, message_info);});\n</code></pre> <p>Note</p> <p>Strictly speaking, the <code>take_type_erased()</code> method is called in the executor, but not the <code>take()</code> method.</p> <p>But <code>take_type_erased()</code> is the embodiment of <code>take()</code>, while <code>take()</code> internally calls <code>take_type_erased()</code>.</p> <p>If <code>rclcpp::Executor</code> based object, an executor, is programmed to call a callback function, the executor itself determines when to do it. Because the executor is essentially calling a best-effort callback function, the message is not guaranteed to be necessarily referenced or processed even though it is received. Therefore it is desirable to call the <code>take()</code> method directly to ensure that a message is referenced or processed at the intended time.</p> <p>As of May 2024, the recommended manners are beginning to be used in Autoware Universe. See the following PR if you want an example in Autoware Universe.</p> <p>feat(tier4_autoware_utils, obstacle_cruise): change to read topic by polling #6702</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-intra-process-comm/","title":"[supplement] Obtain a received message through intra-process communication","text":""},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-intra-process-comm/#supplement-obtain-a-received-message-through-intra-process-communication","title":"[supplement] Obtain a received message through intra-process communication","text":""},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-intra-process-comm/#topic-message-handling-in-intra-process-communication","title":"Topic message handling in intra-process communication","text":"<p><code>rclcpp</code> supports intra-process communication. As explained in Topic message handling guideline, <code>take()</code> method can not be used in the case of intra-process communication. <code>take()</code> can not return a topic message which is received through inter-process communication. However, methods for intra-process communication are provided, similar to the methods for inter-process communication described in obtain data by calling Subscription-&gt;take and then call a callback function. <code>take_data()</code> method is provided to obtain a received data in the case of intra-process communication and the received data must be processed through <code>execute()</code> method. The return value of <code>take_data()</code> is based on the complicated data structure, <code>execute()</code> method should be used along with <code>take_data()</code> method. Refer to Template Class SubscriptionIntraProcess \u2014 rclcpp 16.0.8 documentation for <code>take_data()</code> and <code>execute()</code> for more detail.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-intra-process-comm/#coding-manner","title":"Coding manner","text":"<p>To handle messages via intra-process communication, call <code>take_data()</code> method and then <code>execute()</code> method as below.</p> <pre><code>// Execute any entities of the Waitable that may be ready\nstd::shared_ptr&lt;void&gt; data = waitable.take_data();\nwaitable.execute(data);\n</code></pre> <p>Here is a sample program in ros2_subscription_examples/intra_process_talker_listener/src/timer_listener_intra_process.cpp at main \u00b7 takam5f2/ros2_subscription_examples. You can run the program as below. If you set <code>true</code> to <code>use_intra_process_comms</code>, intra-process communication is performed, while if you set <code>false</code>, inter-process communication is performed.</p> <pre><code>ros2 intra_process_talker_listener talker_listener_intra_process.launch.py use_intra_process_comms:=true\n</code></pre> <p>Here is a snippet of ros2_subscription_examples/intra_process_talker_listener/src/timer_listener_intra_process.cpp at main \u00b7 takam5f2/ros2_subscription_examples.</p> <pre><code>      // check if intra-process communication is enabled.\nif (this-&gt;get_node_options().use_intra_process_comms()){\n\n// get the intra-process subscription's waitable.\nauto intra_process_sub = sub_-&gt;get_intra_process_waitable();\n\n// check if the waitable has data.\nif (intra_process_sub-&gt;is_ready(nullptr) == true) {\n\n// take the data and execute the callback.\nstd::shared_ptr&lt;void&gt; data = intra_process_sub-&gt;take_data();\n\nRCLCPP_INFO(this-&gt;get_logger(), \" Intra-process communication is performed.\");\n\n// execute the callback.\nintra_process_sub-&gt;execute(data);\n</code></pre> <p>Below is a line-by-line explanation of the above code.</p> <ul> <li> <p><code>if (this-&gt;get_node_options().use_intra_process_comms()){</code></p> <ul> <li>The statement checks whether or not intra-process communication is enabled or not by using <code>NodeOptions</code></li> </ul> </li> </ul> <ul> <li> <p><code>auto intra_process_sub = sub_-&gt;get_intra_process_waitable();</code></p> <ul> <li>The statement means to get an embodied object which performs intra-process communication</li> </ul> </li> </ul> <ul> <li> <p><code>if (intra_process_sub-&gt;is_ready(nullptr) == true) {</code></p> <ul> <li>The statement checks if a message has already been received through intra-process communication</li> <li>The argument of <code>is_ready()</code> is of type <code>rcl_wait_set_t</code> type, but because the argument is not used within <code>is_ready()</code>, <code>nullptr</code> is used for the moment.<ul> <li>Using <code>nullptr</code> is currently a workaround, as it has no intent.</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p><code>std::shared_ptr&lt;void&gt; data = intra_process_sub-&gt;take_data();</code></p> <ul> <li>This statement means to obtain a topic message from subscriptions for intra-process communication.</li> <li><code>intra_process_sub-&gt;take_data()</code> does not return a boolean value indicating whether a message is received successfully or not, so it is necessary to check this by calling <code>is_ready()</code> beforehand</li> </ul> </li> </ul> <ul> <li><code>intra_process_sub-&gt;execute(data);</code><ul> <li>A callback function corresponding to the received message is called within <code>execute()</code></li> <li>The callback function is executed by the thread that calls <code>execute()</code> without a context switch</li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-wait_set/","title":"[supplement] Use rclcpp::WaitSet","text":""},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-wait_set/#supplement-use-rclcppwaitset","title":"[supplement] Use rclcpp::WaitSet","text":""},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-wait_set/#what-is-rclcppwaitset","title":"What is <code>rclcpp::WaitSet</code>","text":"<p>As explained in call take() method of Subscription object, the <code>take()</code> method is irreversible. Once the <code>take()</code> method is executed, a state of a subscription object changes. Because there is no undo operation against the <code>take()</code> method, the subscription object can not be restored to its previous state. You can use the <code>rclcpp::WaitSet</code> before calling the <code>take()</code> to check the arrival of an incoming message in the subscription queue. The following sample code shows how the <code>wait_set_.wait()</code> tells you that a message has already been received and can be obtained by the <code>take()</code>.</p> <pre><code>      auto wait_result = wait_set_.wait(std::chrono::milliseconds(0));\nif (wait_result.kind() == rclcpp::WaitResultKind::Ready &amp;&amp;\nwait_result.get_wait_set().get_rcl_wait_set().subscriptions[0]) {\nsub_-&gt;take(msg, msg_info);\nRCLCPP_INFO(this-&gt;get_logger(), \"Catch message\");\nRCLCPP_INFO(this-&gt;get_logger(), \"I heard: [%s]\", msg.data.c_str());\n</code></pre> <p>A single <code>rclcpp::WaitSet</code> object is able to observe multiple subscription objects. If there are multiple subscriptions for different topics, you can check the arrival of incoming messages per subscription. Algorithms used in the field of autonomous robots requires multiple incoming messages, such as sensor data or actuation state. Using <code>rclcpp::WaitSet</code> for the multiple subscriptions, they are able to check whether or not required messages have arrived without taking any message.</p> <pre><code>      auto wait_result = wait_set_.wait(std::chrono::milliseconds(0));\nbool received_all_messages = false;\nif (wait_result.kind() == rclcpp::WaitResultKind::Ready) {\nfor (auto wait_set_subs : wait_result.get_wait_set().get_rcl_wait_set().subscriptions) {\nif (!wait_set_subs) {\nRCLCPP_INFO_THROTTLE(get_logger(), clock, 5000, \"Waiting for data...\");\nreturn {};\n}\n}\nreceived_all_mesages = true;\n}\n</code></pre> <p>In the code above, unless <code>rclcpp::WaitSet</code> is used, it is impossible to verify the arrival of all needed messages without changing state of the subscription objects.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-wait_set/#coding-manner","title":"Coding manner","text":"<p>This section explains how to code using <code>rclcpp::WaitSet</code> with a sample code below.</p> <ul> <li>ros2_subscription_examples/waitset_examples/src/talker_triple.cpp at main \u00b7 takam5f2/ros2_subscription_examples<ul> <li>It periodically publishes <code>/chatter</code> every second, <code>/slower_chatter</code> every two seconds, and <code>/slowest_chatter</code> every three seconds.</li> </ul> </li> <li>ros2_subscription_examples/waitset_examples/src/timer_listener_triple_async.cpp at main \u00b7 takam5f2/ros2_subscription_examples<ul> <li>It queries <code>WaitSet</code> per one second and if there is a message available, it obtains the message with <code>take()</code></li> <li>It has three subscriptions for <code>/chatter</code> <code>/slower_chatter</code>, and <code>/slower_chatter</code></li> </ul> </li> </ul> <p>The following three steps are required to use <code>rclcpp::WaitSet</code>.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-wait_set/#1-declare-and-initialize-waitset","title":"1. Declare and initialize <code>WaitSet</code>","text":"<p>You must first instantiate a <code>rclcpp::WaitSet</code> based object. Below is a snippet from ros2_subscription_examples/waitset_examples/src/timer_listener_triple_async.cpp at main \u00b7 takam5f2/ros2_subscription_examples.</p> <pre><code>rclcpp::WaitSet wait_set_;\n</code></pre> Note <p>There are several types of classes similar to the <code>rclcpp::WaitSet</code>. The <code>rclcpp::WaitSet</code> object can be configured during runtime. It is not thread-safe as explained in the API specification of <code>rclcpp::WaitSet</code> The thread-safe classes that are replacements for <code>rclcpp::WaitSet' are provided by the</code>rclcpp' package as listed below.</p> <ul> <li>Typedef rclcpp::ThreadSafeWaitSet<ul> <li>Subscription, timer, etc. can only be registered to <code>ThreadSafeWaitSet</code> only in thread-safe state</li> <li>Sample code is here: examples/rclcpp/wait_set/src/thread_safe_wait_set.cpp at rolling \u00b7 ros2/examples</li> </ul> </li> <li>Typedef rclcpp::StaticWaitSet<ul> <li>Subscription, timer, etc. can be registered to <code>rclcpp::StaticWaitSet</code> only at initialization</li> <li>Here are sample code:<ul> <li>ros2_subscription_examples/waitset_examples/src/timer_listener_twin_static.cpp at main \u00b7 takam5f2/ros2_subscription_examples</li> <li>examples/rclcpp/wait_set/src/static_wait_set.cpp at rolling \u00b7 ros2/examples</li> </ul> </li> </ul> </li> </ul>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-wait_set/#2-register-trigger-subscription-timer-and-so-on-to-waitset","title":"2. Register trigger (Subscription, Timer, and so on) to <code>WaitSet</code>","text":"<p>You need to register a trigger to the <code>rclcpp::WaitSet</code> based object. The following is a snippet from ros2_subscription_examples/waitset_examples/src/timer_listener_triple_async.cpp at main \u00b7 takam5f2/ros2_subscription_examples</p> <pre><code>    subscriptions_array_[0] = create_subscription&lt;std_msgs::msg::String&gt;(\"chatter\", qos, not_executed_callback, subscription_options);\nsubscriptions_array_[1] = create_subscription&lt;std_msgs::msg::String&gt;(\"slower_chatter\", qos, not_executed_callback, subscription_options);\nsubscriptions_array_[2] = create_subscription&lt;std_msgs::msg::String&gt;(\"slowest_chatter\", qos, not_executed_callback, subscription_options);\n\n// Add subscription to waitset\nfor (auto &amp; subscription : subscriptions_array_) {\nwait_set_.add_subscription(subscription);\n}\n</code></pre> <p>In the code above, the <code>add_subscription()</code> method registers the created subscriptions with the <code>wait_set_</code> object. A <code>rclcpp::WaitSet</code>-based object basically handles objects each of which has a corresponding callback function. Not only<code>Subscription</code>based objects, but also <code>Timer</code>,<code>Service</code>or<code>Action</code>based objects can be observed by a <code>rclcpp::WaitSet</code> based object. A single<code>rclcpp::WaitSet</code> object accepts mixture of different types of objects. A sample code for registering timer triggers can be found here.</p> <pre><code>wait_set_.add_timer(much_slower_timer_);\n</code></pre> <p>A trigger can be registered at declaration and initialization as described in wait_set_topics_and_timer.cpp from the examples.</p>"},{"location":"contributing/coding-guidelines/ros-nodes/topic-message-handling/supp-wait_set/#3-verify-waitset-result","title":"3. Verify WaitSet result","text":"<p>The data structure of the test result returned from the <code>rclcpp::WaitSet</code> is nested. You can find the <code>WaitSet</code> result by the following 2 steps;</p> <ol> <li>Verify if any trigger has been invoked</li> <li>Verify if a specified trigger has been triggered</li> </ol> <p>For step 1, here is a sample code taken from ros2_subscription_examples/waitset_examples/src/timer_listener_triple_async.cpp at main \u00b7 takam5f2/ros2_subscription_examples.</p> <pre><code>      auto wait_result = wait_set_.wait(std::chrono::milliseconds(0));\nif (wait_result.kind() == rclcpp::WaitResultKind::Ready) {\nRCLCPP_INFO(this-&gt;get_logger(), \"wait_set tells that some subscription is ready\");\n} else {\nRCLCPP_INFO(this-&gt;get_logger(), \"wait_set tells that any subscription is not ready and return\");\nreturn;\n}\n</code></pre> <p>In the code above, <code>auto wait_result = wait_set_.wait(std::chrono::milliseconds(0))</code> tests if a trigger in <code>wait_set_</code> has been called. The argument to the<code>wait()</code>method is the timeout duration. If it is greater than 0 milliseconds or seconds, this method will wait for a message to be received until the timeout expires. If<code>wait_result.kind() == rclcpp::WaitResultKind::Ready</code>is<code>true</code>, then any trigger has been invoked.</p> <p>For step 2, here is a sample code taken from ros2_subscription_examples/waitset_examples/src/timer_listener_triple_async.cpp at main \u00b7 takam5f2/ros2_subscription_examples.</p> <pre><code>      for (size_t i = 0; i &lt; subscriptions_num; i++) {\nif (wait_result.get_wait_set().get_rcl_wait_set().subscriptions[i]) {\nstd_msgs::msg::String msg;\nrclcpp::MessageInfo msg_info;\nif (subscriptions_array_[i]-&gt;take(msg, msg_info)) {\nRCLCPP_INFO(this-&gt;get_logger(), \"Catch message via subscription[%ld]\", i);\nRCLCPP_INFO(this-&gt;get_logger(), \"I heard: [%s]\", msg.data.c_str());\n</code></pre> <p>In the code above, <code>wait_result.get_wait_set().get_rcl_wait_set().subscriptions[i]</code> indicates whether each individual trigger has been invoked or not. The result is stored in the <code>subscriptions</code> array. The order in the <code>subscriptions</code> array is the same as the order in which the triggers are registered.</p>"},{"location":"contributing/discussion-guidelines/","title":"Discussion guidelines","text":""},{"location":"contributing/discussion-guidelines/#discussion-guidelines","title":"Discussion guidelines","text":"<p>Warning</p> <p>Under Construction</p> <p>Refer to the following links for now:</p> <ul> <li>https://docs.github.com/en/discussions/guides/best-practices-for-community-conversations-on-github</li> <li>https://opensource.guide/how-to-contribute/#communicating-effectively</li> </ul>"},{"location":"contributing/documentation-guidelines/","title":"Documentation guidelines","text":""},{"location":"contributing/documentation-guidelines/#documentation-guidelines","title":"Documentation guidelines","text":""},{"location":"contributing/documentation-guidelines/#workflow","title":"Workflow","text":"<p>Contributions to Autoware's documentation are welcome, and the same principles described in the contribution guidelines should be followed. Small, limited changes can be made by forking this repository and submitting a pull request, but larger changes should be discussed with the community and Autoware maintainers via GitHub Discussion first.</p> <p>Examples of small changes include:</p> <ul> <li>Fixing spelling or grammatical mistakes</li> <li>Fixing broken links</li> <li>Making an addition to an existing, well-defined page, such as the Troubleshooting guide.</li> </ul> <p>Examples of larger changes include:</p> <ul> <li>Adding new pages with a large amount of detail, such as a tutorial</li> <li>Re-organization of the existing documentation structure</li> </ul>"},{"location":"contributing/documentation-guidelines/#style-guide","title":"Style guide","text":"<p>You should refer to the Google developer documentation style guide as much as possible. Reading the Highlights page of that guide is recommended, but if not then the key points below should be noted.</p> <ul> <li>Use standard American English spelling and punctuation.</li> <li>Use sentence case for document titles and section headings.</li> <li>Use descriptive link text.</li> <li>Write short sentences that are easy to understand and translate.</li> </ul>"},{"location":"contributing/documentation-guidelines/#tips","title":"Tips","text":""},{"location":"contributing/documentation-guidelines/#how-to-preview-your-modification","title":"How to preview your modification","text":"<p>There are two ways to preview your modification on a documentation website.</p>"},{"location":"contributing/documentation-guidelines/#1-using-github-actions-workflow","title":"1. Using GitHub Actions workflow","text":"<p>Follow the steps below.</p> <ol> <li>Create a pull request to the repository.</li> <li>Add the <code>deploy-docs</code> label from the sidebar (See below figure).</li> <li>Wait for a couple of minutes, and the <code>github-actions</code> bot will notify the URL for the pull request's preview.</li> </ol> <p></p>"},{"location":"contributing/documentation-guidelines/#2-running-an-mkdocs-server-in-your-local-environment","title":"2. Running an MkDocs server in your local environment","text":"<p>Instead of creating a PR, you can use the <code>mkdocs</code> command to build Autoware's documentation websites on your local computer. Assuming that you are using Ubuntu OS, run the following to install the required libraries.</p> <pre><code>python3 -m pip install -U $(curl -fsSL https://raw.githubusercontent.com/autowarefoundation/autoware-github-actions/main/deploy-docs/mkdocs-requirements.txt)\n</code></pre> <p>Then, run <code>mkdocs serve</code> on your documentation directory.</p> <pre><code>cd /PATH/TO/YOUR-autoware-documentation\nmkdocs serve\n</code></pre> <p>It will launch the MkDocs server. Access http://127.0.0.1:8000/ to see the preview of the website.</p>"},{"location":"contributing/pull-request-guidelines/","title":"Pull request guidelines","text":""},{"location":"contributing/pull-request-guidelines/#pull-request-guidelines","title":"Pull request guidelines","text":""},{"location":"contributing/pull-request-guidelines/#general-pull-request-workflow","title":"General pull request workflow","text":"<p>Autoware uses the fork-and-pull model. For more details about the model, refer to GitHub Docs.</p> <p>The following is a general example of the pull request workflow based on the fork-and-pull model. Use this workflow as a reference when you contribute to Autoware.</p> <ol> <li>Create an issue.<ul> <li>Discuss the approaches to the issue with maintainers.</li> <li>Confirm the support guidelines before creating an issue.</li> <li>Follow the discussion guidelines when you discuss with other contributors.</li> </ul> </li> <li>Create a fork repository. (for the first time only)</li> <li>Write code in your fork repository according to the approach agreed upon in the issue.<ul> <li>Write the tests and documentation as appropriate.</li> <li>Follow the coding guidelines guidelines when you write code.</li> <li>Follow the Testing guidelines guidelines when you write tests.</li> <li>Follow the Documentation guidelines guidelines when you write documentation.</li> <li>Follow the commit guidelines when you commit your changes.</li> </ul> </li> <li>Test the code.<ul> <li>It is recommended that you summarize the test results, because you will need to explain the test results in the later review process.</li> <li>If you are not sure what tests should be done, discuss them with maintainers.</li> </ul> </li> <li>Create a pull request.<ul> <li>Follow the pull request rules when you create a pull request.</li> </ul> </li> <li>Wait for the pull request to be reviewed.<ul> <li>The reviewers will review your code following the review guidelines.<ul> <li>Not only the reviewers, but also the author is encouraged to understand the review guidelines.</li> </ul> </li> <li>If CI checks have failed, fix the errors.</li> <li>Learn about code ownership from the code owners guidelines.<ul> <li>Check the code owners FAQ section if your pull request is not being reviewed.</li> </ul> </li> </ul> </li> <li>Address the review comments pointed out by the reviewers.<ul> <li>If you don't understand the meaning of a review comment, ask the reviewers until you understand it.<ul> <li>Fixing without understanding the reason is not recommended because the author should be responsible for the final content of their own pull request.</li> </ul> </li> <li>If you don't agree with a review comment, ask the reviewers for a rational reason.<ul> <li>The reviewers are obligated to make the author understand the meanings of each comment.</li> </ul> </li> <li>After you have done with the review comments, re-request a review to the reviewers and back to 6.<ul> <li>Avoid using force push as much as possible so reviewers only see the differences. More precisely, at least keep a commit history up to the point of review because GitHub Web UI such as the suggested change may require rebase to pass DCO CI.</li> </ul> </li> <li>If there are no more new review comments, the reviewers will approve the pull request and proceed to 8.</li> </ul> </li> <li>Merge the pull request.<ul> <li>Anyone with write access can merge the pull request if there is no special request from maintainers.<ul> <li>The author is encouraged to merge the pull request to feel responsible for their own pull request.</li> <li>If the author does not have write access, ask the reviewers or maintainers.</li> </ul> </li> </ul> </li> </ol>"},{"location":"contributing/pull-request-guidelines/#pull-request-rules","title":"Pull request rules","text":""},{"location":"contributing/pull-request-guidelines/#use-an-appropriate-pull-request-template-required-non-automated","title":"Use an appropriate pull request template (required, non-automated)","text":""},{"location":"contributing/pull-request-guidelines/#rationale","title":"Rationale","text":"<ul> <li>The unified style of descriptions by templates can make reviews efficient.</li> </ul>"},{"location":"contributing/pull-request-guidelines/#example","title":"Example","text":"<p>There are two types of templates. Select one based on the following condition.</p> <ol> <li>Standard change:<ul> <li>Complexity:<ul> <li>New features or significant updates.</li> <li>Requires deeper understanding of the codebase.</li> </ul> </li> <li>Impact:<ul> <li>Affects multiple parts of the system.</li> <li>Basically includes minor features, bug fixes and performance improvement.</li> <li>Needs testing before merging.</li> </ul> </li> </ul> </li> <li>Small change:<ul> <li>Complexity:<ul> <li>Documentation, simple refactoring, or style adjustments.</li> <li>Easy to understand and review.</li> </ul> </li> <li>Impact:<ul> <li>Minimal effect on the system.</li> <li>Quicker merge with less testing needed.</li> </ul> </li> </ul> </li> </ol>"},{"location":"contributing/pull-request-guidelines/#steps-to-use-an-appropriate-pull-request-template","title":"Steps to use an appropriate pull request template","text":"<ol> <li>Select the appropriate template, as shown in this video.</li> <li>Read the selected template carefully and fill the required content.</li> <li>Check the checkboxes during a review.<ul> <li>There are pre-review checklist and post-review checklist for the author.</li> </ul> </li> </ol>"},{"location":"contributing/pull-request-guidelines/#set-appropriate-reviewers-after-creating-a-pull-request-required-partially-automated","title":"Set appropriate reviewers after creating a pull request (required, partially automated)","text":""},{"location":"contributing/pull-request-guidelines/#rationale_1","title":"Rationale","text":"<ul> <li>Pull requests must be reviewed by appropriate reviewers to keep the quality of the codebase.</li> </ul>"},{"location":"contributing/pull-request-guidelines/#example_1","title":"Example","text":"<ul> <li>For most ROS packages, reviewers will be automatically assigned based on the <code>maintainer</code> information in <code>package.xml</code>.</li> <li>If no reviewer is assigned automatically, assign reviewers manually following the instructions in GitHub Docs.<ul> <li>You can find the reviewers by seeing the <code>.github/CODEOWNERS</code> file of the repository.</li> </ul> </li> <li>If you are not sure the appropriate reviewers, ask <code>@autoware-maintainers</code>.</li> <li>If you have no rights to assign reviewers, mention reviewers instead.</li> </ul>"},{"location":"contributing/pull-request-guidelines/#apply-conventional-commits-to-the-pull-request-title-required-automated","title":"Apply Conventional Commits to the pull request title (required, automated)","text":""},{"location":"contributing/pull-request-guidelines/#rationale_2","title":"Rationale","text":"<ul> <li>Conventional Commits can generate categorized changelogs, for example using git-cliff.</li> </ul>"},{"location":"contributing/pull-request-guidelines/#example_2","title":"Example","text":"<pre><code>feat(trajectory_follower): add an awesome feature\n</code></pre> <p>Note</p> <p>You have to start the description part (here <code>add an awesome feature</code>) with a lowercase.</p> <p>If your change breaks some interfaces, use the <code>!</code> (breaking changes) mark as follows:</p> <pre><code>feat(trajectory_follower)!: remove package\nfeat(trajectory_follower)!: change parameter names\nfeat(planning)!: change topic names\nfeat(autoware_utils)!: change function names\n</code></pre> <p>For the repositories that contain code (most repositories), use the definition of conventional-commit-types for the type.</p> <p>For documentation repositories such as autoware-documentation, use the following definition:</p> <ul> <li><code>feat</code><ul> <li>Add new pages.</li> <li>Add contents to the existing pages.</li> </ul> </li> <li><code>fix</code><ul> <li>Fix the contents in the existing pages.</li> </ul> </li> <li><code>refactor</code><ul> <li>Move contents to different pages.</li> </ul> </li> <li><code>docs</code><ul> <li>Update documentation for the documentation repository itself.</li> </ul> </li> <li><code>build</code><ul> <li>Update the settings of the documentation site builder.</li> </ul> </li> <li><code>!</code> (breaking changes)<ul> <li>Remove pages.</li> <li>Change the URL of pages.</li> </ul> </li> </ul> <p><code>perf</code> and <code>test</code> are generally unused. Other types have the same meaning as the code repositories.</p>"},{"location":"contributing/pull-request-guidelines/#add-the-related-component-names-to-the-scope-of-conventional-commits-advisory-non-automated","title":"Add the related component names to the scope of Conventional Commits (advisory, non-automated)","text":""},{"location":"contributing/pull-request-guidelines/#rationale_3","title":"Rationale","text":"<ul> <li>It helps contributors find pull requests that are relevant to them.</li> <li>It makes the changelog clearer.</li> </ul>"},{"location":"contributing/pull-request-guidelines/#example_3","title":"Example","text":"<p>For ROS packages, adding the package name or component name is good.</p> <pre><code>feat(trajectory_follower): add an awesome feature\nrefactor(planning, control): use common utils\n</code></pre>"},{"location":"contributing/pull-request-guidelines/#keep-a-pull-request-small-advisory-non-automated","title":"Keep a pull request small (advisory, non-automated)","text":""},{"location":"contributing/pull-request-guidelines/#rationale_4","title":"Rationale","text":"<ul> <li>Small pull requests are easy to understand for reviewers.</li> <li>Small pull requests are easy to revert for maintainers.</li> </ul>"},{"location":"contributing/pull-request-guidelines/#exception","title":"Exception","text":"<p>It is acceptable if it is agreed with maintainers that there is no other way but to submit a big pull request.</p>"},{"location":"contributing/pull-request-guidelines/#example_4","title":"Example","text":"<ul> <li>Avoid developing two features in one pull request.</li> <li>Avoid mixing different types (<code>feat</code>, <code>fix</code>, <code>refactor</code>, etc.) of changes in the same commit.</li> </ul>"},{"location":"contributing/pull-request-guidelines/#remind-reviewers-if-there-is-no-response-for-more-than-a-week-advisory-non-automated","title":"Remind reviewers if there is no response for more than a week (advisory, non-automated)","text":""},{"location":"contributing/pull-request-guidelines/#rationale_5","title":"Rationale","text":"<ul> <li>It is the author's responsibility to care about their own pull request until it is merged.</li> </ul>"},{"location":"contributing/pull-request-guidelines/#example_5","title":"Example","text":"<pre><code>@{some-of-developers} Would it be possible for you to review this PR?\n@autoware-maintainers friendly ping.\n</code></pre>"},{"location":"contributing/pull-request-guidelines/ai-pr-review/","title":"AI PR Review","text":""},{"location":"contributing/pull-request-guidelines/ai-pr-review/#ai-pr-review","title":"AI PR Review","text":"<p>We have Codium-ai/pr-agent enabled for Autoware Universe repository.</p>"},{"location":"contributing/pull-request-guidelines/ai-pr-review/#the-workflow","title":"The workflow","text":"<p>Workflow: pr-agent.yaml</p>"},{"location":"contributing/pull-request-guidelines/ai-pr-review/#additional-links-for-the-workflow-maintainers","title":"Additional links for the workflow maintainers","text":"<ul> <li>Available models list</li> </ul>"},{"location":"contributing/pull-request-guidelines/ai-pr-review/#how-to-use","title":"How to use","text":"<p>When you create the PR, or within the PR add the label <code>tag:pr-agent</code>.</p> <p>Wait until both PR-Agent jobs are completed successfully:</p> <ul> <li><code>prevent-no-label-execution-pr-agent / prevent-no-label-execution</code></li> <li><code>Run pr agent on every pull request, respond to user comments</code></li> </ul> <p>Warning</p> <p>If you add multiple labels at the same time, <code>prevent-no-label-execution</code> can get confused.</p> <p>For example, first add <code>tag:pr-agent</code>, wait until it is ready, then add <code>tag:run-build-and-test-differential</code> if you need it.</p> <p>Then you can pick one of the following commands:</p> <pre><code>/review: Request a review of your Pull Request.\n/describe: Update the PR description based on the contents of the PR.\n/improve: Suggest code improvements.\n/ask Could you propose a better name for this parameter?: Ask a question about the PR or anything really.\n/update_changelog: Update the changelog based on the PR's contents.\n/add_docs: Generate docstring for new components introduced in the PR.\n/help: Get a list of all available PR-Agent tools and their descriptions.\n</code></pre> <ul> <li>Here is the official documentation.</li> <li>Usage Guide</li> </ul> <p>To use it, drop a comment post within your PR like this.</p> <p>Within a minute, you should see \ud83d\udc40 reaction under your comment post.</p> <p>Then the bot will drop a response with reviews, description or an answer.</p> <p>Info</p> <p>Please drop a single PR-Agent related comment at a time.</p>"},{"location":"contributing/pull-request-guidelines/ci-checks/","title":"CI checks","text":""},{"location":"contributing/pull-request-guidelines/ci-checks/#ci-checks","title":"CI checks","text":"<p>Autoware has several checks for a pull request. The results are shown at the bottom of the pull request page as below.</p> <p></p> <p>If the \u274c mark is shown, click the <code>Details</code> button and investigate the failure reason.</p> <p>If the <code>Required</code> mark is shown, you cannot merge the pull request unless you resolve the error. If not, it is optional, but preferably it should be fixed.</p> <p>The following sections explain about common CI checks in Autoware. Note that some repositories may have different settings.</p>"},{"location":"contributing/pull-request-guidelines/ci-checks/#dco","title":"DCO","text":"<p>The Developer Certificate of Origin (DCO) is a lightweight way for contributors to certify that they wrote or otherwise have the right to submit the code they are contributing to the project.</p> <p>This workflow checks whether the pull request fulfills <code>DCO</code>. You need to confirm the required items and commit with <code>git commit -s</code>.</p> <p>For more information, refer to the GitHub App page.</p>"},{"location":"contributing/pull-request-guidelines/ci-checks/#semantic-pull-request","title":"semantic-pull-request","text":"<p>This workflow checks whether the pull request follows Conventional Commits.</p> <p>For the detailed rules, see the pull request rules.</p>"},{"location":"contributing/pull-request-guidelines/ci-checks/#pre-commit","title":"pre-commit","text":"<p>pre-commit is a tool to run formatters or linters when you commit.</p> <p>This workflow checks whether the pull request has no error with <code>pre-commit</code>.</p> <p>In the workflow <code>pre-commit.ci - pr</code> is enabled in the repository, it will automatically fix errors by pre-commit.ci as many as possible. If there are some errors remain, fix them manually.</p> <p>You can run <code>pre-commit</code> in your local environment by the following command:</p> <pre><code>pre-commit run -a\n</code></pre> <p>Or you can install <code>pre-commit</code> to the repository and automatically run it before committing:</p> <pre><code>pre-commit install\n</code></pre> <p>Since it is difficult to detect errors with no false positives, some jobs are split into another config file and marked as optional. To check them, use the <code>--config</code> option:</p> <pre><code>pre-commit run -a --config .pre-commit-config-optional.yaml\n</code></pre>"},{"location":"contributing/pull-request-guidelines/ci-checks/#spell-check-differential","title":"spell-check-differential","text":"<p>This workflow detects spelling mistakes using CSpell with our dictionary file. Since it is difficult to detect errors with no false positives, it is an optional workflow, but it is preferable to remove spelling mistakes as many as possible.</p> <p>You have the following options if you need to use a word that is not registered in the dictionary.</p> <ul> <li>If the word is only used in a few files, you can use inline document settings \"cspell:ignore\" to suppress the check.</li> <li>If the word is widely used in the repository, you can create a local cspell json and pass it to the spell-check action.</li> <li>If the word is common and may be used in many repositories, you can submit pull requests to tier4/autoware-spell-check-dict or tier4/cspell-dicts to update the dictionary.</li> </ul>"},{"location":"contributing/pull-request-guidelines/ci-checks/#build-and-test-differential","title":"build-and-test-differential","text":"<p>This workflow checks <code>colcon build</code> and <code>colcon test</code> for the pull request. To make the CI faster, it doesn't check all packages but only modified packages and the dependencies.</p>"},{"location":"contributing/pull-request-guidelines/ci-checks/#build-and-test-differential-self-hosted","title":"build-and-test-differential-self-hosted","text":"<p>This workflow is the <code>ARM64</code> version of <code>build-and-test-differential</code>. You need to add the <code>ARM64</code> label to run this workflow.</p> <p>For reference information, since ARM machines are not supported by GitHub-hosted runners, we use self-hosted runners prepared by the AWF. For the details about self-hosted runners, refer to GitHub Docs.</p>"},{"location":"contributing/pull-request-guidelines/ci-checks/#deploy-docs","title":"deploy-docs","text":"<p>This workflow deploys the preview documentation site for the pull request. You need to add the <code>deploy-docs</code> label to run this workflow.</p>"},{"location":"contributing/pull-request-guidelines/code-owners/","title":"Code owners","text":""},{"location":"contributing/pull-request-guidelines/code-owners/#code-owners","title":"Code owners","text":"<p>The Autoware project uses multiple <code>CODEOWNERS</code> files to specify owners throughout the repository. For a detailed understanding of code owners, visit the GitHub documentation on code owners.</p>"},{"location":"contributing/pull-request-guidelines/code-owners/#purpose-and-function-of-the-codeowners-file","title":"Purpose and function of the <code>CODEOWNERS</code> file","text":"<p>The <code>CODEOWNERS</code> file plays a vital role in managing pull requests (PRs) by:</p> <ul> <li>Automating Review Requests: Automatically assigns PRs to responsible individuals or teams.</li> <li>Enforcing Merge Approval: Prevents PR merging without approvals from designated code owners or repository maintainers, ensuring thorough review.</li> <li>Maintaining Quality Control: Helps sustain code quality and consistency by requiring review from knowledgeable individuals or teams.</li> </ul>"},{"location":"contributing/pull-request-guidelines/code-owners/#locating-codeowners-files","title":"Locating <code>CODEOWNERS</code> files","text":"<p><code>CODEOWNERS</code> files are found in the <code>.github</code> directory across multiple repositories of the Autoware project. The <code>autoware.repos</code> file lists these repositories and their directories.</p>"},{"location":"contributing/pull-request-guidelines/code-owners/#maintenance-of-codeowners","title":"Maintenance of <code>CODEOWNERS</code>","text":"<p>Generally, repository maintainers handle the updates to <code>CODEOWNERS</code> files. To propose changes, submit a PR to modify the file.</p>"},{"location":"contributing/pull-request-guidelines/code-owners/#special-case-for-the-autoware-universe-repository","title":"Special case for the Autoware Universe repository","text":"<p>In the autoware.universe repository, maintenance of the <code>CODEOWNERS</code> file is automated by the CI.</p> <p>This workflow updates the <code>CODEOWNERS</code> file based on the <code>maintainer</code> information in the <code>package.xml</code> files of the packages in the repository.</p> <p>In order to change the code owners for a package in the <code>autoware.universe</code> repository:</p> <ol> <li>Modify the <code>maintainer</code> information in the <code>package.xml</code> file via a PR.</li> <li>Once merged, the CI workflow runs at midnight UTC (or can be triggered manually by a maintainer) to update the <code>CODEOWNERS</code> file and create a PR.</li> <li>A maintainer then needs to merge the CI-generated PR to finalize the update.<ul> <li>Example Automated PR: chore: update CODEOWNERS #6866</li> </ul> </li> </ol>"},{"location":"contributing/pull-request-guidelines/code-owners/#responsibilities-of-code-owners","title":"Responsibilities of code owners","text":"<p>Code owners should review assigned PRs promptly. If a PR remains unreviewed for over a week, maintainers may intervene to review and possibly merge it.</p>"},{"location":"contributing/pull-request-guidelines/code-owners/#faq","title":"FAQ","text":""},{"location":"contributing/pull-request-guidelines/code-owners/#unreviewed-pull-requests","title":"Unreviewed pull requests","text":"<p>If your PR hasn't been reviewed:</p> <ul> <li>\ud83c\udff9 Directly Address Code Owners: Comment on the PR to alert the owners.</li> <li>\u23f3 Follow Up After a Week: If unreviewed after a week, add a comment under the PR and tag the <code>@autoware-maintainers</code>.</li> <li>\ud83d\udce2 Escalate if Necessary: If your requests continue to go unanswered, you may escalate the issue by posting a message in the Autoware Discord channel \ud83d\udea8. Remember, maintainers often juggle numerous responsibilities, so patience is appreciated\ud83d\ude47.</li> </ul>"},{"location":"contributing/pull-request-guidelines/code-owners/#pr-author-is-the-only-code-owner","title":"PR author is the only code owner","text":"<p>If you, as the only code owner, authored a PR:</p> <ul> <li>Request a review by tagging <code>@autoware-maintainers</code>.</li> <li>The maintainers will consider appointing additional maintainers to avoid such conflicts.</li> </ul>"},{"location":"contributing/pull-request-guidelines/code-owners/#non-code-owners-reviewing-prs","title":"Non-code owners reviewing PRs","text":"<p>Anyone can review a PR:</p> <ul> <li>You can review any pull request and provide your feedback.</li> <li>Your review might not be enough to merge the pull request, but it will help the code owners and maintainers to make a decision.</li> <li>If you think the pull request is ready to merge, you can mention the code owners and maintainers in a comment on the pull request.</li> </ul>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/","title":"Commit guidelines","text":""},{"location":"contributing/pull-request-guidelines/commit-guidelines/#commit-guidelines","title":"Commit guidelines","text":""},{"location":"contributing/pull-request-guidelines/commit-guidelines/#branch-rules","title":"Branch rules","text":""},{"location":"contributing/pull-request-guidelines/commit-guidelines/#start-branch-names-with-the-corresponding-issue-numbers-advisory-non-automated","title":"Start branch names with the corresponding issue numbers (advisory, non-automated)","text":""},{"location":"contributing/pull-request-guidelines/commit-guidelines/#rationale","title":"Rationale","text":"<ul> <li>Developers can quickly find the corresponding issues.</li> <li>It is helpful for tools.</li> <li>It is consistent with GitHub's default behavior.</li> </ul>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#exception","title":"Exception","text":"<p>If there are no corresponding issues, you can ignore this rule.</p>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#example","title":"Example","text":"<pre><code>123-add-feature\n</code></pre>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#reference","title":"Reference","text":"<ul> <li>GitHub Docs</li> </ul>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#use-dash-case-for-the-separator-of-branch-names-advisory-non-automated","title":"Use <code>dash-case</code> for the separator of branch names (advisory, non-automated)","text":""},{"location":"contributing/pull-request-guidelines/commit-guidelines/#rationale_1","title":"Rationale","text":"<ul> <li>It is consistent with GitHub's default behavior.</li> </ul>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#example_1","title":"Example","text":"<pre><code>123-add-feature\n</code></pre>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#reference_1","title":"Reference","text":"<ul> <li>GitHub Docs</li> </ul>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#make-branch-names-descriptive-advisory-non-automated","title":"Make branch names descriptive (advisory, non-automated)","text":""},{"location":"contributing/pull-request-guidelines/commit-guidelines/#rationale_2","title":"Rationale","text":"<ul> <li>It can avoid conflicts of names.</li> <li>Developers can understand the purpose of the branch.</li> </ul>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#exception_1","title":"Exception","text":"<p>If you have already submitted a pull request, you do not have to change the branch name because you need to re-create a pull request, which is noisy and a waste of time. Be careful from the next time.</p>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#example_2","title":"Example","text":"<p>Usually it is good to start with a verb.</p> <pre><code>123-fix-memory-leak-of-trajectory-follower\n</code></pre>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#commit-rules","title":"Commit rules","text":""},{"location":"contributing/pull-request-guidelines/commit-guidelines/#sign-off-your-commits-required-automated","title":"Sign-off your commits (required, automated)","text":"<p>Developers must certify that they wrote or otherwise have the right to submit the code they are contributing to the project.</p>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#rationale_3","title":"Rationale","text":"<p>If not, it will lead to complex license problems.</p>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#example_3","title":"Example","text":"<pre><code>git commit -s\n</code></pre> <pre><code>feat: add a feature\n\nSigned-off-by: Autoware &lt;autoware@example.com&gt;\n</code></pre>"},{"location":"contributing/pull-request-guidelines/commit-guidelines/#reference_2","title":"Reference","text":"<ul> <li>GitHub Apps - DCO</li> </ul>"},{"location":"contributing/pull-request-guidelines/review-guidelines/","title":"Review guidelines","text":""},{"location":"contributing/pull-request-guidelines/review-guidelines/#review-guidelines","title":"Review guidelines","text":"<p>Warning</p> <p>Under Construction</p> <p>Refer to the following links for now:</p> <ul> <li>https://google.github.io/eng-practices/review/</li> <li>https://docs.gitlab.com/ee/development/code_review.html</li> <li>https://www.swarmia.com/blog/a-complete-guide-to-code-reviews/</li> <li>https://rewind.com/blog/best-practices-for-reviewing-pull-requests-in-github/</li> </ul>"},{"location":"contributing/pull-request-guidelines/review-tips/","title":"Review tips","text":""},{"location":"contributing/pull-request-guidelines/review-tips/#review-tips","title":"Review tips","text":""},{"location":"contributing/pull-request-guidelines/review-tips/#toggle-annotations-or-review-comments-in-the-diff-view","title":"Toggle annotations or review comments in the diff view","text":"<p>There might be some annotations or review comments in the diff view during your review.</p> <p>To toggle annotations, press the <code>A</code> key.</p> <p>Before:</p> <p></p> <p>After:</p> <p></p> <p>To toggle review comments, press the <code>I</code> key.</p> <p>For other keyboard shortcuts, refer to GitHub Docs.</p>"},{"location":"contributing/pull-request-guidelines/review-tips/#view-code-in-the-web-based-visual-studio-code","title":"View code in the web-based Visual Studio Code","text":"<p>You can open <code>Visual Studio Code</code> from your browser to view code in a rich UI. To use it, press the <code>.</code> key on any repository or pull request.</p> <p>For more detailed usage, refer to github/dev.</p>"},{"location":"contributing/pull-request-guidelines/review-tips/#check-out-the-branch-of-a-pull-request-quickly","title":"Check out the branch of a pull request quickly","text":"<p>If you want to check out the branch of a pull request, it's generally troublesome with the fork-and-pull model.</p> <pre><code># Copy the user name and the fork URL.\ngit remote add {user-name} {fork-url}\ngit checkout {user-name}/{branch-name}\ngit remote rm {user-name} # To clean up\n</code></pre> <p>Instead, you can use GitHub CLI to simplify the steps, just run <code>gh pr checkout {pr-number}</code>.</p> <p>You can copy the command from the top right of the pull request page.</p> <p></p>"},{"location":"contributing/testing-guidelines/","title":"Testing guidelines","text":""},{"location":"contributing/testing-guidelines/#testing-guidelines","title":"Testing guidelines","text":""},{"location":"contributing/testing-guidelines/#unit-testing","title":"Unit testing","text":"<p>Unit testing is a software testing method that tests individual units of source code to determine whether they satisfy the specification.</p> <p>For details, see the Unit testing guidelines.</p>"},{"location":"contributing/testing-guidelines/#integration-testing","title":"Integration testing","text":"<p>Integration testing combines and tests the individual software modules as a group, and is done after unit testing.</p> <p>While performing integration testing, the following subtypes of tests are written:</p> <ol> <li>Fault injection testing</li> <li>Back-to-back comparison between a model and code</li> <li>Requirements-based testing</li> <li>Anomaly detection during integration testing</li> <li>Random input testing</li> </ol> <p>For details, see the Integration testing guidelines.</p>"},{"location":"contributing/testing-guidelines/integration-testing/","title":"Integration testing","text":""},{"location":"contributing/testing-guidelines/integration-testing/#integration-testing","title":"Integration testing","text":"<p>An integration test is defined as the phase in software testing where individual software modules are combined and tested as a group. Integration tests occur after unit tests, and before validation tests.</p> <p>The input to an integration test is a set of independent modules that have been unit tested. The set of modules is tested against the defined integration test plan, and the output is a set of properly integrated software modules that is ready for system testing.</p>"},{"location":"contributing/testing-guidelines/integration-testing/#value-of-integration-testing","title":"Value of integration testing","text":"<p>Integration tests determine if independently developed software modules work correctly when the modules are connected to each other. In ROS 2, the software modules are called nodes. Testing a single node is a special type of integration test that is commonly referred to as component testing.</p> <p>Integration tests help to find the following types of errors:</p> <ul> <li>Incompatible interactions between nodes, such as non-matching topics, different message types, or incompatible QoS settings.</li> <li>Edge cases that were not touched by unit testing, such as a critical timing issue, network communication delays, disk I/O failures, and other such problems that can occur in production environments.</li> <li>Issues that can occur while the system is under high CPU/memory load, such as <code>malloc</code> failures. This can be tested using tools like <code>stress</code> and <code>udpreplay</code> to test the performance of nodes with real data.</li> </ul> <p>With ROS 2, it is possible to program complex autonomous-driving applications with a large number of nodes. Therefore, a lot of effort has been made to provide an integration-test framework that helps developers test the interaction of ROS 2 nodes.</p>"},{"location":"contributing/testing-guidelines/integration-testing/#integration-test-framework","title":"Integration-test framework","text":"<p>A typical integration-test framework has three parts:</p> <ol> <li>A series of executables with arguments that work together and generate outputs.</li> <li>A series of expected outputs that should match the output of the executables.</li> <li>A launcher that starts the tests, compares the outputs to the expected outputs, and determines if the test passes.</li> </ol> <p>In Autoware, we use the launch_testing framework.</p>"},{"location":"contributing/testing-guidelines/integration-testing/#smoke-tests","title":"Smoke tests","text":"<p>Autoware has a dedicated API for smoke testing. To use this framework, in <code>package.xml</code> add:</p> <pre><code>&lt;test_depend&gt;autoware_testing&lt;/test_depend&gt;\n</code></pre> <p>And in <code>CMakeLists.txt</code> add:</p> <pre><code>if(BUILD_TESTING)\nfind_package(autoware_testing REQUIRED)\nadd_smoke_test(${PROJECT_NAME} ${NODE_NAME})\nendif()\n</code></pre> <p>Doing so adds smoke tests that ensure that a node can be:</p> <ol> <li>Launched with a default parameter file.</li> <li>Terminated with a standard <code>SIGTERM</code> signal.</li> </ol> <p>For the full API documentation, refer to the package design page.</p> <p>Note</p> <p>This API is not suitable for all smoke test cases. It cannot be used when a specific file location (eg: for a map) is required to be passed to the node, or if some preparation needs to be conducted before node launch. In such cases use the manual solution from the component test section below.</p>"},{"location":"contributing/testing-guidelines/integration-testing/#integration-test-with-a-single-node-component-test","title":"Integration test with a single node: component test","text":"<p>The simplest scenario is a single node. In this case, the integration test is commonly referred to as a component test.</p> <p>To add a component test to an existing node, you can follow the example of the <code>lanelet2_map_loader</code> in the <code>map_loader</code> package (added in this PR).</p> <p>In <code>package.xml</code>, add:</p> <pre><code>&lt;test_depend&gt;ros_testing&lt;/test_depend&gt;\n</code></pre> <p>In <code>CMakeLists.txt</code>, add or modify the <code>BUILD_TESTING</code> section:</p> <pre><code>if(BUILD_TESTING)\nadd_ros_test(\ntest/lanelet2_map_loader_launch.test.py\nTIMEOUT \"30\"\n)\ninstall(DIRECTORY\ntest/data/\nDESTINATION share/${PROJECT_NAME}/test/data/\n)\nendif()\n</code></pre> <p>In addition to the command <code>add_ros_test</code>, we also install any data that is required by the test using the <code>install</code> command.</p> <p>Note</p> <ul> <li>The <code>TIMEOUT</code> argument is given in seconds; see the add_ros_test.cmake file for details.</li> <li>The <code>add_ros_test</code> command will run the test in a unique <code>ROS_DOMAIN_ID</code> which avoids interference between tests running in parallel.</li> </ul> <p>To create a test, either read the launch_testing quick-start example, or follow the steps below.</p> <p>Taking <code>test/lanelet2_map_loader_launch.test.py</code> as an example, first dependencies are imported:</p> <pre><code>import os\nimport unittest\n\nfrom ament_index_python import get_package_share_directory\nimport launch\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nimport launch_testing\nimport pytest\n</code></pre> <p>Then a launch description is created to launch the node under test. Note that the <code>test_map.osm</code> file path is found and passed to the node, something that cannot be done with the smoke testing API:</p> <pre><code>@pytest.mark.launch_test\ndef generate_test_description():\n\n    lanelet2_map_path = os.path.join(\n        get_package_share_directory(\"map_loader\"), \"test/data/test_map.osm\"\n    )\n\n    lanelet2_map_loader = Node(\n        package=\"map_loader\",\n        executable=\"lanelet2_map_loader\",\n        parameters=[{\"lanelet2_map_path\": lanelet2_map_path}],\n    )\n\n    context = {}\n\n    return (\n        LaunchDescription(\n            [\n                lanelet2_map_loader,\n                # Start test after 1s - gives time for the map_loader to finish initialization\n                launch.actions.TimerAction(\n                    period=1.0, actions=[launch_testing.actions.ReadyToTest()]\n                ),\n            ]\n        ),\n        context,\n    )\n</code></pre> <p>Note</p> <ul> <li>Since the node need time to process the input lanelet2 map, we use a <code>TimerAction</code> to delay the start of the test by 1s.</li> <li>In the example above, the <code>context</code> is empty but it can be used to pass objects to the test cases.</li> <li>You can find an example of using the <code>context</code> in the ROS 2 context_launch_test.py test example.</li> </ul> <p>Finally, a test is executed after the node executable has been shut down (<code>post_shutdown_test</code>). Here we ensure that the node was launched without error and exited cleanly.</p> <pre><code>@launch_testing.post_shutdown_test()\nclass TestProcessOutput(unittest.TestCase):\n    def test_exit_code(self, proc_info):\n        # Check that process exits with code 0: no error\n        launch_testing.asserts.assertExitCodes(proc_info)\n</code></pre>"},{"location":"contributing/testing-guidelines/integration-testing/#running-the-test","title":"Running the test","text":"<p>Continuing the example from above, first build your package:</p> <pre><code>colcon build --packages-up-to map_loader\nsource install/setup.bash\n</code></pre> <p>Then either execute the component test manually:</p> <pre><code>ros2 test src/universe/autoware.universe/map/map_loader/test/lanelet2_map_loader_launch.test.py\n</code></pre> <p>Or as part of testing the entire package:</p> <pre><code>colcon test --packages-select map_loader\n</code></pre> <p>Verify that the test is executed; e.g.</p> <pre><code>$ colcon test-result --all --verbose\n...\nbuild/map_loader/test_results/map_loader/test_lanelet2_map_loader_launch.test.py.xunit.xml: 1 test, 0 errors, 0 failures, 0 skipped\n</code></pre>"},{"location":"contributing/testing-guidelines/integration-testing/#next-steps","title":"Next steps","text":"<p>The simple test described in Integration test with a single node: component test can be extended in numerous directions, such as testing a node's output.</p>"},{"location":"contributing/testing-guidelines/integration-testing/#testing-the-output-of-a-node","title":"Testing the output of a node","text":"<p>To test while the node is running, create an active test by adding a subclass of Python's <code>unittest.TestCase</code> to <code>*launch.test.py</code>. Some boilerplate code is required to access output by creating a node and a subscription to a particular topic, e.g.</p> <pre><code>import unittest\n\nclass TestRunningDataPublisher(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        cls.context = Context()\n        rclpy.init(context=cls.context)\n        cls.node = rclpy.create_node(\"test_node\", context=cls.context)\n\n    @classmethod\n    def tearDownClass(cls):\n        rclpy.shutdown(context=cls.context)\n\n    def setUp(self):\n        self.msgs = []\n        sub = self.node.create_subscription(\n            msg_type=my_msg_type,\n            topic=\"/info_test\",\n            callback=self._msg_received\n        )\n        self.addCleanup(self.node.destroy_subscription, sub)\n\n    def _msg_received(self, msg):\n        # Callback for ROS 2 subscriber used in the test\n        self.msgs.append(msg)\n\n    def get_message(self):\n        startlen = len(self.msgs)\n\n        executor = rclpy.executors.SingleThreadedExecutor(context=self.context)\n        executor.add_node(self.node)\n\n        try:\n            # Try up to 60 s to receive messages\n            end_time = time.time() + 60.0\n            while time.time() &lt; end_time:\n                executor.spin_once(timeout_sec=0.1)\n                if startlen != len(self.msgs):\n                    break\n\n            self.assertNotEqual(startlen, len(self.msgs))\n            return self.msgs[-1]\n        finally:\n            executor.remove_node(self.node)\n\n    def test_message_content():\n        msg = self.get_message()\n        self.assertEqual(msg, \"Hello, world\")\n</code></pre>"},{"location":"contributing/testing-guidelines/integration-testing/#references","title":"References","text":"<ul> <li>colcon is used to build and run tests.</li> <li>launch testing launches nodes and runs tests.</li> <li>Testing guidelines describes the different types of tests performed in Autoware and links to the corresponding guidelines.</li> </ul>"},{"location":"contributing/testing-guidelines/unit-testing/","title":"Unit testing","text":""},{"location":"contributing/testing-guidelines/unit-testing/#unit-testing","title":"Unit testing","text":"<p>Unit testing is the first phase of testing and is used to validate units of source code such as classes and functions. Typically, a unit of code is tested by validating its output for various inputs. Unit testing helps ensure that the code behaves as intended and prevents accidental changes of behavior.</p> <p>Autoware uses the <code>ament_cmake</code> framework to build and run tests. The same framework is also used to analyze the test results.</p> <p><code>ament_cmake</code> provides several convenience functions to make it easy to register tests in a CMake-based package and to ensure that JUnit-compatible result files are generated. It currently supports a few different testing frameworks like <code>pytest</code>, <code>gtest</code>, and <code>gmock</code>.</p> <p>In order to prevent tests running in parallel from interfering with each other when publishing and subscribing to ROS topics, it is recommended to use commands from <code>ament_cmake_ros</code> to run tests in isolation.</p> <p>See below for an example of using <code>ament_add_ros_isolated_gtest</code> with <code>colcon test</code>. All other tests follow a similar pattern.</p>"},{"location":"contributing/testing-guidelines/unit-testing/#create-a-unit-test-with-gtest","title":"Create a unit test with gtest","text":"<p>In <code>my_cool_pkg/test</code>, create the <code>gtest</code> code file <code>test_my_cool_pkg.cpp</code>:</p> <pre><code>#include \"gtest/gtest.h\"\n#include \"my_cool_pkg/my_cool_pkg.hpp\"\nTEST(TestMyCoolPkg, TestHello) {\nEXPECT_EQ(my_cool_pkg::print_hello(), 0);\n}\n</code></pre> <p>In <code>package.xml</code>, add the following line:</p> <pre><code>&lt;test_depend&gt;ament_cmake_ros&lt;/test_depend&gt;\n</code></pre> <p>Next add an entry under <code>BUILD_TESTING</code> in the <code>CMakeLists.txt</code> to compile the test source files:</p> <pre><code>if(BUILD_TESTING)\n\nament_add_ros_isolated_gtest(test_my_cool_pkg test/test_my_cool_pkg.cpp)\ntarget_link_libraries(test_my_cool_pkg ${PROJECT_NAME})\ntarget_include_directories(test_my_cool_pkg PRIVATE src)  # For private headers.\n...\nendif()\n</code></pre> <p>This automatically links the test with the default main function provided by <code>gtest</code>. The code under test is usually in a different CMake target (<code>${PROJECT_NAME}</code> in the example) and its shared object for linking needs to be added. If the test source files include private headers from the <code>src</code> directory, the directory needs to be added to the include path using <code>target_include_directories()</code> function.</p> <p>To register a new <code>gtest</code> item, wrap the test code with the macro <code>TEST ()</code>. <code>TEST ()</code> is a predefined macro that helps generate the final test code, and also registers a <code>gtest</code> item to be available for execution. The test case name should be in CamelCase, since gtest inserts an underscore between the fixture name and the class case name when creating the test executable.</p> <p><code>gtest/gtest.h</code> also contains predefined macros of <code>gtest</code> like <code>ASSERT_TRUE(condition)</code>, <code>ASSERT_FALSE(condition)</code>, <code>ASSERT_EQ(val1,val2)</code>, <code>ASSERT_STREQ(str1,str2)</code>, <code>EXPECT_EQ()</code>, etc. <code>ASSERT_*</code> will abort the test if the condition is not satisfied, while <code>EXPECT_*</code> will mark the test as failed but continue on to the next test condition.</p> <p>Info</p> <p>More information about <code>gtest</code> and its features can be found in the gtest repo.</p> <p>In the demo <code>CMakeLists.txt</code>, <code>ament_add_ros_isolated_gtest</code> is a predefined macro in <code>ament_cmake_ros</code> that helps simplify adding <code>gtest</code> code. Details can be viewed in ament_add_gtest.cmake.</p>"},{"location":"contributing/testing-guidelines/unit-testing/#build-test","title":"Build test","text":"<p>By default, all necessary test files (<code>ELF</code>, <code>CTestTestfile.cmake</code>, etc.) are compiled by <code>colcon</code>:</p> <pre><code>cd ~/workspace/\ncolcon build --packages-select my_cool_pkg\n</code></pre> <p>Test files are generated under <code>~/workspace/build/my_cool_pkg</code>.</p>"},{"location":"contributing/testing-guidelines/unit-testing/#run-test","title":"Run test","text":"<p>To run all tests for a specific package, call:</p> <pre><code>$ colcon test --packages-select my_cool_pkg\n\nStarting &gt;&gt;&gt; my_cool_pkg\nFinished &lt;&lt;&lt; my_cool_pkg [7.80s]\n\nSummary: 1 package finished [9.27s]\n</code></pre> <p>The test command output contains a brief report of all the test results.</p> <p>To get job-wise information of all executed tests, call:</p> <pre><code>$ colcon test-result --all\n\nbuild/my_cool_pkg/test_results/my_cool_pkg/copyright.xunit.xml: 8 tests, 0 errors, 0 failures, 0 skipped\nbuild/my_cool_pkg/test_results/my_cool_pkg/cppcheck.xunit.xml: 6 tests, 0 errors, 0 failures, 0 skipped\nbuild/my_cool_pkg/test_results/my_cool_pkg/lint_cmake.xunit.xml: 1 test, 0 errors, 0 failures, 0 skipped\nbuild/my_cool_pkg/test_results/my_cool_pkg/my_cool_pkg_exe_integration_test.xunit.xml: 1 test, 0 errors, 0 failures, 0 skipped\nbuild/my_cool_pkg/test_results/my_cool_pkg/test_my_cool_pkg.gtest.xml: 1 test, 0 errors, 0 failures, 0 skipped\nbuild/my_cool_pkg/test_results/my_cool_pkg/xmllint.xunit.xml: 1 test, 0 errors, 0 failures, 0 skipped\n\nSummary: 18 tests, 0 errors, 0 failures, 0 skipped\n</code></pre> <p>Look in the <code>~/workspace/log/test_&lt;date&gt;/&lt;package_name&gt;</code> directory for all the raw test commands, <code>std_out</code>, and <code>std_err</code>. There is also the <code>~/workspace/log/latest_*/</code> directory containing symbolic links to the most recent package-level build and test output.</p> <p>To print the tests' details while the tests are being run, use the <code>--event-handlers console_cohesion+</code> option to print the details directly to the console:</p> <pre><code>$ colcon test --event-handlers console_cohesion+ --packages-select my_cool_pkg\n\n...\ntest 1\n    Start 1: test_my_cool_pkg\n\n1: Test command: /usr/bin/python3 \"-u\" \"~/workspace/install/share/ament_cmake_test/cmake/run_test.py\" \"~/workspace/build/my_cool_pkg/test_results/my_cool_pkg/test_my_cool_pkg.gtest.xml\" \"--package-name\" \"my_cool_pkg\" \"--output-file\" \"~/workspace/build/my_cool_pkg/ament_cmake_gtest/test_my_cool_pkg.txt\" \"--command\" \"~/workspace/build/my_cool_pkg/test_my_cool_pkg\" \"--gtest_output=xml:~/workspace/build/my_cool_pkg/test_results/my_cool_pkg/test_my_cool_pkg.gtest.xml\"\n1: Test timeout computed to be: 60\n1: -- run_test.py: invoking following command in '~/workspace/src/my_cool_pkg':\n1:  - ~/workspace/build/my_cool_pkg/test_my_cool_pkg --gtest_output=xml:~/workspace/build/my_cool_pkg/test_results/my_cool_pkg/test_my_cool_pkg.gtest.xml\n1: [==========] Running 1 test from 1 test case.\n1: [----------] Global test environment set-up.\n1: [----------] 1 test from test_my_cool_pkg\n1: [ RUN      ] test_my_cool_pkg.test_hello\n1: Hello World\n1: [       OK ] test_my_cool_pkg.test_hello (0 ms)\n1: [----------] 1 test from test_my_cool_pkg (0 ms total)\n1:\n1: [----------] Global test environment tear-down\n1: [==========] 1 test from 1 test case ran. (0 ms total)\n1: [  PASSED  ] 1 test.\n1: -- run_test.py: return code 0\n1: -- run_test.py: inject classname prefix into gtest result file '~/workspace/build/my_cool_pkg/test_results/my_cool_pkg/test_my_cool_pkg.gtest.xml'\n1: -- run_test.py: verify result file '~/workspace/build/my_cool_pkg/test_results/my_cool_pkg/test_my_cool_pkg.gtest.xml'\n1/5 Test #1: test_my_cool_pkg ...................   Passed    0.09 sec\n\n...\n\n100% tests passed, 0 tests failed out of 5\n\nLabel Time Summary:\ncopyright     =   0.49 sec*proc (1 test)\ncppcheck      =   0.20 sec*proc (1 test)\ngtest         =   0.05 sec*proc (1 test)\nlint_cmake    =   0.18 sec*proc (1 test)\nlinter        =   1.34 sec*proc (4 tests)\nxmllint       =   0.47 sec*proc (1 test)\n\nTotal Test time (real) =   7.91 sec\n...\n</code></pre>"},{"location":"contributing/testing-guidelines/unit-testing/#code-coverage","title":"Code coverage","text":"<p>Loosely described, a code coverage metric is a measure of how much of the program code has been exercised (covered) during testing.</p> <p>In the Autoware repositories, Codecov is used to automatically calculate coverage of any open pull request.</p> <p>More details about the code coverage metrics can be found in the Codecov documentation.</p>"},{"location":"datasets/","title":"Datasets","text":""},{"location":"datasets/#datasets","title":"Datasets","text":"<p>Autoware partners provide datasets for testing and development. These datasets are available for download here.</p>"},{"location":"datasets/#bus-odd-operational-design-domain-datasets","title":"Bus-ODD (Operational Design Domain) datasets","text":""},{"location":"datasets/#leo-drive-isuzu-sensor-data","title":"Leo Drive - ISUZU sensor data","text":"<p>This dataset contains data from the Isuzu bus used in the Bus ODD project.</p> <p>The data contains data from following sensors:</p> <ul> <li>1 x VLP16</li> <li>2 x VLP32C</li> <li>1 x Applanix POS LV 120 GNSS/INS</li> <li>3 x Lucid Vision Triton 5.4MP cameras (left, right, front)</li> <li>Vehicle status report</li> </ul> <p>It also contains <code>/tf</code> topic for static transformations between sensors.</p>"},{"location":"datasets/#required-message-types","title":"Required message types","text":"<p>The GNSS data is available in <code>sensor_msgs/msg/NavSatFix</code> message type.</p> <p>But also the Applanix raw messages are also included in <code>applanix_msgs/msg/NavigationPerformanceGsof50</code> and <code>applanix_msgs/msg/NavigationSolutionGsof49</code> message types. In order to be able to play back these messages, you need to build and source the <code>applanix_msgs</code> package.</p> <pre><code># Create a workspace and clone the repository\nmkdir -p ~/applanix_ws/src &amp;&amp; cd \"$_\"\ngit clone https://github.com/autowarefoundation/applanix.git\ncd ..\n\n# Build the workspace\ncolcon build --symlink-install --packages-select applanix_msgs\n\n# Source the workspace\nsource ~/applanix_ws/install/setup.bash\n\n# Now you can play back the messages\n</code></pre> <p>Also make sure to source Autoware Universe workspace too.</p>"},{"location":"datasets/#download-instructions","title":"Download instructions","text":"<pre><code># Install awscli\n$ sudo apt update &amp;&amp; sudo apt install awscli -y\n\n# This will download the entire dataset to the current directory.\n# (About 10.9GB of data)\n$ aws s3 sync s3://autoware-files/collected_data/2022-08-22_leo_drive_isuzu_bags/ ./2022-08-22_leo_drive_isuzu_bags  --no-sign-request\n\n# Optionally,\n# If you instead want to download a single bag file, you can get a list of the available files with following:\n$ aws s3 ls s3://autoware-files/collected_data/2022-08-22_leo_drive_isuzu_bags/ --no-sign-request\n   PRE all-sensors-bag1_compressed/\n   PRE all-sensors-bag2_compressed/\n   PRE all-sensors-bag3_compressed/\n   PRE all-sensors-bag4_compressed/\n   PRE all-sensors-bag5_compressed/\n   PRE all-sensors-bag6_compressed/\n   PRE driving_20_kmh_2022_06_10-16_01_55_compressed/\n   PRE driving_30_kmh_2022_06_10-15_47_42_compressed/\n\n# Then you can download a single bag file with the following:\naws s3 sync s3://autoware-files/collected_data/2022-08-22_leo_drive_isuzu_bags/all-sensors-bag1_compressed/ ./all-sensors-bag1_compressed  --no-sign-request\n</code></pre>"},{"location":"datasets/#autocoreai-lidar-ros-2-bag-file-and-pcap","title":"AutoCore.ai - lidar ROS 2 bag file and pcap","text":"<p>This dataset contains pcap files and ros2 bag files from Ouster OS1-64 Lidar. The pcap file and ros2 bag file is recorded in the same time with slight difference in duration.</p> <p>Click here to download (~553MB)</p> <p>Reference Issue</p>"},{"location":"datasets/data-anonymization/","title":"Rosbag2 Anonymizer","text":""},{"location":"datasets/data-anonymization/#rosbag2-anonymizer","title":"Rosbag2 Anonymizer","text":""},{"location":"datasets/data-anonymization/#overview","title":"Overview","text":"<p>Autoware provides a tool (autoware_rosbag2_anonymizer) to anonymize ROS 2 bag files. This tool is useful when you want to share your data with Autoware community but want to keep the privacy of the data.</p> <p>With this tool you can blur any object (faces, license plates, etc.) in your bag files, and you can get a new bag file with the blurred images.</p>"},{"location":"datasets/data-anonymization/#installation","title":"Installation","text":""},{"location":"datasets/data-anonymization/#clone-the-repository","title":"Clone the repository","text":"<pre><code>git clone https://github.com/autowarefoundation/autoware_rosbag2_anonymizer.git\ncd autoware_rosbag2_anonymizer\n</code></pre>"},{"location":"datasets/data-anonymization/#download-the-pretrained-models","title":"Download the pretrained models","text":"<pre><code>wget https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\n\nwget https://huggingface.co/ShilongLiu/GroundingDINO/resolve/main/GroundingDINO_SwinB.cfg.py\nwget https://huggingface.co/ShilongLiu/GroundingDINO/resolve/main/groundingdino_swinb_cogcoor.pth\n\nwget https://github.com/autowarefoundation/autoware_rosbag2_anonymizer/releases/download/v0.0.0/yolov8x_anonymizer.pt\nwget https://github.com/autowarefoundation/autoware_rosbag2_anonymizer/releases/download/v0.0.0/yolo_config.yaml\n</code></pre>"},{"location":"datasets/data-anonymization/#install-ros-2-mcap-dependencies-if-you-will-use-mcap-files","title":"Install ROS 2 mcap dependencies if you will use mcap files","text":"<p>Warning</p> <p>Be sure you have installed the ROS 2 on your system.</p> <pre><code>sudo apt install ros-humble-rosbag2-storage-mcap\n</code></pre>"},{"location":"datasets/data-anonymization/#install-autoware_rosbag2_anonymizer-tool","title":"Install <code>autoware_rosbag2_anonymizer</code> tool","text":"<p>Before installing the tool, you should update the pip package manager.</p> <pre><code>python3 -m pip install pip -U\n</code></pre> <p>Then, you can install the tool with the following command.</p> <pre><code>python3 -m pip install .\n</code></pre>"},{"location":"datasets/data-anonymization/#configuration","title":"Configuration","text":"<p>Define prompts in the <code>validation.json</code> file. The tool will use these prompts to detect objects. You can add your prompts as dictionaries under the prompts key. Each dictionary should have two keys:</p> <ul> <li><code>prompt</code>: The prompt that will be used to detect the object. This prompt will be blurred in the anonymization process.</li> <li><code>should_inside</code>: This is a list of prompts that object should be inside. If the object is not inside the prompts, the   tool will not blur the object.</li> </ul> <pre><code>{\n\"prompts\": [\n{\n\"prompt\": \"license plate\",\n\"should_inside\": [\"car\", \"bus\", \"...\"]\n},\n{\n\"prompt\": \"human face\",\n\"should_inside\": [\"person\", \"human body\", \"...\"]\n}\n]\n}\n</code></pre> <p>You should set your configuration in the configuration files under config folder according to the usage. Following instructions will guide you to set each configuration file.</p> <ul> <li><code>config/anonymize_with_unified_model.yaml</code></li> </ul> <pre><code>rosbag:\ninput_bags_folder: \"/path/to/input_bag_folder\" # Path to the input folder which contains ROS 2 bag files\noutput_bags_folder: \"/path/to/output_folder\" # Path to the output ROS 2 bag folder\noutput_save_compressed_image: True # Save images as compressed images (True or False)\noutput_storage_id: \"sqlite3\" # Storage id for the output bag file (`sqlite3` or `mcap`)\n\ngrounding_dino:\nbox_threshold: 0.1 # Threshold for the bounding box (float)\ntext_threshold: 0.1 # Threshold for the text (float)\nnms_threshold: 0.1 # Threshold for the non-maximum suppression (float)\n\nopen_clip:\nscore_threshold: 0.7 # Validity threshold for the OpenCLIP model (float\n\nyolo:\nconfidence: 0.15 # Confidence threshold for the YOLOv8 model (float)\n\nbbox_validation:\niou_threshold: 0.9 # Threshold for the intersection over union (float), if the intersection over union is greater than this threshold, the object will be selected as inside the validation prompt\n\nblur:\nkernel_size: 31 # Kernel size for the Gaussian blur (int)\nsigma_x: 11 # Sigma x for the Gaussian blur (int)\n</code></pre> <ul> <li><code>config/yolo_create_dataset.yaml</code></li> </ul> <pre><code>rosbag:\ninput_bags_folder: \"/path/to/input_bag_folder\" # Path to the input ROS 2 bag files folder\n\ndataset:\noutput_dataset_folder: \"/path/to/output/dataset\" # Path to the output dataset folder\noutput_dataset_subsample_coefficient: 25 # Subsample coefficient for the dataset (int)\n\ngrounding_dino:\nbox_threshold: 0.1 # Threshold for the bounding box (float)\ntext_threshold: 0.1 # Threshold for the text (float)\nnms_threshold: 0.1 # Threshold for the non-maximum suppression (float)\n\nopen_clip:\nscore_threshold: 0.7 # Validity threshold for the OpenCLIP model (float\n\nbbox_validation:\niou_threshold: 0.9 # Threshold for the intersection over union (float), if the intersection over union is greater than this threshold, the object will be selected as inside the validation prompt\n</code></pre> <ul> <li><code>config/yolo_train.yaml</code></li> </ul> <pre><code>dataset:\ninput_dataset_yaml: \"path/to/data.yaml\" # Path to the config file of the dataset, which is created in the previous step\n\nyolo:\nepochs: 100 # Number of epochs for the YOLOv8 model (int)\nmodel: \"yolov8x.pt\" # Select the base model for YOLOv8 ('yolov8x.pt' 'yolov8l.pt', 'yolov8m.pt', 'yolov8n.pt')\n</code></pre> <ul> <li><code>config/yolo_anonymize.yaml</code></li> </ul> <pre><code>rosbag:\ninput_bag_path: \"/path/to/input_bag/bag.mcap\" # Path to the input ROS 2 bag file with 'mcap' or 'sqlite3' extension\noutput_bag_path: \"/path/to/output_bag_file\" # Path to the output ROS 2 bag folder\noutput_save_compressed_image: True # Save images as compressed images (True or False)\noutput_storage_id: \"sqlite3\" # Storage id for the output bag file (`sqlite3` or `mcap`)\n\nyolo:\nmodel: \"path/to/yolo/model\" # Path to the trained YOLOv8 model file (`.pt` extension) (you can download the pre-trained model from releases)\nconfig_path: \"path/to/input/data.yaml\" # Path to the config file of the dataset, which is created in the previous step\nconfidence: 0.15 # Confidence threshold for the YOLOv8 model (float)\n\nblur:\nkernel_size: 31 # Kernel size for the Gaussian blur (int)\nsigma_x: 11 # Sigma x for the Gaussian blur (int)\n</code></pre>"},{"location":"datasets/data-anonymization/#usage","title":"Usage","text":"<p>The tool provides two options to anonymize images in ROS 2 bag files.</p> <p>Warning</p> <p>If your ROS 2 bag file includes custom message types from Autoware or any other packages, you should source the their workspaces before running the tool.</p> <p>You can source Autoware workspace with the following command. </p><pre><code>source /path/to/your/workspace/install/setup.bash\n</code></pre>"},{"location":"datasets/data-anonymization/#option-1-anonymize-with-unified-model","title":"Option 1: Anonymize with Unified Model","text":"<p>You should provide a single rosbag and tool anonymize images in rosbag with a unified model. The model is a combination of GroundingDINO, OpenCLIP, YOLOv8 and SegmentAnything. If you don't want to use pre-trained YOLOv8 model, you can follow the instructions in the second option to train your own YOLOv8 model.</p> <p>You should set your configuration in config/anonymize_with_unified_model.yaml file.</p> <pre><code>python3 main.py config/anonymize_with_unified_model.yaml --anonymize_with_unified_model\n</code></pre>"},{"location":"datasets/data-anonymization/#option-2-anonymize-using-the-yolov8-model-trained-on-a-dataset-created-with-the-unified-model","title":"Option 2: Anonymize Using the YOLOv8 Model Trained on a Dataset Created with the Unified Model","text":""},{"location":"datasets/data-anonymization/#step-1-create-a-dataset","title":"Step 1: Create a Dataset","text":"<p>Create an initial dataset with the unified model. You can provide multiple ROS 2 bag files to create a dataset. After running the following command, the tool will create a dataset in YOLO format.</p> <p>You should set your configuration in config/yolo_create_dataset.yaml file.</p> <pre><code>python3 main.py config/yolo_create_dataset.yaml --yolo_create_dataset\n</code></pre>"},{"location":"datasets/data-anonymization/#step-2-manually-label-the-missing-labels","title":"Step 2: Manually Label the Missing Labels","text":"<p>The dataset which is created in the first step has some missing labels. You should label the missing labels manually. You can use the following example tools to label the missing labels:</p> <ul> <li>label-studio</li> <li>Roboflow (You can use the free version)</li> </ul>"},{"location":"datasets/data-anonymization/#step-3-split-the-dataset","title":"Step 3: Split the Dataset","text":"<p>Split the dataset into training and validation sets. Give the path to the dataset folder which is created in the first step.</p> <pre><code>autoware-rosbag2-anonymizer-split-dataset /path/to/dataset/folder\n</code></pre>"},{"location":"datasets/data-anonymization/#step-4-train-the-yolov8-model","title":"Step 4: Train the YOLOv8 Model","text":"<p>Train the YOLOv8 model with the dataset which is created in the first step.</p> <p>You should set your configuration in config/yolo_train.yaml file.</p> <pre><code>python3 main.py config/yolo_train.yaml --yolo_train\n</code></pre>"},{"location":"datasets/data-anonymization/#step-5-anonymize-images-in-ros-2-bag-files","title":"Step 5: Anonymize Images in ROS 2 Bag Files","text":"<p>Anonymize images in ROS 2 bag files with the trained YOLOv8 model. If you want to anonymize your ROS 2 bag file with only YOLOv8 model, you should use following command. But we recommend to use the unified model for better results. You can follow the Option 1 for the unified model with the YOLOv8 model trained by you.</p> <p>You should set your configuration in config/yolo_anonymize.yaml file.</p> <pre><code>python3 main.py config/yolo_anonymize.yaml --yolo_anonymize\n</code></pre>"},{"location":"datasets/data-anonymization/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Error 1: <code>torch.OutOfMemoryError: CUDA out of memory</code></li> </ul> <pre><code>torch.OutOfMemoryError: CUDA out of memory. Tried to allocate 1024.00 MiB. GPU 0 has a total capacity of 10.87 GiB of which 1010.88 MiB is free. Including non-PyTorch memory, this process has 8.66 GiB memory in use. Of the allocated memory 8.21 GiB is allocated by PyTorch, and 266.44 MiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting PYTORCH_CUDA_ALLOC_CONF=expandable_segments:True to avoid fragmentation.  See documentation for Memory Management  (https://pytorch.org/docs/stable/notes/cuda.html#environment-variables)\n</code></pre> <p>This error occurs when the GPU memory is not enough to run the model. You can add the following environment variable to avoid this error.</p> <pre><code>export PYTORCH_CUDA_ALLOC_CONF=expandable_segments:True\n</code></pre>"},{"location":"datasets/data-anonymization/#share-your-anonymized-data","title":"Share Your Anonymized Data","text":"<p>After anonymizing your data, you can share your anonymized data with the Autoware community. If you want to share your data with the Autoware community, you should create an issue and pull request to the Autoware Documentation repository.</p>"},{"location":"datasets/data-anonymization/#citation","title":"Citation","text":"<pre><code>@article{liu2023grounding,\ntitle={Grounding dino: Marrying dino with grounded pre-training for open-set object detection},\nauthor={Liu, Shilong and Zeng, Zhaoyang and Ren, Tianhe and Li, Feng and Zhang, Hao and Yang, Jie and Li, Chunyuan and Yang, Jianwei and Su, Hang and Zhu, Jun and others},\njournal={arXiv preprint arXiv:2303.05499},\nyear={2023}\n}\n</code></pre> <pre><code>@article{kirillov2023segany,\ntitle={Segment Anything},\nauthor={Kirillov, Alexander and Mintun, Eric and Ravi, Nikhila and Mao, Hanzi and Rolland, Chloe and Gustafson, Laura and Xiao, Tete and Whitehead, Spencer and Berg, Alexander C. and Lo, Wan-Yen and Doll{\\'a}r, Piotr and Girshick, Ross},\njournal={arXiv:2304.02643},\nyear={2023}\n}\n</code></pre> <pre><code>@software{ilharco_gabriel_2021_5143773,\nauthor       = {Ilharco, Gabriel and\n                  Wortsman, Mitchell and\n                  Wightman, Ross and\n                  Gordon, Cade and\n                  Carlini, Nicholas and\n                  Taori, Rohan and\n                  Dave, Achal and\n                  Shankar, Vaishaal and\n                  Namkoong, Hongseok and\n                  Miller, John and\n                  Hajishirzi, Hannaneh and\n                  Farhadi, Ali and\n                  Schmidt, Ludwig},\ntitle        = {OpenCLIP},\nmonth        = jul,\nyear         = 2021,\nnote         = {If you use this software, please cite it as below.},\npublisher    = {Zenodo},\nversion      = {0.1},\ndoi          = {10.5281/zenodo.5143773},\nurl          = {https://doi.org/10.5281/zenodo.5143773}\n}\n</code></pre>"},{"location":"design/","title":"Autoware's Design","text":""},{"location":"design/#autowares-design","title":"Autoware's Design","text":""},{"location":"design/#architecture","title":"Architecture","text":"<p>Core and Universe.</p> <p>Autoware provides the runtimes and technology components by open-source software. The runtimes are based on the Robot Operating System (ROS). The technology components are provided by contributors, which include, but are not limited to:</p> <ul> <li>Sensing<ul> <li>Camera Component</li> <li>LiDAR Component</li> <li>RADAR Component</li> <li>GNSS Component</li> </ul> </li> <li>Computing<ul> <li>Localization Component</li> <li>Perception Component</li> <li>Planning Component</li> <li>Control Component</li> <li>Logging Component</li> <li>System Monitoring Component</li> </ul> </li> <li>Actuation<ul> <li>DBW Component</li> </ul> </li> <li>Tools<ul> <li>Simulator Component</li> <li>Mapping Component</li> <li>Remote Component</li> <li>ML Component</li> <li>Annotation Component</li> <li>Calibration Component</li> </ul> </li> </ul>"},{"location":"design/#concern-assumption-and-limitation","title":"Concern, Assumption, and Limitation","text":"<p>The downside of the microautonomy architecture is that the computational performance of end applications is sacrificed due to its data path overhead attributed to functional modularity. In other words, the trade-off characteristic of the microautonomy architecture exists between computational performance and functional modularity. This trade-off problem can be solved technically by introducing real-time capability. This is because autonomous driving systems are not really designed to be real-fast, that is, low-latency computing is nice-to-have but not must-have. The must-have feature for autonomous driving systems is that the latency of computing is predictable, that is, the systems are real-time. As a whole, we can compromise computational performance to an extent that is predictable enough to meet the given timing constraints of autonomous driving systems, often referred to as deadlines of computation.</p>"},{"location":"design/#design","title":"Design","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/#autoware-concepts","title":"Autoware concepts","text":"<p>The Autoware concepts page describes the design philosophy of Autoware. Readers (service providers and all Autoware users) will learn the basic concepts underlying Autoware development, such as microautonomy and the Core/Universe architecture.</p>"},{"location":"design/#autoware-architecture","title":"Autoware architecture","text":"<p>The Autoware architecture page describes an overview of each module that makes up Autoware. Readers (all Autoware users) will gain a high-level picture of how each module that composes Autoware works.</p>"},{"location":"design/#autoware-interfaces","title":"Autoware interfaces","text":"<p>The Autoware interfaces page describes in detail the interface of each module that makes up Autoware. Readers (intermediate developers) will learn how to add new functionality to Autoware and how to integrate their own modules with Autoware.</p>"},{"location":"design/#configuration-management","title":"Configuration management","text":""},{"location":"design/#conclusion","title":"Conclusion","text":""},{"location":"design/autoware-architecture/","title":"Architecture overview","text":""},{"location":"design/autoware-architecture/#architecture-overview","title":"Architecture overview","text":"<p>This page describes the architecture of Autoware.</p>"},{"location":"design/autoware-architecture/#introduction","title":"Introduction","text":"<p>The current Autoware is defined to be a layered architecture that clarifies each module's role and simplifies the interface between them. By doing so:</p> <ul> <li>Autoware's internal processing becomes more transparent.</li> <li>Collaborative development is made easier because of the reduced interdependency between modules.</li> <li>Users can easily replace an existing module (e.g. localization) with their own software component by simply wrapping their software to fit in with Autoware's interface.</li> </ul> <p>Note that the initial focus of this architecture design was solely on driving capability, and so the following features were left as future work:</p> <ul> <li>Fail safe</li> <li>Human Machine Interface</li> <li>Real-time processing</li> <li>Redundant system</li> <li>State monitoring system</li> </ul>"},{"location":"design/autoware-architecture/#high-level-architecture-design","title":"High-level architecture design","text":"<p>Autoware's architecture consists of the following six stacks. Each linked page contains a more detailed set of requirements and use cases specific to that stack:</p> <ul> <li>Sensing design</li> <li>Map design</li> <li>Localization design</li> <li>Perception design</li> <li>Planning design</li> <li>Control design</li> <li>Vehicle Interface design</li> </ul>"},{"location":"design/autoware-architecture/#node-diagram","title":"Node diagram","text":"<p>A diagram showing Autoware's nodes in the default configuration can be found on the Node diagram page. Detailed documents for each node are available in the Autoware Universe docs.</p> <p>Note that Autoware configurations are scalable / selectable and will vary depending on the environment and required use cases.</p>"},{"location":"design/autoware-architecture/#references","title":"References","text":"<ul> <li>The architecture presentation given to the AWF Technical Steering Committee, March 2020</li> </ul>"},{"location":"design/autoware-architecture/control/","title":"Control component design","text":""},{"location":"design/autoware-architecture/control/#control-component-design","title":"Control component design","text":""},{"location":"design/autoware-architecture/control/#abstract","title":"Abstract","text":"<p>This document presents the design concept of the Control Component. The content is as follows:</p> <ul> <li>Autoware Control Design<ul> <li>Outlining the policy for Autoware's control, which deals with only general information for autonomous driving systems and provides generic control commands to the vehicle.</li> </ul> </li> <li>Vehicle Adaptation Design<ul> <li>Describing the policy for vehicle adaptation, which utilizes adapter mechanisms to standardize the characteristics of the vehicle's drive system and integrate it with Autoware.</li> </ul> </li> <li>Control Feature Design<ul> <li>Demonstrating the features provided by Autoware's control.</li> <li>Presenting the approach towards the functions installed in the vehicle such as ABS.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/control/#autoware-control-design","title":"Autoware Control Design","text":"<p>The Control Component generates the control signal to which the Vehicle Component subscribes. The generated control signals are computed based on the reference trajectories from the Planning Component.</p> <p></p> <p>The Control Component consists of two modules. The <code>trajectory_follower</code> module generates a vehicle control command to follow the reference trajectory received from the planning module. The command includes, for example, the desired steering angle and target speed. The <code>vehicle_command_gate</code> is responsible for filtering the control command to prevent abnormal values and then sending it to the vehicle. This gate also allows switching between multiple sources such as the MRM (minimal risk maneuver) module or some remote control module, in addition to the trajectory follower.</p> <p>The Autoware control system is designed as a platform for automated driving systems that can be compatible with a diverse range of vehicles.</p> <p>The control process in Autoware uses general information (such as target acceleration and deceleration) and no vehicle-specific information (such as brake pressure) is used. Hence it can be adjusted independently of the vehicle's drive interface enabling easy integration or performance tuning.</p> <p>Furthermore, significant differences that affect vehicle motion constraints, such as two-wheel steering or four-wheel steering, are addressed by switching the control vehicle model, achieving control specialized for each characteristic.</p> <p>Autoware's control module outputs the necessary information to control the vehicle as a substitute for a human driver. For example, the control command from the control module looks like the following:</p> <pre><code>- Target steering angle\n- Target steering torque\n- Target speed\n- Target acceleration\n</code></pre> <p>Note that vehicle-specific values such as pedal positions and low-level information such as individual wheel rotation speeds are excluded from the command.</p>"},{"location":"design/autoware-architecture/control/#vehicle-adaptation-design","title":"Vehicle Adaptation Design","text":""},{"location":"design/autoware-architecture/control/#vehicle-interface-adapter","title":"Vehicle interface adapter","text":"<p>Autoware is designed to be an autonomous driving platform able to accommodate vehicles with various drivetrain types.</p> <p>This is an explanation of how Autoware handles the standardization of systems with different vehicle drivetrain. The interfaces for vehicle drivetrain are diverse, including steering angle, steering angular velocity, steering torque, speed, accel/brake pedals, and brake pressure. To accommodate these differences, Autoware adds an adapter module between the control component and the vehicle interface. This module performs the conversion between the proprietary message types used by the vehicle (such as brake pressure) and the generic types used by Autoware (such as desired acceleration). By providing this conversion information, the differences in vehicle drivetrain can be accommodated.</p> <p>If the information is not known in advance, an automatic calibration tool can be used. Calibration will occur within limited degrees of freedom, generating the information necessary for the drivetrain conversion automatically.</p> <p>This configuration is summarized in the following diagram.</p> <p></p>"},{"location":"design/autoware-architecture/control/#examples-of-several-vehicle-interfaces","title":"Examples of several vehicle interfaces","text":"<p>This is an example of the several drivetrain types in the vehicle interface.</p> Vehicle Lateral interface Longitudinal interface Note Lexus Steering angle Accel/brake pedal position Acceleration lookup table conversion for longitudinal JPN TAXI Steering angle Accel/brake pedal position Acceleration lookup table conversion for longitudinal GSM8 Steering EPS voltage Acceleration motor voltage, Deceleration brake hydraulic pressure lookup table and PID conversion for lateral and longitudinal YMC Golfcart Steering angle Velocity Logiee yaw rate Velocity F1 TENTH Steering angle Motor RPM interface code"},{"location":"design/autoware-architecture/control/#control-feature-design","title":"Control Feature Design","text":"<p>The following lists the features provided by Autoware's Control/Vehicle component, as well as the conditions and assumptions required to utilize them effectively.</p> <p>The proper operation of the ODD is limited by factors such as whether the functions are enabled, delay time, calibration accuracy and degradation rate, and sensor accuracy.</p> Feature Description\u3000 Requirements/Assumptions Note \u3000Limitation for now Lateral Control Control the drivetrain system related to lateral vehicle motion Trying to increase the number of vehicle types that can be supported in the future. Only front-steering type is supported. Longitudinal Control Control the drivetrain system related to longitudinal vehicle motion Slope Compensation Supports precise vehicle motion control on slopes Gradient information can be obtained from maps or sensors attached to the chassis If gradient information is not available, the gradient is estimated from the vehicle's pitch angle. Delay Compensation Controls the drivetrain system appropriately in the presence of time delays The drivetrain delay information is provided in advance If there is no delay information, the drivetrain delay is estimated automatically (automatic calibration). However, the effect of delay cannot be completely eliminated, especially in scenarios with sudden changes in speed. Only fixed delay times can be set for longitudinal and lateral drivetrain systems separately. It does not accommodate different delay times for the accelerator and brake. Drivetrain IF Conversion (Lateral Control) Converts the drivetrain-specific information of the vehicle into the drivetrain information used by Autoware (e.g., target steering angular velocity \u2192 steering torque) The conversion information is provided in advance If there is no conversion information, the conversion map is estimated automatically (automatic calibration). The degree of freedom for conversion is limited (2D lookup table + PID FB). Drivetrain IF Conversion (Longitudinal Control) Converts the drivetrain-specific information of the vehicle into the drivetrain information used by Autoware (e.g., target acceleration \u2192 accelerator/brake pedal value) The conversion information is provided in advance If there is no conversion information, the conversion map is estimated automatically (automatic calibration). The degree of freedom for conversion is limited (2D lookup table + PID FB). Automatic Calibration Automatically estimates and applies values such as drivetrain IF conversion map and delay time. The drivetrain status can be obtained (must) Anomaly Detection Notifies when there is a discrepancy in the calibration or unexpected drivetrain behavior The drivetrain status can be obtained (must) Steering Zero Point Correction Corrects the midpoint of the steering to achieve appropriate steering control The drivetrain status can be obtained (must) Steering Deadzone Correction Corrects the deadzone of the steering to achieve appropriate steering control The steering deadzone parameter is provided in advance If the parameter is unknown, the deadzone parameter is estimated from driving information Not available now Steering Deadzone Estimation Dynamically estimates the steering deadzone from driving data Not available now Weight Compensation Performs appropriate vehicle control according to weight Weight information can be obtained from sensors If there is no weight sensor, estimate the weight from driving information. Currently not available Weight Estimation Dynamically estimates weight from driving data Currently not available <p>The list above does not cover wheel control systems such as ABS commonly used in vehicles. Regarding these features, the following considerations are taken into account.</p>"},{"location":"design/autoware-architecture/control/#integration-with-vehicle-side-functions","title":"Integration with vehicle-side functions","text":"<p>ABS (Anti-lock Brake System) and ESC (Electric Stability Control) are two functions that may be pre-installed on a vehicle, directly impacting its controllability. The control modules of Autoware assume that both ABS and ESC are installed on the vehicle and their absence may cause unreliable controls depending on the target ODD. For example, with low-velocity driving in a controlled environment, these functions are not necessary.</p> <p>Also, note that this statement does not negate the development of ABS functionality in autonomous driving systems.</p>"},{"location":"design/autoware-architecture/control/#autoware-capabilities-and-vehicle-requirements","title":"Autoware Capabilities and Vehicle Requirements","text":"<p>As an alternative to human driving, autonomous driving systems essentially aim to handle tasks that humans can perform. This includes not only controlling the steering wheel, accel, and brake, but also automatically detecting issues such as poor brake response or a misaligned steering angle. However, this is a trade-off, as better vehicle performance will lead to superior system behavior, ultimately affecting the design of ODD.</p> <p>On the other hand, for tasks that are not typically anticipated or cannot be handled by a human driver, processing in the vehicle ECU is expected. Examples of such scenarios include cases where the brake response is clearly delayed or when the vehicle rotates due to a single-side tire slipping. These tasks are typically handled by ABS or ESC.</p>"},{"location":"design/autoware-architecture/localization/","title":"Index","text":"<p>LOCALIZATION COMPONENT DESIGN DOC</p>"},{"location":"design/autoware-architecture/localization/#abstract","title":"Abstract","text":""},{"location":"design/autoware-architecture/localization/#1-requirements","title":"1. Requirements","text":"<p>Localization aims to estimate vehicle pose, velocity, and acceleration.</p> <p>Goals:</p> <ul> <li>Propose a system that can estimate vehicle pose, velocity, and acceleration for as long as possible.</li> <li>Propose a system that can diagnose the stability of estimation and send a warning message to the error-monitoring system if the estimation result is unreliable.</li> <li>Design a vehicle localization function that can work with various sensor configurations.</li> </ul> <p>Non-goals:</p> <ul> <li>This design document does not aim to develop a localization system that<ul> <li>is infallible in all environments</li> <li>works outside of the pre-defined ODD (Operational Design Domain)</li> <li>has better performance than is required for autonomous driving</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/localization/#2-sensor-configuration-examples","title":"2. Sensor Configuration Examples","text":"<p>This section shows example sensor configurations and their expected performances. Each sensor has its own advantages and disadvantages, but overall performance can be improved by fusing multiple sensors.</p>"},{"location":"design/autoware-architecture/localization/#3d-lidar-pointcloud-map","title":"3D-LiDAR + PointCloud Map","text":""},{"location":"design/autoware-architecture/localization/#expected-situation","title":"Expected situation","text":"<ul> <li>The vehicle is located in a structure-rich environment, such as an urban area</li> </ul>"},{"location":"design/autoware-architecture/localization/#situations-that-can-make-the-system-unstable","title":"Situations that can make the system unstable","text":"<ul> <li>The vehicle is placed in a structure-less environment, such as a rural landscape, highway, or tunnel</li> <li>Environmental changes have occurred since the map was created, such as snow cover or the construction/destruction of buildings.</li> <li>Surrounding objects are occluded</li> <li>The car is surrounded by objects undetectable by LiDAR, e.g., glass windows, reflections, or absorption (dark objects)</li> <li>The environment contains laser beams at the same frequency as the car's LiDAR sensor(s)</li> </ul>"},{"location":"design/autoware-architecture/localization/#functionality","title":"Functionality","text":"<ul> <li>The system can estimate the vehicle location on the point cloud map with the error of ~10cm.</li> <li>The system is operable at night.</li> </ul>"},{"location":"design/autoware-architecture/localization/#3d-lidar-or-camera-vector-map","title":"3D-LiDAR or Camera + Vector Map","text":""},{"location":"design/autoware-architecture/localization/#expected-situation_1","title":"Expected situation","text":"<ul> <li>Road with clear white lines and loose curvatures, such as a highway or an ordinary local road.</li> </ul>"},{"location":"design/autoware-architecture/localization/#situations-that-can-make-the-system-unstable_1","title":"Situations that can make the system unstable","text":"<ul> <li>White lines are scratchy or covered by rain or snow</li> <li>Tight curvature such as intersections</li> <li>Large reflection change of the road surface caused by rain or paint</li> </ul>"},{"location":"design/autoware-architecture/localization/#functionalities","title":"Functionalities","text":"<ul> <li>Correct vehicle positions along the lateral direction.</li> <li>Pose correction along the longitudinal can be inaccurate, but can be resolved by fusing with GNSS.</li> </ul>"},{"location":"design/autoware-architecture/localization/#gnss","title":"GNSS","text":""},{"location":"design/autoware-architecture/localization/#expected-situation_2","title":"Expected situation","text":"<ul> <li>The vehicle is placed in an open environment with few to no surrounding objects, such as a rural landscape.</li> </ul>"},{"location":"design/autoware-architecture/localization/#situation-that-can-make-the-system-unstable","title":"Situation that can make the system unstable","text":"<ul> <li>GNSS signals are blocked by surrounding objects, e.g., tunnels or buildings.</li> </ul>"},{"location":"design/autoware-architecture/localization/#functionality_1","title":"Functionality","text":"<ul> <li>The system can estimate vehicle position in the world coordinate within an error of ~10m.</li> <li>With a RKT-GNSS (Real Time Kinematic Global Navigation Satellite System) attached, the accuracy can be improved to ~10cm.</li> <li>A system with this configuration can work without environment maps (both point cloud and vector map types).</li> </ul>"},{"location":"design/autoware-architecture/localization/#camera-visual-odometry-visual-slam","title":"Camera (Visual Odometry, Visual SLAM)","text":""},{"location":"design/autoware-architecture/localization/#expected-situation_3","title":"Expected situation","text":"<ul> <li>The vehicle is placed in an environment with rich visual features, such as an urban area.</li> </ul>"},{"location":"design/autoware-architecture/localization/#situations-that-can-make-the-system-unstable_2","title":"Situations that can make the system unstable","text":"<ul> <li>The vehicle is placed in a texture-less environment.</li> <li>The vehicle is surrounded by other objects.</li> <li>The camera observes significant illumination changes, such as those caused by sunshine, headlights from other vehicles or when approaching the exit of a tunnel.</li> <li>The vehicle is placed in a dark environment.</li> </ul>"},{"location":"design/autoware-architecture/localization/#functionality_2","title":"Functionality","text":"<ul> <li>The system can estimate odometry by tracking visual features.</li> </ul>"},{"location":"design/autoware-architecture/localization/#wheel-speed-sensor","title":"Wheel speed sensor","text":""},{"location":"design/autoware-architecture/localization/#expected-situation_4","title":"Expected situation","text":"<ul> <li>The vehicle is running on a flat and smooth road.</li> </ul>"},{"location":"design/autoware-architecture/localization/#situations-that-can-make-the-system-unstable_3","title":"Situations that can make the system unstable","text":"<ul> <li>The vehicle is running on a slippery or bumpy road, which can cause incorrect observations of wheel speed.</li> </ul>"},{"location":"design/autoware-architecture/localization/#functionality_3","title":"Functionality","text":"<ul> <li>The system can acquire the vehicle velocity and estimate distance traveled.</li> </ul>"},{"location":"design/autoware-architecture/localization/#imu","title":"IMU","text":""},{"location":"design/autoware-architecture/localization/#expected-environments","title":"Expected environments","text":"<ul> <li>Flat, smooth roads</li> </ul>"},{"location":"design/autoware-architecture/localization/#situations-that-can-make-the-system-unstable_4","title":"Situations that can make the system unstable","text":"<ul> <li>IMUs have a bias1 that is dependent on the surrounding temperature, and can cause incorrect sensor observation or odometry drift.</li> </ul>"},{"location":"design/autoware-architecture/localization/#functionality_4","title":"Functionality","text":"<ul> <li>The system can observe acceleration and angular velocity.</li> <li>By integrating these observations, the system can estimate the local pose change and realize dead-reckoning</li> </ul>"},{"location":"design/autoware-architecture/localization/#geomagnetic-sensor","title":"Geomagnetic sensor","text":""},{"location":"design/autoware-architecture/localization/#expected-situation_5","title":"Expected situation","text":"<ul> <li>The vehicle is placed in an environment with low magnetic noise</li> </ul>"},{"location":"design/autoware-architecture/localization/#situations-that-can-make-the-system-unstable_5","title":"Situations that can make the system unstable","text":"<ul> <li>The vehicle is placed in an environment with high magnetic noise, such as one containing buildings or structures with reinforced steel or other materials that generate electromagnetic waves.</li> </ul>"},{"location":"design/autoware-architecture/localization/#functionality_5","title":"Functionality","text":"<ul> <li>The system can estimate the vehicle's direction in the world coordinate system.</li> </ul>"},{"location":"design/autoware-architecture/localization/#magnetic-markers","title":"Magnetic markers","text":""},{"location":"design/autoware-architecture/localization/#expected-situation_6","title":"Expected situation","text":"<ul> <li>The car is placed in an environment with magnetic markers installed.</li> </ul>"},{"location":"design/autoware-architecture/localization/#situations-where-the-system-becomes-unstable","title":"Situations where the system becomes unstable","text":"<ul> <li>The markers are not maintained.</li> </ul>"},{"location":"design/autoware-architecture/localization/#functionality_6","title":"Functionality","text":"<ul> <li>Vehicle location can be obtained on the world coordinate by detecting the magnetic markers.</li> <li>The system can work even if the road is covered with snow.</li> </ul>"},{"location":"design/autoware-architecture/localization/#3-requirements","title":"3. Requirements","text":"<ul> <li>By implementing different modules, various sensor configurations and algorithms can be used.</li> <li>The localization system can start pose estimation from an ambiguous initial location.</li> <li>The system can produce a reliable initial location estimation.</li> <li>The system can manage the state of the initial location estimation (uninitialized, initializable, or non-initializable) and can report to the error monitor.</li> </ul>"},{"location":"design/autoware-architecture/localization/#4-architecture","title":"4. Architecture","text":""},{"location":"design/autoware-architecture/localization/#abstract_1","title":"Abstract","text":"<p>Two architectures are defined, \"Required\" and \"Recommended\". However, the \"Required\" architecture only contains the inputs and outputs necessary to accept various localization algorithms. To improve the reusability of each module, the required components are defined in the \"Recommended\" architecture section along with a more detailed explanation.</p>"},{"location":"design/autoware-architecture/localization/#required-architecture","title":"Required Architecture","text":""},{"location":"design/autoware-architecture/localization/#input","title":"Input","text":"<ul> <li>Sensor message<ul> <li>e.g., LiDAR, camera, GNSS, IMU, CAN Bus, etc.</li> <li>Data types should be ROS primitives for reusability</li> </ul> </li> <li>Map data<ul> <li>e.g., point cloud map, lanelet2 map, feature map, etc.</li> <li>The map format should be chosen based on use case and sensor configuration</li> <li>Note that map data is not required for some specific cases (e.g., GNSS-only localization)</li> </ul> </li> <li>tf, static_tf<ul> <li>map frame</li> <li>base_link frame</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/localization/#output","title":"Output","text":"<ul> <li>Pose with covariance stamped<ul> <li>Vehicle pose, covariance, and timestamp on the map coordinate</li> <li>50Hz~ frequency (depending on the requirements of the Planning and Control components)</li> </ul> </li> <li>Twist with covariance stamped<ul> <li>Vehicle velocity, covariance, and timestamp on the base_link coordinate</li> <li>50Hz~ frequency</li> </ul> </li> <li>Accel with covariance stamped<ul> <li>Acceleration, covariance, and timestamp on the base_link coordinate</li> <li>50Hz~ frequency</li> </ul> </li> <li>Diagnostics<ul> <li>Diagnostics information that indicates if the localization module works properly</li> </ul> </li> <li>tf<ul> <li>tf of map to base_link</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/localization/#recommended-architecture","title":"Recommended Architecture","text":""},{"location":"design/autoware-architecture/localization/#pose-estimator","title":"Pose Estimator","text":"<ul> <li>Estimates the vehicle pose on the map coordinate by matching external sensor observation to the map</li> <li>Provides the obtained pose and its covariance to <code>PoseTwistFusionFilter</code></li> </ul>"},{"location":"design/autoware-architecture/localization/#twist-accel-estimator","title":"Twist-Accel Estimator","text":"<ul> <li>Produces the vehicle velocity, angular velocity, acceleration, angular acceleration, and their covariances<ul> <li>It is possible to create a single module for both twist and acceleration or to create two separate modules - the choice of architecture is up to the developer</li> </ul> </li> <li>The twist estimator produces velocity and angular velocity from internal sensor observation</li> <li>The accel estimator produces acceleration and angular acceleration from internal sensor observations</li> </ul>"},{"location":"design/autoware-architecture/localization/#kinematics-fusion-filter","title":"Kinematics Fusion Filter","text":"<ul> <li>Produces the likeliest pose, velocity, acceleration, and their covariances, computed by fusing two kinds of information:<ul> <li>The pose obtained from the pose estimator.</li> <li>The velocity and acceleration obtained from the twist-accel estimator</li> </ul> </li> <li>Produces tf of map to base_link according to the pose estimation result</li> </ul>"},{"location":"design/autoware-architecture/localization/#localization-diagnostics","title":"Localization Diagnostics","text":"<ul> <li>Monitors and guarantees the stability and reliability of pose estimation by fusing information obtained from multiple localization modules</li> <li>Reports error status to the error monitor</li> </ul>"},{"location":"design/autoware-architecture/localization/#tf-tree","title":"TF tree","text":"frame meaning earth ECEF (Earth Centered Earth Fixed\uff09 map Origin of the map coordinate (ex. MGRS origin) viewer User-defined frame for rviz base_link Reference pose of the ego-vehicle (projection of the rear-axle center onto the ground surface) sensor Reference pose of each sensor <p>Developers can optionally add other frames such as odom or base_footprint as long as the tf structure above is maintained.</p>"},{"location":"design/autoware-architecture/localization/#the-localization-modules-ideal-functionality","title":"The localization module's ideal functionality","text":"<ul> <li>The localization module should provide pose, velocity, and acceleration for control, planning, and perception.</li> <li>Latency and stagger should be sufficiently small or adjustable such that the estimated values can be used for control within the ODD (Operational Design Domain).</li> <li>The localization module should produce the pose on a fixed coordinate frame.</li> <li>Sensors should be independent of each other so that they can be easily replaced.</li> <li>The localization module should provide a status indicating whether or not the autonomous vehicle can operate with the self-contained function or map information.</li> <li>Tools or manuals should describe how to set proper parameters for the localization module</li> <li>Valid calibration parameters should be provided to align different frame or pose coordinates and sensor timestamps.</li> </ul>"},{"location":"design/autoware-architecture/localization/#kpi","title":"KPI","text":"<p>To maintain sufficient pose estimation performance for safe operation, the following metrics are considered:</p> <ul> <li>Safety<ul> <li>The distance traveled within the ODD where pose estimation met the required accuracy, divided by the overall distance traveled within the ODD, as a percentage.</li> <li>The anomaly detection rate for situations where the localization module cannot estimate pose within the ODD</li> <li>The accuracy of detecting when the vehicle goes outside of the ODD, as a percentage.</li> </ul> </li> <li>Computational load</li> <li>Latency</li> </ul>"},{"location":"design/autoware-architecture/localization/#5-interface-and-data-structure","title":"5. Interface and Data Structure","text":""},{"location":"design/autoware-architecture/localization/#6-concerns-assumptions-and-limitations","title":"6. Concerns, Assumptions, and Limitations","text":""},{"location":"design/autoware-architecture/localization/#prerequisites-of-sensors-and-inputs","title":"Prerequisites of sensors and inputs","text":""},{"location":"design/autoware-architecture/localization/#sensor-prerequisites","title":"Sensor prerequisites","text":"<ul> <li>Input data is not defective.<ul> <li>Internal sensor observation such as IMU continuously keeps the proper frequency.</li> </ul> </li> <li>Input data has correct and exact time stamps.<ul> <li>Estimated poses can be inaccurate or unstable if the timestamps are not exact.</li> </ul> </li> <li>Sensors are correctly mounted with exact positioning and accessible from TF.<ul> <li>If the sensor positions are inaccurate, estimation results may be incorrect or unstable.</li> <li>A sensor calibration framework is required to properly obtain the sensor positions.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/localization/#map-prerequisites","title":"Map prerequisites","text":"<ul> <li>Sufficient information is contained within the map.<ul> <li>Pose estimation might be unstable if there is insufficient information in the map.</li> <li>A testing framework is necessary to check if the map has adequate information for pose estimation.</li> </ul> </li> <li>Map does not differ greatly from the actual environment.<ul> <li>Pose estimation might be unstable if the actual environment has different objects from the map.</li> <li>Maps need updates according to new objects and seasonal changes.</li> </ul> </li> <li>Maps must be aligned to a uniform coordinate, or an alignment framework is in place.<ul> <li>If multiple maps with different coordinate systems are used, the misalignment between them can affect the localization performance.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/localization/#computational-resources","title":"Computational resources","text":"<ul> <li>Sufficient computational resources should be provided to maintain accuracy and computation speed.</li> </ul> <ol> <li> <p>For more details about bias, refer to the VectorNav IMU specifications page.\u00a0\u21a9</p> </li> </ol>"},{"location":"design/autoware-architecture/map/","title":"Map component design","text":""},{"location":"design/autoware-architecture/map/#map-component-design","title":"Map component design","text":""},{"location":"design/autoware-architecture/map/#1-overview","title":"1. Overview","text":"<p>Autoware relies on high-definition point cloud maps and vector maps of the driving environment to perform various tasks such as localization, route planning, traffic light detection, and predicting the trajectories of pedestrians and other vehicles.</p> <p>This document describes the design of map component of Autoware, including its requirements, architecture design, features, data formats, and interface to distribute map information to the rest of autonomous driving stack.</p>"},{"location":"design/autoware-architecture/map/#2-requirements","title":"2. Requirements","text":"<p>Map should provide two types of information to the rest of the stack:</p> <ul> <li>Semantic information about roads as a vector map</li> <li>Geometric information about the environment as a point cloud map (optional)</li> </ul> <p>A vector map contains highly accurate information about a road network, lane geometry, and traffic lights. It is required for route planning, traffic light detection, and predicting the trajectories of other vehicles and pedestrians.</p> <p>A 3D point cloud map is primarily used for LiDAR-based localization and part of perception in Autoware. In order to determine the current position and orientation of the vehicle, a live scan captured from one or more LiDAR units is matched against a pre-generated 3D point cloud map. Therefore, an accurate point cloud map is crucial for good localization results. However, if the vehicle has an alternate localization method with enough accuracy, for example using camera-based localization, point cloud map may not be required to use Autoware.</p> <p>In addition to above two types of maps, Autoware also requires a supplemental file for specifying the coordinate system of the map in geodetic system.</p>"},{"location":"design/autoware-architecture/map/#3-architecture","title":"3. Architecture","text":"<p>This diagram describes the high-level architecture of Map component in Autoware.</p> <p></p> <p>The Map component consists of the following sub-components:</p> <ul> <li>Point Cloud Map Loading: Load and publish point cloud map</li> <li>Vector Map Loading: Load and publish vector map</li> <li>Projection Loading: Load and publish projection information for conversion between local coordinate (x, y, z) and geodetic coordinate (latitude, longitude, altitude)</li> </ul>"},{"location":"design/autoware-architecture/map/#4-component-interface","title":"4. Component interface","text":""},{"location":"design/autoware-architecture/map/#input-to-the-map-component","title":"Input to the map component","text":"<ul> <li>From file system<ul> <li>Point cloud map and its metadata file</li> <li>Vector map</li> <li>Projection information</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/map/#output-from-the-map-component","title":"Output from the map component","text":"<ul> <li>To Sensing<ul> <li>Projection information: Used to convert GNSS data from geodetic coordinate system to local coordinate system</li> </ul> </li> <li>To Localization<ul> <li>Point cloud map: Used for LiDAR-based localization</li> <li>Vector map: Used for localization methods based on road markings, etc</li> </ul> </li> <li>To Perception<ul> <li>Point cloud map: Used for obstacle segmentation by comparing LiDAR and point cloud map</li> <li>Vector map: Used for vehicle trajectory prediction</li> </ul> </li> <li>To Planning<ul> <li>Vector map: Used for behavior planning</li> </ul> </li> <li>To API layer<ul> <li>Projection information: Used to convert localization results from local coordinate system to geodetic coordinate system</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/map/#5-map-specification","title":"5. Map Specification","text":""},{"location":"design/autoware-architecture/map/#point-cloud-map","title":"Point Cloud Map","text":"<p>The point cloud map must be supplied as a file with the following requirements:</p> <ul> <li>The point cloud map must be projected on the same coordinate defined in <code>map_projection_loader</code> in order to be consistent with the lanelet2 map and other packages that converts between local and geodetic coordinates. For more information, please refer to the readme of <code>map_projection_loader</code>.</li> <li>It must be in the PCD (Point Cloud Data) file format, but can be a single PCD file or divided into multiple PCD files.</li> <li>Each point in the map must contain X, Y, and Z coordinates.</li> <li>An intensity or RGB value for each point may be optionally included.</li> <li>It must cover the entire operational area of the vehicle. It is also recommended to include an additional buffer zone according to the detection range of sensors attached to the vehicle.</li> <li>Its resolution should be at least 0.2 m to yield reliable localization results.</li> <li>It can be in either local or global coordinates, but must be in global coordinates (georeferenced) to use GNSS data for localization.</li> </ul> <p>For more details on divided map format, please refer to the readme of <code>map_loader</code> in Autoware Universe.</p> <p>Note</p> <p>Three global coordinate systems are currently supported by Autoware, including Military Grid Reference System (MGRS), Universal Transverse Mercator (UTM), and Japan Rectangular Coordinate System. However, MGRS is a preferred coordinate system for georeferenced maps. In a map with MGRS coordinate system, the X and Y coordinates of each point represent the point's location within the 100,000-meter square, while the Z coordinate represents the point's elevation.</p>"},{"location":"design/autoware-architecture/map/#vector-map","title":"Vector Map","text":"<p>The vector cloud map must be supplied as a file with the following requirements:</p> <ul> <li>It must be in Lanelet2 format, with additional modifications required by Autoware.</li> <li>It must contain the shape and position information of lanes, traffic lights, stop lines, crosswalks, parking spaces, and parking lots.</li> <li>Except at the beginning or end of a road, each lanelet in the map must be correctly connected to its predecessor, successors, left neighbor, and right neighbor.</li> <li>Each lanelet in the map must contain traffic rule information including its speed limit, right of way, traffic direction, associated traffic lights, stop lines, and traffic signs.</li> <li>It must cover the entire operational area of the vehicle.</li> </ul> <p>For detailed specifications on Vector Map creation, please refer to Vector Map Creation Requirement Specification document.</p>"},{"location":"design/autoware-architecture/map/#projection-information","title":"Projection Information","text":"<p>The projection information must be supplied as a file with the following requirements:</p> <ul> <li>It must be in YAML format, provided into <code>map_projection_loader</code> in current Autoware Universe implementation.</li> <li>The file must contain the following information:<ul> <li>The name of the projection method used to convert between local and global coordinates</li> <li>The parameters of the projection method (depending on the projection method)</li> </ul> </li> </ul> <p>For further information, please refer to the readme of <code>map_projection_loader</code> in Autoware Universe.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/","title":"Vector Map creation requirement specifications","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/#vector-map-creation-requirement-specifications","title":"Vector Map creation requirement specifications","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/#overview","title":"Overview","text":"<p>Autoware relies on high-definition point cloud maps and vector maps of the driving environment to perform various tasks such as localization, route planning, traffic light detection, and predicting the trajectories of pedestrians and other vehicles.</p> <p>A vector map contains highly accurate information about a road network, lane geometry, and traffic lights. It is required for route planning, traffic light detection, and predicting the trajectories of other vehicles and pedestrians.</p> <p>Vector Map uses lanelet2_extension, which is based on the lanelet2 format and extended for Autoware.</p> <p>The primitives (basic components) used in Vector Map are explained in Web.Auto Docs - What is Lanelet2. The following Vector Map creation requirement specifications are written on the premise of these knowledge.</p> <p>This specification is a set of requirements for the creation of Vector Map(s) to ensure that Autoware drives safely and autonomously as intended by the user. To Create a Lanelet2 format .osm file, please refer to Creating a vector map.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/#handling-of-the-requirement-specification","title":"Handling of the Requirement Specification","text":"<p>Which requirements apply entirely depends on the configuration of the Autoware system on a vehicle. Before creating a Vector Map, it is necessary to clearly determine in advance how you want the vehicle with the implemented system to behave in various environments.</p> <p>Next, you must comply with the laws of the country where the autonomous driving vehicle will be operating. It is your responsibility to choose which of the following requirements to apply according to the laws.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/#caution","title":"Caution","text":"<ul> <li>The examples of the road signs and road surface markings are used in Japan. Please replace them with those used in your respective countries.</li> <li>The values for range and distance indicated are minimum values. Please determine values that comply with the laws of your country. Furthermore, these minimum values may change depending on the maximum velocity of the autonomous driving vehicle.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/#list-of-requirement-specifications","title":"List of Requirement Specifications","text":"Category ID Requirements Category Lane vm-01-01 Lanelet basics vm-01-02 Allowance for lane changes vm-01-03 Linestring sharing vm-01-04 Sharing of the centerline of lanes for opposing traffic vm-01-05 Lane geometry vm-01-06 Line position (1) vm-01-07 Line position (2) vm-01-08 Line position (3) vm-01-09 Speed limits vm-01-10 Centerline vm-01-11 Centerline connection (1) vm-01-12 Centerline connection (2) vm-01-13 Roads with no centerline (1) vm-01-14 Roads with no centerline (2) vm-01-15 Road shoulder vm-01-16 Road shoulder Linestring sharing vm-01-17 Side strip vm-01-18 Side strip Linestring sharing vm-01-19 Walkway Category Stop Line vm-02-01 Stop line alignment vm-02-02 Stop sign Category Intersection vm-03-01 Intersection criteria vm-03-02 Lanelet's turn direction and virtual vm-03-03 Lanelet width in the intersection vm-03-04 Lanelet creation in the intersection vm-03-05 Lanelet division in the intersection vm-03-06 Guide lines in the intersection vm-03-07 Multiple lanelets in the intersection vm-03-08 Intersection Area range vm-03-09 Range of Lanelet in the intersection vm-03-10 Right of way (with signal) vm-03-11 Right of way (without signal) vm-03-12 Right of way supplements vm-03-13 Merging from private area, sidewalk vm-03-14 Road marking vm-03-15 Exclusive bicycle lane Category Traffic Light vm-04-01 Traffic light basics vm-04-02 Traffic light position and size vm-04-03 Traffic light lamps Category Crosswalk vm-05-01 Crosswalks across the road vm-05-02 Crosswalks with pedestrian signals vm-05-03 Deceleration for safety at crosswalks vm-05-04 Fences Category Area vm-06-01 Buffer Zone vm-06-02 No parking signs vm-06-03 No stopping signs vm-06-04 No stopping sections vm-06-05 Detection area Category Others vm-07-01 Vector Map creation range vm-07-02 Range of detecting pedestrians who enter the road vm-07-03 Guardrails, guard pipes, fences vm-07-04 Ellipsoidal height"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/","title":"Category area","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#categoryarea","title":"Category:Area","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#vm-06-01-buffer-zone","title":"vm-06-01 Buffer Zone","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#detail-of-requirements","title":"Detail of requirements","text":"<p>Create a Polygon (type:hatched_road_markings) when a Buffer Zone (also known as a zebra zone) is painted on the road surface.</p> <ul> <li>If the Buffer Zone is next to a Lanelet, share Points between them.</li> <li>Overlap the Buffer Zone's Polygon with the intersection's Polygon (intersection_area) if the Buffer Zone is located at an intersection.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#behavior-of-autoware","title":"Behavior of Autoware\uff1a","text":"<p>In order to avoid obstacles, Autoware regards the Buffer Zone as a drivable area and proceeds through it.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#caution","title":"Caution","text":"<ul> <li>Vehicles are not allowed to pass through safety areas. It's important to differentiate between Buffer Zones and safety areas. - Do not create a Polygon for the Buffer Zone in areas where static objects like poles are present and vehicles cannot pass, even if a Buffer Zone is painted on the surface. Buffer Zones should be established only in areas where vehicle passage is feasible.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#preferred-vector-map","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#incorrect-vector-map","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#related-autoware-module","title":"Related Autoware module","text":"<ul> <li>Static Avoidance - Autoware Universe Documentation</li> <li>Dynamic Avoidance - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#vm-06-02-no-parking-signs","title":"vm-06-02 No parking signs","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#detail-of-requirements_1","title":"Detail of requirements","text":"<p>When creating a Vector Map, you can prohibit parking in specific areas, while temporary stops are permitted.</p> <p>Create a reference from a Lanelet (subtype:road) to a Regulatory Element (subtype:no_parking_area), and have this Regulatory Element refer to a Polygon (type:no_parking_area).</p> <p>Refer to Web.Auto Documentation - Creation of No Parking Area for the method of creation in Vector Map Builder.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#behavior-of-autoware_1","title":"Behavior of Autoware\uff1a","text":"<p>Since no_parking_area does not allow for setting a goal, Autoware cannot park the vehicle there.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#preferred-vector-map_1","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#incorrect-vector-map_1","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#related-autoware-module_1","title":"Related Autoware module","text":"<ul> <li>Goal Planner design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#vm-06-03-no-stopping-signs","title":"vm-06-03 No stopping signs","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#detail-of-requirements_2","title":"Detail of requirements","text":"<p>When creating a Vector Map, you can prohibit stopping in specific areas, while temporary stops are permitted.</p> <p>Create a reference from a Lanelet (subtype:road) to a Regulatory Element (subtype:no_parking_area), and have this Regulatory Element refer to a Polygon (type:no_parking_area).</p> <p>Refer to Web.Auto Documentation - Creation of No Parking Area for the method of creation in Vector Map Builder.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#behavior-of-autoware_2","title":"Behavior of Autoware\uff1a","text":"<p>Since no_parking_area does not allow for setting a goal, Autoware cannot park the vehicle there.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#preferred-vector-map_2","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#incorrect-vector-map_2","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#related-autoware-module_2","title":"Related Autoware module","text":"<ul> <li>Goal Planner design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#vm-06-04-no-stopping-sections","title":"vm-06-04 No stopping sections","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#detail-of-requirements_3","title":"Detail of requirements","text":"<p>While vehicles may stop on the road for signals or traffic congestion, you can prohibit any form of stopping (temporary stopping, parking, idling) in specific areas when creating a Vector Map.</p> <p>Create a reference from a Lanelet (subtype:road) to a Regulatory Element (subtype:no_stopping_area), and have this Regulatory Element refer to a Polygon (type:no_stopping_area).</p> <p>Refer to Web.Auto Documentation - Creation of No Stopping Area for the method of creation in Vector Map Builder.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#behavior-of-autoware_3","title":"Behavior of Autoware\uff1a","text":"<p>The vehicle does not make temporary stops in no_stopping_area. Since goals cannot be set in no_stopping_area, the vehicle cannot park there.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#preferred-vector-map_3","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#incorrect-vector-map_3","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#related-autoware-module_3","title":"Related Autoware module","text":"<ul> <li>No Stopping Area design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#vm-06-05-detection-area","title":"vm-06-05 Detection area","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#detail-of-requirements_4","title":"Detail of requirements","text":"<p>Autoware identifies obstacles by detecting point clouds in the Detection Area, leading to a stop at the stop line and maintaining that stop until the obstacles move away. To enable this response, incorporate the Detection Area element into the Vector Map.</p> <p>Create a reference from a Lanelet (subtype:road) to a Regulatory Element (subtype:detection_area), and have this Regulatory Element refer to a Polygon (type:detection_area) and a Linestring (type:stop_line).</p> <p>Refer to Web.Auto Documentation - Creation of Detection Area for the method of creation in Vector Map Builder.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#preferred-vector-map_4","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#incorrect-vector-map_4","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_area/#related-autoware-module_4","title":"Related Autoware module","text":"<ul> <li>Detection Area - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/","title":"Category crosswalk","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#categorycrosswalk","title":"Category:Crosswalk","text":"<p>There are two types of requirements for crosswalks, and they can both be applicable to a single crosswalk.</p> <ul> <li>vm-05-01 : Crosswalks across the road</li> <li>vm-05-02 : Crosswalks with pedestrian signals</li> </ul> <p>In the case of crosswalks at intersections, they must also meet the requirements of the intersection.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#vm-05-01-crosswalks-across-the-road","title":"vm-05-01 Crosswalks across the road","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#detail-of-requirements","title":"Detail of requirements","text":"<p>Necessary requirements for creation:</p> <ol> <li>Create a Lanelet for the crosswalk (subtype:crosswalk).</li> <li>If there is a stop line before the crosswalk, create a Linestring (type:stop_line). Create stop lines for the opposing traffic lane in the same way.</li> <li>Create a Polygon (type:crosswalk_polygon) to cover the crosswalk.</li> <li>The Lanelet of the road refers to the regulatory element (subtype:crosswalk), and the regulatory element refers to the created Lanelet, Linestring, and Polygon.</li> </ol>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#supplemental-information","title":"Supplemental information","text":"<ul> <li>Link the regulatory element to the lanelet(s) of the road that intersects with the crosswalk.</li> <li>The stop lines linked to the regulatory element do not necessarily have to exist on the road Lanelets linked with the regulatory element.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#behavior-of-autoware","title":"Behavior of Autoware\uff1a","text":"<p>When pedestrians or cyclists are on the crosswalk, Autoware will come to a stop before the stop line and wait for them to pass. Once they have cleared the area, Autoware will begin to move forward.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#preferred-vector-map","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#incorrect-vector-map","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#related-autoware-module","title":"Related Autoware module","text":"<ul> <li>Crosswalk - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#vm-05-02-crosswalks-with-pedestrian-signals","title":"vm-05-02 Crosswalks with pedestrian signals","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#detail-of-requirements_1","title":"Detail of requirements","text":"<p>Necessary requirements for creation:</p> <ul> <li>Create a Lanelet (subtype:crosswalk, participant:pedestrian).</li> <li>Create a Traffic Light Linestring. If multiple traffic lights exist, create multiple Linestrings.<ul> <li>Linestring<ul> <li>type:traffic_light</li> <li>subtype:red_green</li> <li>height:value</li> </ul> </li> </ul> </li> <li>Ensure the crosswalk's Lanelet references a Regulatory Element (subtype:traffic_light). Also, ensure the Regulatory Element references Linestring (type:traffic_light).</li> </ul> <p>Refer to vm-04-02 for more about traffic light object.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#preferred-vector-map_1","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#incorrect-vector-map_1","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#related-autoware-module_1","title":"Related Autoware module","text":"<ul> <li>Crosswalk - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#vm-05-03-deceleration-for-safety-at-crosswalks","title":"vm-05-03 Deceleration for safety at crosswalks","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#detail-of-requirements_2","title":"Detail of requirements","text":"<p>To ensure a constant deceleration to a safe speed when traversing a crosswalk, add the following tags to the crosswalk's Lanelet (subtype:crosswalk):</p> <ul> <li>safety_slow_down_speed [m/s]: The maximum velocity while crossing.</li> <li>safety_slow_down_distance [m]: The starting point of the area where the maximum speed applies, measured from the vehicle's front bumper to the crosswalk.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#preferred-vector-map_2","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#incorrect-vector-map_2","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#related-autoware-module_2","title":"Related Autoware module","text":"<ul> <li>Crosswalk - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#vm-05-04-fences","title":"vm-05-04 Fences","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#detail-of-requirements_3","title":"Detail of requirements","text":"<p>Autoware detects pedestrians and bicycles crossing the crosswalk, as well as those that might cross. However, areas near the crosswalk, such as fenced kindergartens, playgrounds, or parks, where many people are moving, can affect crosswalk detection due to predicted paths of people and bicycles from these areas.</p> <p>Surround areas not connected to the crosswalk with Linestring (type:fence), which does not need to be linked to anything.</p> <p>However, if there is a guardrail, wall, or fence between the road and sidewalk, with another fence behind it, the second fence may be omitted. Nevertheless, areas around crosswalks are not subject to this omission and must be created without exclusion.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#preferred-vector-map_3","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#incorrect-vector-map_3","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_crosswalk/#related-autoware-module_3","title":"Related Autoware module","text":"<ul> <li>map_based_prediction - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/","title":"Category intersection","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#categoryintersection","title":"Category:Intersection","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-01-intersection-criteria","title":"vm-03-01 Intersection criteria","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements","title":"Detail of requirements","text":"<p>Essential criteria for the construction of an intersection:</p> <ul> <li>Encircle the drivable area at the intersection with a Polygon (type:intersection_area).</li> <li>Add turn_direction to all Lanelets in the intersection.</li> <li>Ensure that all lanelets in the intersection are tagged:<ul> <li>key:intersection_area</li> <li>value: Polygon's ID</li> </ul> </li> <li>Attach right_of_way to the necessary Lanelets.</li> <li>Also, it is necessary to appropriately create traffic lights, crosswalks, and stop lines.</li> </ul> <p>For detailed information, refer to the respective requirements on this page.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#autoware-modules","title":"Autoware modules","text":"<ul> <li>The requirements for turn_direction and right_of_way are related to the intersection module, which plans velocity to avoid collisions with other vehicles, taking traffic light instructions into account.</li> <li>The requirements for intersection_area are related to the avoidance module, which plans routes that evade by veering out of lanes in the intersections.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map","title":"Preferred vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> <li>Blind Spot design - Autoware Universe Documentation</li> <li>Static Avoidance - Autoware Universe Documentation</li> <li>Dynamic Avoidance - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-02-lanelets-turn-direction-and-virtual-linestring","title":"vm-03-02 Lanelet's turn direction and virtual linestring","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_1","title":"Detail of requirements","text":"<p>Add the following tag to the Lanelets in the intersection:</p> <ul> <li>turn_direction : straight</li> <li>turn_direction : left</li> <li>turn_direction : right</li> </ul> <p>Also, if the left or right Linestrings of Lanelets at the intersection lack road paintings, designate these as type:virtual.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#behavior-of-autoware","title":"Behavior of Autoware\uff1a","text":"<p>Autoware will start flashing the turn signals (blinkers) 30 meters as default before turn_direction-tagged Lanelet. If you change the blinking timing, add the following tags:</p> <ul> <li>key: turn_signal_distance</li> <li>value: numerical value (m)</li> </ul> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_1","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_1","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_1","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> <li>Blind Spot design - Autoware Universe Documentation</li> <li>virtual_traffic_light in behavior_velocity_planner - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-03-lanelet-width-in-the-intersection","title":"vm-03-03 Lanelet width in the intersection","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_2","title":"Detail of requirements\uff1a","text":"<p>Lanelets in the intersection should have a consistent width. Additionally, draw Linestrings with smooth curves.</p> <p>The shape of this curve must be determined by the Vector Map creator.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_2","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_2","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-04-lanelet-creation-in-the-intersection","title":"vm-03-04 Lanelet creation in the intersection","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_3","title":"Detail of requirements","text":"<p>Create all Lanelets in the intersection, including lanelets not driven by the vehicle. Additionally, link stop lines and traffic lights to the Lanelets appropriately.</p> <p>Refer also to the creation scope vm-07-01</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#behavior-of-autoware_1","title":"Behavior of Autoware","text":"<p>Autoware uses lanelets to predict the movements of other vehicles and plan the vehicle's velocity accordingly. Therefore, it is necessary to create all lanelets in the intersection.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_3","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_3","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_2","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-05-lanelet-division-in-the-intersection","title":"vm-03-05 Lanelet division in the intersection","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_4","title":"Detail of requirements","text":"<p>Create the Lanelets in the intersection as a single object without dividing them.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_4","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_4","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_3","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-06-guide-lines-in-the-intersection","title":"vm-03-06 Guide lines in the intersection","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_5","title":"Detail of requirements","text":"<p>If there are guide lines in the intersection, draw the Lanelet following them.</p> <p>In cases where the Lanelets branches off, begin the branching at the end of the guide line. However, it is not necessary to share points or linestrings between Lanelets.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_5","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_5","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_4","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-07-multiple-lanelets-in-the-intersection","title":"vm-03-07 Multiple lanelets in the intersection","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_6","title":"Detail of requirements","text":"<p>When connecting multiple lanes with Lanelets at an intersection, those Lanelets should be made adjacent to each other without crossing.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_6","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_6","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_5","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-08-intersection-area-range","title":"vm-03-08 Intersection area range","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_7","title":"Detail of requirements","text":"<p>Encircle the intersection's drivable area with a Polygon (type:intersection_area). The boundary of this intersection's Polygon should be defined by the objects below.</p> <ul> <li>Linestrings (subtype:road_border)</li> <li>Straight lines at the connection points of lanelets in the intersection.\"</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_7","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_7","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_6","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> <li>Blind Spot design - Autoware Universe Documentation</li> <li>Static Avoidance - Autoware Universe Documentation</li> <li>Dynamic Avoidance - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-09-range-of-lanelet-in-the-intersection","title":"vm-03-09 Range of Lanelet in the intersection","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_8","title":"Detail of requirements","text":"<p>Determine the start and end positions of lanelets in the intersection (henceforth the boundaries of lanelet connections) based on the stop line's position.</p> <ul> <li>For cases with a painted stop line:<ul> <li>The stop line's linestring (type:stop_line) position must align with the lanelet's start.</li> <li>Extend the lanelet's end to where the opposing lane's stop line would be.</li> </ul> </li> <li>Without a painted stop line:<ul> <li>Use a drawn linestring (type:stop_line) to establish positions as if there were a painted stop line.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_8","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_8","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_7","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-10-right-of-way-with-signal","title":"vm-03-10 Right of way (with signal)","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_9","title":"Detail of requirements","text":"<p>Set the regulatory element 'right_of_way' for Lanelets that meet all of the following criteria:</p> <ul> <li>Lanelets in the intersection with a turn_direction of right or left.</li> <li>Lanelets that intersect with the vehicle's lanelet.</li> <li>There are traffic lights at the intersection.</li> </ul> <p>Set to yield those lanelets in the intersection that intersect the vehicle's lanelet, and set to yield those lanelets that do not share the same signal change timing with the vehicle. Also, if the vehicle is turning left, set the opposing vehicle's right-turn lane to yield. There is no need to set yield for lanelets where the vehicle goes straight (turn_direction:straight).</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_9","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#the-vehicle-turns-left","title":"The vehicle turns left","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#the-vehicle-turns-right","title":"The vehicle turns right","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_9","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_8","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-11-right-of-way-without-signal","title":"vm-03-11 Right of way (without signal)","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_10","title":"Detail of requirements","text":"<p>Set the regulatory element 'right_of_way' for Lanelets that meet all of the following criteria:</p> <ul> <li>Lanelets in the intersection with a turn_direction of right or left.</li> <li>Lanelets that intersect with the vehicle's lanelet.</li> <li>There are no traffic lights at the intersection.</li> </ul> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_10","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#1-the-vehicle-on-the-priority-lane","title":"\u2460 The vehicle on the priority lane","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#2-the-vehicle-on-the-non-priority-lane","title":"\u2461 The vehicle on the non-priority lane","text":"<p>A regulatory element is not necessary. However, when the vehicle goes straight, it has relative priority over other vehicles turning right from the opposing non-priority road. Therefore, settings for right_of_way and yield are required in this case.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_10","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_9","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-12-right-of-way-supplements","title":"vm-03-12 Right of way supplements","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_11","title":"Detail of requirements","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#why-its-necessary-to-configure-right_of_way","title":"Why it's necessary to configure 'right_of_way'","text":"<p>Without the 'right_of_way' setting, Autoware interprets other lanes intersecting its path as having priority. Therefore, as long as there are other vehicles in the crossing lane, Autoware cannot enter the intersection regardless of signal indications.</p> <p>An example of a problem: Even when our signal allows proceeding, our vehicle waits beforehand if other vehicles are waiting at a red light where the opposing lane intersects with a right-turn lane.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_11","title":"Preferred vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_11","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_10","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-13-merging-from-private-area-sidewalk","title":"vm-03-13 Merging from private area, sidewalk","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_12","title":"Detail of requirements","text":"<p>Set location=private for Lanelets within private property.</p> <p>When a road, which enters or exits private property, intersects with a sidewalk, create a Lanelet for that sidewalk (subtype:walkway).</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#behavior-of-autoware_2","title":"Behavior of Autoware\uff1a","text":"<ul> <li>The vehicle stops temporarily before entering the sidewalk.</li> <li>The vehicle comes to a stop before merging onto the public road.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_12","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_12","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_11","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-14-road-marking","title":"vm-03-14 Road marking","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_13","title":"Detail of requirements","text":"<p>If there is a stop line ahead of the guide lines in the intersection, ensure the following:</p> <ul> <li>Create a Lanelet for the guide lines.</li> <li>The Lanelet for the guide lines references a Regulatory Element (subtype:road_marking).</li> <li>The Regulatory Element refers to the stop_line's Linestring.\"</li> </ul> <p>Refer to Web.Auto Documentation - Creation of Regulatory Element for the method of creation in Vector Map Builder.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_13","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_13","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_12","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#vm-03-15-exclusive-bicycle-lane","title":"vm-03-15 Exclusive bicycle lane","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#detail-of-requirements_14","title":"Detail of requirements","text":"<p>If an exclusive bicycle lane exists, create a Lanelet (subtype:road). The section adjoining the road should share a Linestring. For bicycle lanes at intersections, assign a yieldlane designation beneath the _right_of_way for lanes that intersect with the vehicle's left-turn lane. (Refer to vm-03-10 and vm-03-11 for right_of_way).</p> <p>In addition, set lane_change = no as OptionalTags.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#behavior-of-autoware_3","title":"Behavior of Autoware\uff1a","text":"<p>The blind spot (entanglement check) feature verifies the lanelet(subtype:road) and decides if the vehicle can proceed.</p> <p></p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#preferred-vector-map_14","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#incorrect-vector-map_14","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_intersection/#related-autoware-module_13","title":"Related Autoware module","text":"<ul> <li>Blind Spot design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/","title":"Category lane","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#categorylane","title":"Category:Lane","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-01-lanelet-basics","title":"vm-01-01 Lanelet basics","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements","title":"Detail of requirements","text":"<p>The road's Lanelets must comply with the following requirements.</p> <ul> <li>subtype:road</li> <li>location:urban, for public roads</li> <li>Align the Lanelet's direction with the direction of vehicle move. (You can visualize lanelet direction as arrows with Vector Map Builder)</li> <li>Set lane change is allowed or not, according to vm-01-02.</li> <li>Set the Linestring IDs for Lanelet's left_bound and right_bound respectively. See vm-01-03.</li> <li>tag : one_way=yes. Autoware currently does not support no.</li> <li>Connect the Lanelet to another Lanelet, except if it's at the start or end.</li> <li>Position the points (x, y, z) within the Lanelet to align with the PCD Map, ensuring accuracy not only laterally but also in elevation. The height of a Point should be based on the ellipsoidal height (WGS84). Refer to vm-07-04.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-02-allowance-for-lane-changes","title":"vm-01-02 Allowance for lane changes","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_1","title":"Detail of requirements","text":"<p>Add a tag to the Lanelet's Linestring indicating lane change permission or prohibition.</p> <ul> <li>Permit lane_change=yes</li> <li>Prohibit lane_change=no</li> </ul> <p>Set the Linestring subtype according to the type of line.</p> <ul> <li>solid</li> <li>dashed</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#referenced-from-japans-road-traffic-law","title":"Referenced from Japan's Road Traffic Law","text":"<ul> <li>White dashed lines : indicate that lane changes and overtaking are permitted.</li> <li>White solid lines : indicate that changing lanes and overtaking are allowed.</li> <li>Yellow solid lines : mean no lane changes are allowed.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#related-autoware-module","title":"Related Autoware module","text":"<ul> <li>Lane Change design - Autoware Universe Documentation</li> <li>Static Avoidance - Autoware Universe Documentation</li> <li>Dynamic Avoidance - Autoware Universe Documentation</li> <li>Out of lane design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-03-linestring-sharing","title":"vm-01-03 Linestring sharing","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_2","title":"Detail of requirements","text":"<p>Share the Linestring when creating Lanelets that are physically adjacent to others.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#behavior-of-autoware","title":"Behavior of Autoware","text":"<p>If the Lanelet adjacent to the one the vehicle is driving on shares a Linestring, the following behaviors become possible:</p> <ul> <li>The vehicle moves out of their lanes to avoid obstacles.</li> <li>The vehicle turns a curve while slightly extending out of the lane.</li> <li>Lane changes</li> </ul> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_1","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#related-autoware-module_1","title":"Related Autoware module","text":"<ul> <li>Lane Change design - Autoware Universe Documentation</li> <li>Static Avoidance - Autoware Universe Documentation</li> <li>Dynamic Avoidance - Autoware Universe Documentation</li> <li>Out of lane design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-04-sharing-of-the-centerline-of-lanes-for-opposing-traffic","title":"vm-01-04 Sharing of the centerline of lanes for opposing traffic","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_3","title":"Detail of requirements","text":"<p>When the vehicle's lanelet and the opposing lanelet physically touch, the road center line's Linestring ID must be shared between these two Lanelets. For that purpose, the lengths of those two Lanelets must match.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#behavior-of-autoware_1","title":"Behavior of Autoware\uff1a","text":"<p>Obstacle avoidance across the opposing lane is possible.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_2","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_1","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-05-lane-geometry","title":"vm-01-05 Lane geometry","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_4","title":"Detail of requirements","text":"<p>The geometry of the road lanelet needs to comply with the following:</p> <ul> <li>The left and right Linestrings must follow the road's boundary lines.</li> <li>The lines of a Lanelet, which join with lanelets ahead and behind it, must form straight lines.</li> <li>Ensure the outline is smooth and not jagged or bumpy, except for L-shaped cranks.</li> </ul> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_3","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_2","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-06-line-position-1","title":"vm-01-06 Line position (1)","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_5","title":"Detail of requirements","text":"<p>Ensure the road's center line Linestring is located in the exact middle of the road markings.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_4","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_3","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-07-line-position-2","title":"vm-01-07 Line position (2)","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_6","title":"Detail of requirements","text":"<p>Place the Linestring at the center of the markings when lines exist outside the road.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_5","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_4","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-08-line-position-3","title":"vm-01-08 Line position (3)","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_7","title":"Detail of requirements","text":"<p>If there are no lines on the outer side within the road, position the Linestring 0.5 m from the road's edge.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#caution","title":"Caution","text":"<p>The width depends on the laws of your country.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_6","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_5","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-09-speed-limits","title":"vm-01-09 Speed limits","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_8","title":"Detail of requirements","text":"<p>In the following cases, add a speed limit (tag:speed_limit) to the Lanelet (subtype:road) the vehicle is driving on, in km/h.</p> <ul> <li>A speed limit road sign exists.</li> <li>You can add a speed limit, for example, on narrow roads.</li> </ul> <p>Note that the following is achieved through Autoware's settings and behavior.</p> <ul> <li>Vehicle's maximum velocity</li> <li>Speed adjustment at places requiring deceleration, like curves and downhill areas.</li> </ul> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_7","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_6","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-10-centerline","title":"vm-01-10 Centerline","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_9","title":"Detail of requirements","text":"<p>Autoware is designed to move through the midpoint calculated from a Lanelet's left and right Linestrings.</p> <p>Create a centerline for the Lanelet when there is a need to shift the driving position to the left or right due to certain circumstances, ensuring the centerline has a smooth shape for drivability.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#caution_1","title":"Caution","text":"<p>'Centerline' is a distinct concept from the central lane division line (centerline).</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_8","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_7","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-11-centerline-connection-1","title":"vm-01-11 Centerline connection (1)","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_10","title":"Detail of requirements","text":"<p>When center lines have been added to several Lanelets, they should be connected.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_9","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_8","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-12-centerline-connection-2","title":"vm-01-12 Centerline connection (2)","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_11","title":"Detail of requirements","text":"<p>If a Lanelet with an added centerline is connected to Lanelets without one, ensure the start and end points of the added centerline are positioned at the Lanelet's center. Ensure the centerline has a smooth shape for drivability.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_10","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_9","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-13-roads-with-no-centerline-1","title":"vm-01-13 Roads with no centerline (1)","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_12","title":"Detail of requirements","text":"<p>When a road lacks a central line but is wide enough for one's vehicle and oncoming vehicles to pass each other, Lanelets should be positioned next to each other at the center of the road.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_11","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_10","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-14-roads-with-no-centerline-2","title":"vm-01-14 Roads with no centerline (2)","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_13","title":"Detail of requirements","text":"<p>Apply if all the next conditions are satisfied:</p> <ul> <li>The road is a single lane without a central line and is too narrow for one's vehicle and an oncoming vehicle to pass each other.</li> <li>It is an environment where no vehicles other than the autonomous vehicle enter this road.</li> <li>The plan involves autonomous vehicles operating forth and back on this road.</li> </ul> <p>Requirement for Vector Map creation:</p> <ul> <li>Stack two Lanelets together.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#supplementary-information","title":"Supplementary information","text":"<ul> <li>The application of this case depends on local operational policies and vehicle specifications, and should be determined in discussion with the map requestor.</li> <li>The current Autoware does not possess the capability to pass oncoming vehicles in shared lanes.</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_12","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_11","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-15-road-shoulder","title":"vm-01-15 Road Shoulder","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_14","title":"Detail of requirements","text":"<p>If there is a shoulder next to the road, place the lanelet for the road shoulder (subtype:road_shoulder). However, it is not necessary to create this within intersections.</p> <p>The road shoulder's Lanelet and sidewalk's Lanelet share the Linestring (subtype:road_border).</p> <p>There must not be a road shoulder Lanelet next to another road shoulder Lanelet.</p> <p>A road Lanelet must be next to the shoulder Lanelet.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#behavior-of-autoware_2","title":"Behavior of Autoware","text":"<ul> <li>Autoware can start from the shoulder and also reach the shoulder.</li> <li>The margin for moving to the edge upon arrival is determined by the Autoware parameter margin_from_boundary. It does not need to be considered when creating the Vector Map.</li> <li>Autoware does not park on the road shoulder lanelet if it overlaps with any of the following:<ul> <li>A Polygon marked as no_parking_area</li> <li>A Polygon marked as no_stopping_area</li> <li>Areas near intersection and in the intersection</li> <li>Crosswalk</li> </ul> </li> </ul> <p>tag:lane_change=yes is not required on the Linestring marking the boundary of the shoulder.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_13","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_12","title":"Incorrect vector map","text":"<p>Do not create a road shoulder Lanelet for roads without a shoulder.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#related-autoware-module_2","title":"Related Autoware module","text":"<ul> <li>Static Avoidance - Autoware Universe Documentation</li> <li>Dynamic Avoidance - Autoware Universe Documentation</li> <li>Goal Planner design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-16-road-shoulder-linestring-sharing","title":"vm-01-16 Road shoulder Linestring sharing","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_15","title":"Detail of requirements","text":"<p>The Lanelets for the road shoulder and the adjacent road should have a common Linestring.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_14","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_13","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#related-autoware-module_3","title":"Related Autoware module","text":"<ul> <li>Static Avoidance - Autoware Universe Documentation</li> <li>Dynamic Avoidance - Autoware Universe Documentation</li> <li>Goal Planner design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-17-side-strip","title":"vm-01-17 Side strip","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_16","title":"Detail of requirements","text":"<p>Place a Lanelet (subtype:pedestrian_lane) on the side strip. However, it is not necessary to create this within intersections.</p> <p>The side strip's Lanelet must have the Linestring (subtype:road_border) outside.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_15","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_14","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-18-side-strip-linestring-sharing","title":"vm-01-18 Side strip Linestring sharing","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_17","title":"Detail of requirements","text":"<p>The Lanelet for the side strip and the adjacent road Lanelet should have a common Linestring.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_16","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_15","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#vm-01-19-sidewalk","title":"vm-01-19 sidewalk","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#detail-of-requirements_18","title":"Detail of requirements","text":"<p>Place a sidewalk Lanelet (subtype:walkway) where necessary. However, install only when there is a crosswalk intersecting the vehicle's lane. Do not install if there is no intersection.</p> <p>The length of the lanelet (subtype:walkway) should be the area intersecting with your lane and additional 3 meters before and after.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#preferred-vector-map_17","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#incorrect-vector-map_16","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_lane/#related-autoware-module_4","title":"Related Autoware module","text":"<ul> <li>Intersection - Autoware Universe Documentation</li> <li>Walkway design- Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/","title":"Category others","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#categoryothers","title":"Category:Others","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#vm-07-01-vector-map-creation-range","title":"vm-07-01 Vector Map creation range","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#detail-of-requirements","title":"Detail of requirements","text":"<p>Create all Lanelets within the sensor range of the vehicle, even those on roads not driven by the vehicle, including Lanelets that intersect with the vehicle's Lanelet.</p> <p>However, if the following conditions are met, the range you must create lanelets is 10 meters at least.</p> <ul> <li>The vehicle drives on the priority lane through the intersection without traffic lights.</li> <li>The vehicle drives straight or turn left through the intersection with traffic lights</li> </ul> <p>Refer to vm-03-04 for more about intersection requirements.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#behavior-of-autoware","title":"Behavior of Autoware\uff1a","text":"<p>Autoware detects approaching vehicles and plans a route to avoid collisions.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#caution","title":"Caution","text":"<p>Check the range of sensors on your vehicle.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#preferred-vector-map","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#incorrect-vector-map","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#vm-07-02-range-of-detecting-pedestrians-who-enter-the-road","title":"vm-07-02 Range of detecting pedestrians who enter the road","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#detail-of-requirements_1","title":"Detail of requirements","text":"<p>Autoware's feature for detecting sudden entries from the roadside tracks pedestrians and cyclists beyond the road boundaries, decelerating to prevent collisions when emergence into the road is likely.</p> <p>Setting up a linestring of the following type instructs Autoware to disregard those positioned outside the line as not posing pop-out risks.</p> <ul> <li>guard_rail</li> <li>wall</li> <li>fence</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#preferred-vector-map_1","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#incorrect-vector-map_1","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#related-autoware-module","title":"Related Autoware module","text":"<ul> <li>map_based_prediction - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#vm-07-03-guardrails-guard-pipes-fences","title":"vm-07-03 Guardrails, guard pipes, fences","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#detail-of-requirements_2","title":"Detail of requirements","text":"<p>When creating a Linestring for guardrails or guard pipes (type: guard_rail), position it at the point where the most protruding part on the roadway side is projected vertically onto the ground.</p> <p>Follow the same position guidelines for Linestrings of fences (type:fence).</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#preferred-vector-map_2","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#incorrect-vector-map_2","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#related-autoware-module_1","title":"Related Autoware module","text":"<ul> <li>Drivable Area design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#vm-07-04-ellipsoidal-height","title":"vm-07-04 Ellipsoidal height","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#detail-of-requirements_3","title":"Detail of requirements","text":"<p>The height of a Point should be based on the ellipsoidal height (WGS84), in meters.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#preferred-vector-map_3","title":"Preferred vector map","text":"<p>The height of a Point is the distance from the ellipsoidal surface to the ground.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_others/#incorrect-vector-map_3","title":"Incorrect vector map","text":"<p>The height of a Point is Orthometric height, the distance from the Geoid to the ground.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/","title":"Category stop line","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#categorystop-line","title":"Category:Stop Line","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#vm-02-01-stop-line-alignment","title":"vm-02-01 Stop line alignment","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#detail-of-requirements","title":"Detail of requirements","text":"<p>Place the Linestring (type:stop_line) for the stop line on the edge on the side before the white line.</p> <p>Refer to Web.Auto Documentation - Creation and edit of a stop point (StopPoint) for the method of creation in Vector Map Builder.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#preferred-vector-map","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#incorrect-vector-map","title":"Incorrect vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#vm-02-02-stop-sign","title":"vm-02-02 Stop sign","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#detail-of-requirements_1","title":"Detail of requirements","text":"<p>Where there is no stop line on the road but a stop sign exists, place a Linestring as the stop line next to the sign.</p> <p>Create a reference from a Lanelet (subtype:road) to a Regulatory Element (subtype:traffic_sign), and have this Regulatory Element refer to a Linestring (type:stop_line) and a Linestring (type:traffic_sign, subtype:stop_sign).</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#preferred-vector-map_1","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#incorrect-vector-map_1","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_stop_line/#related-autoware-module","title":"Related Autoware module","text":"<ul> <li>Stop Line design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/","title":"Category traffic light","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#categorytraffic-light","title":"Category:Traffic Light","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#vm-04-01-traffic-light-basics","title":"vm-04-01 Traffic light basics","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#detail-of-requirements","title":"Detail of requirements","text":"<p>When creating traffic lights in a vector map, meet the following requirements:</p> <ul> <li>Road Lanelet (subtype:road). Quantity: one.</li> <li>Traffic Light. Multiple instances possible.<ul> <li>Traffic light Linestring (type:traffic_light).</li> <li>Traffic light bulbs Linestring (type:light_bulbs).</li> <li>Stop line Linestring (type:stop_line).</li> </ul> </li> <li>Regulatory element for traffic lights (subtype:traffic_light). Referenced by the road Lanelet and references both the traffic light (traffic_light, light_bulbs) and stop line (stop_line). Quantity: one.</li> </ul> <p>Refer to Web.Auto Documentation - Creation of a traffic light and a stop line for the method of creation in Vector Map Builder.</p> <p>Refer to vm-04-02 and vm-04-03 for the specifications of traffic light and traffic light bulb objects.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#preferred-vector-map","title":"Preferred vector map","text":"<p>If there is a crosswalk at the intersection, arrange for the road's Lanelet and the crosswalk's Lanelet to intersect and overlap.</p> <p></p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#related-autoware-module","title":"Related Autoware module","text":"<ul> <li>Traffic Light design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#vm-04-02-traffic-light-position-and-size","title":"vm-04-02 Traffic light position and size","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#detail-of-requirements_1","title":"Detail of requirements","text":"<p>Create traffic lights with Linestring.</p> <ul> <li>type:traffic_light</li> <li>subtype:red_yellow_green (optional)</li> </ul> <p>Create the Linestring's length (from start to end points) precisely aligned with the traffic light's bottom edge. Ensure the traffic light's positional height is correctly represented in the Linestring's 3D coordinates.</p> <p>Use tag:height for the traffic light's height, e.g., for 50cm, write tag:height=0.5. Note that this height indicates the size of the traffic light, not its position.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#supplemental-information","title":"Supplemental information","text":"<p>Autoware currently ignores subtype red_yellow_green.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#preferred-vector-map_1","title":"Preferred vector map","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#incorrect-vector-map","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#related-autoware-module_1","title":"Related Autoware module","text":"<ul> <li>Traffic Light design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#vm-04-03-traffic-light-lamps","title":"vm-04-03 Traffic light lamps","text":""},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#detail-of-requirements_2","title":"Detail of requirements","text":"<p>To enable the system to detect the color of traffic lights, the color scheme and arrangement must be accurately created as objects. Indicate the position of the lights with Points. For colored lights, use the color tag to represent the color. For arrow lights, use the arrow tag to indicate the direction.</p> <ul> <li>tag: color = red, yellow, green</li> <li>tag: arrow = up, right, left, up_light, up_left</li> </ul> <p>Use the Points of the lights when creating a Linestring.</p> <ul> <li>type: light_bulbs</li> </ul>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#preferred-vector-map_2","title":"Preferred vector map","text":"<p>The order of the lights' Points can be 1\u21922\u21923\u21924 or 4\u21923\u21922\u21921, either is acceptable.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#incorrect-vector-map_1","title":"Incorrect vector map","text":"<p>None in particular.</p>"},{"location":"design/autoware-architecture/map/map-requirements/vector-map-requirements-overview/category_traffic_light/#related-autoware-module_2","title":"Related Autoware module","text":"<ul> <li>Traffic Light design - Autoware Universe Documentation</li> </ul>"},{"location":"design/autoware-architecture/node-diagram/","title":"Node diagram","text":""},{"location":"design/autoware-architecture/node-diagram/#node-diagram","title":"Node diagram","text":"<p>This page depicts the node diagram designs for Autoware Core/Universe architecture.</p>"},{"location":"design/autoware-architecture/node-diagram/#autoware-core","title":"Autoware Core","text":"<p>TBD.</p>"},{"location":"design/autoware-architecture/node-diagram/#autoware-universe","title":"Autoware Universe","text":"<p>Open in draw.io for fullscreen</p> <p>Note that the diagram is for reference. We are planning to update this diagram every release and may have old information between the releases. If you wish to check the latest node diagram use rqt_graph after launching the Autoware.</p>"},{"location":"design/autoware-architecture/perception/","title":"Perception Component Design","text":""},{"location":"design/autoware-architecture/perception/#perception-component-design","title":"Perception Component Design","text":""},{"location":"design/autoware-architecture/perception/#purpose-of-this-document","title":"Purpose of this document","text":"<p>This document outlines the high-level design strategies, goals and related rationales in the development of the Perception Component. Through this document, it is expected that all OSS developers will comprehend the design philosophy, goals and constraints under which the Perception Component is designed, and participate seamlessly in the development.</p>"},{"location":"design/autoware-architecture/perception/#overview","title":"Overview","text":"<p>The Perception Component receives inputs from Sensing, Localization, and Map components, and adds semantic information (e.g., Object Recognition, Obstacle Segmentation, Traffic Light Recognition, Occupancy Grid Map), which is then passed on to Planning Component. This component design follows the overarching philosophy of Autoware, defined as the microautonomy concept.</p>"},{"location":"design/autoware-architecture/perception/#goals-and-non-goals","title":"Goals and non-goals","text":"<p>The role of the Perception Component is to recognize the surrounding environment based on the data obtained through Sensing and acquire sufficient information (such as the presence of dynamic objects, stationary obstacles, blind spots, and traffic signal information) to enable autonomous driving.</p> <p>In our overall design, we emphasize the concept of microautonomy architecture. This term refers to a design approach that focuses on the proper modularization of functions, clear definition of interfaces between these modules, and as a result, high expandability of the system. Given this context, the goal of the Perception Component is set not to solve every conceivable complex use case (although we do aim to support basic ones), but rather to provide a platform that can be customized to the user's needs and can facilitate the development of additional features.</p> <p>To clarify the design concepts, the following points are listed as goals and non-goals.</p> <p>Goals:</p> <ul> <li>To provide the basic functions so that a simple ODD can be defined.</li> <li>To achieve a design that can provide perception functionality to every autonomous vehicle.</li> <li>To be extensible with the third-party components.</li> <li>To provide a platform that enables Autoware users to develop the complete functionality and capability.</li> <li>To provide a platform that enables Autoware users to develop the autonomous driving system which always outperforms human drivers.</li> <li>To provide a platform that enables Autoware users to develop the autonomous driving system achieving \"100% accuracy\" or \"error-free recognition\".</li> </ul> <p>Non-goals:</p> <ul> <li>To develop the perception component architecture specialized for specific / limited ODDs.</li> <li>To achieve the complete functionality and capability.</li> <li>To outperform the recognition capability of human drivers.</li> <li>To achieve \"100% accuracy\" or \"error-free recognition\".</li> </ul>"},{"location":"design/autoware-architecture/perception/#high-level-architecture","title":"High-level architecture","text":"<p>This diagram describes the high-level architecture of the Perception Component.</p> <p></p> <p>The Perception Component consists of the following sub-components:</p> <ul> <li>Object Recognition: Recognizes dynamic objects surrounding the ego vehicle in the current frame, objects that were not present during map creation, and predicts their future trajectories. This includes:<ul> <li>Pedestrians</li> <li>Cars</li> <li>Trucks/Buses</li> <li>Bicycles</li> <li>Motorcycles</li> <li>Animals</li> <li>Traffic cones</li> <li>Road debris: Items such as cardboard, oil drums, trash cans, wood, etc., either dropped on the road or floating in the air</li> </ul> </li> <li>Obstacle Segmentation: Identifies point clouds originating from obstacles, including both dynamic objects and static obstacles that requires the ego vehicle either steer clear of them or come to a stop in front of the obstacles.<ul> <li>This includes:<ul> <li>All dynamic objects (as listed above)</li> <li>Curbs/Bollards</li> <li>Barriers</li> <li>Trees</li> <li>Walls/Buildings</li> </ul> </li> <li>This does not include:<ul> <li>Grass</li> <li>Water splashes</li> <li>Smoke/Vapor</li> <li>Newspapers</li> <li>Plastic bags</li> </ul> </li> </ul> </li> <li>Occupancy Grid Map: Detects blind spots (areas where no information is available and where dynamic objects may jump out).</li> <li>Traffic Light Recognition: Recognizes the colors of traffic lights and the directions of arrow signals.</li> </ul>"},{"location":"design/autoware-architecture/perception/#component-interface","title":"Component interface","text":"<p>The following describes the input/output concept between Perception Component and other components. See the Perception Component Interface page for the current implementation.</p>"},{"location":"design/autoware-architecture/perception/#input-to-the-perception-component","title":"Input to the Perception Component","text":"<ul> <li>From Sensing: This input should provide real-time information about the environment.<ul> <li>Camera Image: Image data obtained from the camera.</li> <li>Point Cloud: Point Cloud data obtained from LiDAR.</li> <li>Radar Object: Object data obtained from radar.</li> </ul> </li> <li>From Localization: This input should provide real-time information about the ego vehicle.<ul> <li>Vehicle motion information: Includes the ego vehicle's position.</li> </ul> </li> <li>From Map: This input should provide real-time information about the static information about the environment.<ul> <li>Vector Map: Contains all static information about the environment, including lane area information.</li> <li>Point Cloud Map: Contains static point cloud maps, which should not include information about the dynamic objects.</li> </ul> </li> <li>From API:<ul> <li>V2X information: The information from V2X modules. For example, the information from traffic signals.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/perception/#output-from-the-perception-component","title":"Output from the Perception Component","text":"<ul> <li>To Planning<ul> <li>Dynamic Objects: Provides real-time information about objects that cannot be known in advance, such as pedestrians and other vehicles.</li> <li>Obstacle Segmentation: Supplies real-time information about the location of obstacles, which is more primitive than Detected Object.</li> <li>Occupancy Grid Map: Offers real-time information about the presence of occluded area information.</li> <li>Traffic Light Recognition result: Provides the current state of each traffic light in real time.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/perception/#how-to-add-new-modules-wip","title":"How to add new modules (WIP)","text":"<p>As mentioned in the goal session, this perception module is designed to be extensible by third-party components. For specific instructions on how to add new modules and expand its functionality, please refer to the provided documentation or guidelines (WIP).</p>"},{"location":"design/autoware-architecture/perception/#supported-functions","title":"Supported Functions","text":"Feature Description Requirements LiDAR DNN based 3D detector This module takes point clouds as input and detects objects such as vehicles, trucks, buses, pedestrians, and bicycles. - Point Clouds Camera DNN based 2D detector This module takes camera images as input and detects objects such as vehicles, trucks, buses, pedestrians, and bicycles in the two-dimensional image space. It detects objects within image coordinates and providing 3D coordinate information is not mandatory. - Camera Images LiDAR Clustering This module performs clustering of point clouds and shape estimation to achieve object detection without labels. - Point Clouds Semi-rule based detector This module detects objects using information from both images and point clouds, and it consists of two components: LiDAR Clustering and Camera DNN based 2D detector. - Output from Camera DNN based 2D detector and LiDAR Clustering Radar based 3D detector This module takes radar data as input and detects dynamic 3D objects. In detail, please see this document. - Radar data Object Merger This module integrates results from various detectors. - Detected Objects Interpolator This module stabilizes the object detection results by maintaining long-term detection results using Tracking results. - Detected Objects  - Tracked Objects Tracking This module gives ID and estimate velocity to the detection results. - Detected Objects Prediction This module predicts the future paths (and their probabilities) of dynamic objects according to the shape of the map and the surrounding environment. - Tracked Objects  - Vector Map Obstacle Segmentation This module identifies point clouds originating from obstacles that the ego vehicle should avoid. - Point Clouds  - Point Cloud Map Occupancy Grid Map This module detects blind spots (areas where no information is available and where dynamic objects may jump out). - Point Clouds  - Point Cloud Map Traffic Light Recognition This module detects the position and state of traffic signals. - Camera Images  - Vector Map"},{"location":"design/autoware-architecture/perception/#reference-implementation","title":"Reference Implementation","text":"<p>When Autoware is launched, the default parameters are loaded, and the Reference Implementation is started. For more details, please refer to the Reference Implementation.</p>"},{"location":"design/autoware-architecture/perception/reference_implementation/","title":"Perception Component Reference Implementation Design","text":""},{"location":"design/autoware-architecture/perception/reference_implementation/#perception-component-reference-implementation-design","title":"Perception Component Reference Implementation Design","text":""},{"location":"design/autoware-architecture/perception/reference_implementation/#purpose-of-this-document","title":"Purpose of this document","text":"<p>This document outlines detailed design of the reference imprementations. This allows developers and users to understand what is currently available with the Perception Component, how to utilize, expand, or add to its features.</p>"},{"location":"design/autoware-architecture/perception/reference_implementation/#architecture","title":"Architecture","text":"<p>This diagram describes the architecture of the reference implementation.</p> <p></p> <p>The Perception component consists of the following sub-components:</p> <ul> <li>Obstacle Segmentation: Identifies point clouds originating from obstacles(not only dynamic objects but also static obstacles that should be avoided, such as stationary obstacles) that the ego vehicle should avoid. For example, construction cones are recognized using this module.</li> <li>Occupancy Grid Map: Detects blind spots (areas where no information is available and where dynamic objects may jump out).</li> <li>Object Recognition: Recognizes dynamic objects surrounding the ego vehicle in the current frame and predicts their future trajectories.<ul> <li>Detection: Detects the pose and velocity of dynamic objects such as vehicles and pedestrians.<ul> <li>Detector: Triggers object detection processing frame by frame.</li> <li>Interpolator: Maintains stable object detection. Even if the output from Detector suddenly becomes unavailable, Interpolator uses the output from the Tracking module to maintain the detection results without missing any objects.</li> </ul> </li> <li>Tracking: Associates detected results across multiple frames.</li> <li>Prediction: Predicts trajectories of dynamic objects.</li> </ul> </li> <li>Traffic Light Recognition: Recognizes the colors of traffic lights and the directions of arrow signals.</li> </ul>"},{"location":"design/autoware-architecture/perception/reference_implementation/#internal-interface-in-the-perception-component","title":"Internal interface in the perception component","text":"<ul> <li>Obstacle Segmentation to Object Recognition<ul> <li>Point Cloud: A Point Cloud observed in the current frame, where the ground and outliers are removed.</li> </ul> </li> <li>Obstacle Segmentation to Occupancy Grid Map<ul> <li>Ground filtered Point Cloud: A Point Cloud observed in the current frame, where the ground is removed.</li> </ul> </li> <li>Occupancy Grid Map to Obstacle Segmentation<ul> <li>Occupancy Grid Map: This is used for filtering outlier.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/","title":"Radar faraway dynamic objects detection with radar objects","text":""},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#radar-faraway-dynamic-objects-detection-with-radar-objects","title":"Radar faraway dynamic objects detection with radar objects","text":""},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#overview","title":"Overview","text":"<p>This diagram describes the pipeline for radar faraway dynamic object detection.</p> <p></p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#reference-implementation","title":"Reference implementation","text":""},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#crossing-filter","title":"Crossing filter","text":"<ul> <li>radar_crossing_objects_noise_filter</li> </ul> <p>This package can filter the noise objects crossing to the ego vehicle, which are most likely ghost objects.</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#velocity-filter","title":"Velocity filter","text":"<ul> <li>object_velocity_splitter</li> </ul> <p>Static objects include many noise like the objects reflected from ground. In many cases for radars, dynamic objects can be detected stably. To filter out static objects, <code>object_velocity_splitter</code> can be used.</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#range-filter","title":"Range filter","text":"<ul> <li>object_range_splitter</li> </ul> <p>For some radars, ghost objects sometimes occur for near objects. To filter these objects, <code>object_range_splitter</code> can be used.</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#vector-map-filter","title":"Vector map filter","text":"<ul> <li>object-lanelet-filter</li> </ul> <p>In most cases, vehicles drive in drivable are. To filter objects that are out of drivable area, <code>object-lanelet-filter</code> can be used. <code>object-lanelet-filter</code> filter objects that are out of drivable area defined by vector map.</p> <p>Note that if you use <code>object-lanelet-filter</code> for radar faraway detection, you need to define drivable area in a vector map other than the area where autonomous car run.</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#radar-object-clustering","title":"Radar object clustering","text":"<ul> <li>radar_object_clustering</li> </ul> <p>This package can combine multiple radar detections from one object into one and adjust class and size. It can suppress splitting objects in tracking module.</p> <p></p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#note","title":"Note","text":""},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#parameter-tuning","title":"Parameter tuning","text":"<p>Detection performed only by Radar applies various strong noise processing. Therefore, there is a trade-off that if you strengthen the noise processing, things that you originally wanted to detect will disappear, and if you weaken it, your self-driving system will be unable to start because the object will be in front of you all the time due to noise. It is necessary to adjust parameters while paying attention to this trade-off.</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/faraway-object-detection/#limitation","title":"Limitation","text":"<ul> <li>Elevated railway, vehicles for multi-level intersection</li> </ul> <p>If you use 2D radars (The radar can detect in xy-axis 2D coordinate, but can not have z-axis detection) and driving area has elevated railway or vehicles for multi-level intersection, the radar process detects these these and these have a bad influence to planning results. In addition, for now, elevated railway is detected as vehicle because the radar process doesn't have label classification feature and it leads to unintended behavior.</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/","title":"Radar based 3D detector","text":""},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#radar-based-3d-detector","title":"Radar based 3D detector","text":""},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#overview","title":"Overview","text":""},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#features","title":"Features","text":"<p>Radar based 3D detector aims for the following:</p> <ul> <li>Detecting objects farther than the range of LiDAR-based 3D detection.</li> </ul> <p>Since radar can acquire data from a longer distance than LiDAR (&gt; 100m), when the distance of LiDAR-based 3D detection is insufficient, the radar base 3D detector can be applied. The detection distance of radar based 3D detection depends on the radar device specification.</p> <ul> <li>Improving velocity estimation for dynamic objects</li> </ul> <p>Radar can get velocity information and estimate more precise twist information by fused between the objects from LiDAR-based 3D detection radar information. This can lead to improve for the performance of object tracking/prediction and planning like adaptive cruise control.</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#whole-pipeline","title":"Whole pipeline","text":"<p>Radar based 3D detector with radar objects consists of</p> <ul> <li>3D object detection with Radar pointcloud</li> <li>Noise filter</li> <li>Faraway dynamic 3D object detection</li> <li>Radar fusion to LiDAR-based 3D object detection</li> <li>Radar object tracking</li> <li>Merger of tracked object</li> </ul> <p></p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#interface","title":"Interface","text":"<ul> <li>Input<ul> <li>Message type for pointcloud is <code>ros-perception/radar_msgs/msg/RadarScan.msg</code></li> <li>Message type for radar objects is <code>autoware_auto_perception_msgs/msg/DetectedObject</code>.<ul> <li>Input objects need to be concatenated.</li> <li>Input objects need to be compensated with ego motion.</li> <li>Input objects need to be transformed to <code>base_link</code>.</li> </ul> </li> </ul> </li> <li>Output<ul> <li>Tracked objects</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#module","title":"Module","text":""},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#radar-pointcloud-3d-detection","title":"Radar pointcloud 3D detection","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#noise-filter-and-radar-faraway-dynamic-3d-object-detection","title":"Noise filter and radar faraway dynamic 3D object detection","text":"<p>This function filters noise objects and detects faraway (&gt; 100m) dynamic vehicles. The main idea is that in the case where LiDAR is used, near range can be detected accurately using LiDAR pointcloud and the main role of radar is to detect distant objects that cannot be detected with LiDAR alone. In detail, please see this document</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#radar-fusion-to-lidar-based-3d-object-detection","title":"Radar fusion to LiDAR-based 3D object detection","text":"<ul> <li>radar_fusion_to_detected_object</li> </ul> <p>This package contains a sensor fusion module for radar-detected objects and 3D detected objects. The fusion node can:</p> <ul> <li>Attach velocity to 3D detections when successfully matching radar data. The tracking modules use the velocity information to enhance the tracking results while planning modules use it to execute actions like adaptive cruise control.</li> <li>Improve the low confidence 3D detections when corresponding radar detections are found.</li> </ul>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#radar-object-tracking","title":"Radar object tracking","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#merger-of-tracked-object","title":"Merger of tracked object","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#appendix","title":"Appendix","text":""},{"location":"design/autoware-architecture/perception/reference-implementations/radar-based-3d-detector/radar-based-3d-detector/#customize-own-radar-interface","title":"Customize own radar interface","text":"<p>The perception interface of Autoware is defined to <code>DetectedObjects</code>, <code>TrackedObjects</code>, and <code>PredictedObjects</code>, however, other message is defined by own cases. For example, DetectedObjectWithFeature is used by customized message in perception module.</p> <p>Same as that, you can adjust new radar interface. For example, <code>RadarTrack</code> doesn't have orientation information from past discussions, especially this discussion. If you want orientation information, you can adapt radar ROS driver to publish directly to <code>TrackedObject</code>.</p>"},{"location":"design/autoware-architecture/planning/","title":"Planning component design","text":""},{"location":"design/autoware-architecture/planning/#planning-component-design","title":"Planning component design","text":""},{"location":"design/autoware-architecture/planning/#purpose","title":"Purpose","text":"<p>The Planning Component in autonomous driving systems plays a crucial role in generating a target trajectory (path and speed) for autonomous vehicles. It ensures safety and adherence to traffic rules, fulfilling specific missions.</p> <p>This document outlines the planning requirements and design within Autoware, aiding developers in comprehending the design and extendibility of the Planning Component.</p> <p>The document is divided into two parts: the first part discusses high-level requirements and design, and the latter part focuses on actual implementations and functionalities provided.</p>"},{"location":"design/autoware-architecture/planning/#goals-and-non-goals","title":"Goals and non-goals","text":"<p>Our objective extends beyond merely developing an autonomous driving system. We aim to offer an \"autonomous driving platform\" where users can enhance autonomous driving functionalities based on their individual needs.</p> <p>In Autoware, we utilize the microautonomy architecture concept, which emphasizes high extensibility, functional modularity, and clearly defined interfaces.</p> <p>With this in mind, the design policy for the Planning Component is focused not on addressing every complex autonomous driving scenario (as that is a very challenging problem), but on providing a customizable and easily extendable Planning development platform. We believe this approach will allow the platform to meet a wide range of needs, ultimately solving many complex use cases.</p> <p>To clarify this policy, the Goals and Non-Goals are defined as follows:</p> <p>Goals:</p> <ul> <li>The basic functions are provided so that a simple ODD can be defined<ul> <li>Before extending its functionalities, the Planning Component must provide the essential features necessary for autonomous driving. This encompasses basic operations like moving, stopping, and turning, as well as handling lane changes and obstacle avoidance in relatively safe and simple contexts.</li> </ul> </li> <li>The functionality is modularized for user-driven extension<ul> <li>The system is designed to adapt to various Operational Design Domains (ODDs) with extended functionalities. Modularization, akin to plug-ins, allows for creating systems tailored to diverse needs, such as different levels of autonomous driving and varied vehicular or environmental applications (e.g., Lv4/Lv2 autonomous driving, public/private road driving, large vehicles, small robots).</li> <li>Reducing functionalities for specific ODDs, like obstacle-free private roads, is also a key aspect. This modular approach allows for reductions in power consumption or sensor requirements, aligning with specific user needs.</li> </ul> </li> <li>The capability is extensible with the decision of human operators<ul> <li>Incorporating operator assistance is a critical aspect of functional expansion. It means that the system can adapt to complex and challenging scenarios with human support. The specific type of operator is not defined here. It might be a person accompanying in the vehicle during the prototype development phase or a remote operator connected in emergencies during autonomous driving services.</li> </ul> </li> </ul> <p>Non-goals:</p> <p>The Planning Component is designed to be extended with third-party modules. Consequently, the following are not the goals of Autoware's Planning Component:</p> <ul> <li>To provide all user-required functionalities by default.</li> <li>To provide complete functionality and performance characteristic of an autonomous driving system.</li> <li>To provide performance that consistently surpasses human capabilities or ensures absolute safety.</li> </ul> <p>These aspects are specific to our vision of an autonomous driving \"platform\" and may not apply to a typical autonomous driving Planning Component.</p>"},{"location":"design/autoware-architecture/planning/#high-level-design","title":"High level design","text":"<p>This diagram illustrates the high-level architecture of the Planning Component. This represents an idealized design, and current implementations might vary. Further details on implementations are provided in the latter sections of this document.</p> <p></p> <p>Following the principles of microautonomy architecture, we have adopted a modular system framework. The functions within the Planning domain are implemented as modules, dynamically or statically adaptable according to specific use cases. This includes modules for lane changes, intersection handling, and pedestrian crossings, among others.</p> <p>The Planning Component comprises several sub-components:</p> <ul> <li>Mission Planning: This module calculates routes from the current location to the destination, utilizing map data. Its functionality is similar to that of Fleet Management Systems (FMS) or car navigation route planning.</li> <li>Planning Modules: These modules plans the vehicle's behavior for the assigned mission, including target trajectory, blinker signaling, etc. They are divided into Behavior and Motion categories:<ul> <li>Behavior: Focuses on calculating safe and rule-compliant routes, managing decisions for lane changes, intersection entries, and stoppings at a stop line.</li> <li>Motion: Works in cooperate with Behavior modules to determine the vehicle's trajectory, considering its motion and ride comfort. It includes lateral and longitudinal planning for route shaping and speed calculation.</li> </ul> </li> <li>Validation: Ensures the safety and appropriateness of the planned trajectories, with capabilities for emergency response. In cases where a planned trajectory is unsuitable, it triggers emergency protocols or generates alternative paths.</li> </ul>"},{"location":"design/autoware-architecture/planning/#highlights","title":"Highlights","text":"<p>Key aspects of this high-level design include:</p>"},{"location":"design/autoware-architecture/planning/#modulation-of-each-function","title":"Modulation of each function","text":"<p>Essential Planning functions, such as route generation, lane changes, and intersection management, are modularized. These modules come with standardized interfaces, enabling easy addition or modification. More details on these interfaces will be discussed in subsequent sections. You can see the details about how to enable/disable each module in the implementation documentation of Planning.</p>"},{"location":"design/autoware-architecture/planning/#separation-of-mission-planning-sub-component","title":"Separation of Mission Planning sub-component","text":"<p>Mission Planning serves as a substitute for functions typically found in existing services like FMS (Fleet Management System). Adherence to defined interfaces in the high-level design facilitates easy integration with third-party services.</p>"},{"location":"design/autoware-architecture/planning/#separation-of-validation-sub-component","title":"Separation of Validation sub-component","text":"<p>Given the extendable nature of the Planning Component, ensuring consistent safety levels across all functions is challenging. Therefore, the Validation function is managed independently from the core planning modules, maintaining a baseline of safety even for arbitrary changes of the planning modules.</p>"},{"location":"design/autoware-architecture/planning/#interface-for-hmi-human-machine-interface","title":"Interface for HMI (Human Machine Interface)","text":"<p>The HMI is designed for smooth cooperation with human operators. These interfaces enable coordination between the Planning Component and operators, whether in-vehicle or remote.</p>"},{"location":"design/autoware-architecture/planning/#trade-offs-for-the-separation-of-planning-and-other-components","title":"Trade-offs for the separation of planning and other components","text":"<p>In Autoware's overarching design, the separation of components like Planning, Perception, Localization, and Control facilitates cooperation with third-party modules. However, this separation entails trade-offs between performance and extensibility. For instance, the Perception component might process unnecessary objects due to its separation from Planning. Similarly, separating planning and control can pose challenges in accounting for vehicle dynamics during planning. To mitigate these issues, we might need to enhance interface information or increase computational efforts.</p>"},{"location":"design/autoware-architecture/planning/#customize-features","title":"Customize features","text":"<p>A significant feature of the Planning Component design is its ability to integrate with external modules. The diagram below shows various methods for incorporating external functionalities.</p> <p></p>"},{"location":"design/autoware-architecture/planning/#1-adding-new-modules-to-the-planning-component","title":"1. Adding New Modules to the Planning Component","text":"<p>Users can augment or replace existing Planning functionalities with new modules. This approach is commonly used for extending features, allowing for the addition of capabilities absent in the desired ODD or simplification of existing features.</p> <p>However, adding these functionalities requires well-organized module interfaces. As of November 2023, an ideal modular system is not fully established, presenting some limitations. For more information, please refer to the Reference Implementation section Customize features in the current implementation and the implementation documentation of Planning.</p>"},{"location":"design/autoware-architecture/planning/#2-replacing-sub-components-of-planning","title":"2. Replacing Sub-components of Planning","text":"<p>Collaboration and extension at the sub-component level may interest some users. This could involve replacing Mission Planning with an existing FMS service or incorporating a third-party trajectory generation module while utilizing the existing Validation functionality.</p> <p>Adhering to the Internal interface in the planning component, collaboration and extension at this level are feasible. While complex coordination with existing Planning features may be limited, it allows for integration between certain Planning Component functionalities and external modules.</p>"},{"location":"design/autoware-architecture/planning/#3-replacing-the-entire-planning-component","title":"3. Replacing the Entire Planning Component","text":"<p>Organizations or research entities developing autonomous driving Planning systems might be interested in integrating their proprietary Planning solutions with Autoware's Perception or Control modules. This can be achieved by replacing the entire Planning system, following the robust and stable interfaces defined between components. It is important to note, however, that direct coordination with existing Planning modules might not be possible.</p>"},{"location":"design/autoware-architecture/planning/#component-interface","title":"Component interface","text":"<p>This section describes the inputs and outputs of the Planning Component and of its internal modules. See the Planning Component Interface page for the current implementation.</p>"},{"location":"design/autoware-architecture/planning/#input-to-the-planning-component","title":"Input to the planning component","text":"<ul> <li>From Map<ul> <li>Vector map: Contains all static information about the environment, including lane connection information for route planning, lane geometry for generating a reference path, and traffic rule-related information.</li> </ul> </li> <li>From Perception<ul> <li>Detected object information: Provides real-time information about objects that cannot be known in advance, such as pedestrians and other vehicles. The Planning Component plans maneuvers to avoid collisions with these objects.</li> <li>Detected obstacle information: Supplies real-time information about the location of obstacles, which is more primitive than Detected Object and used for emergency stops and other safety measures.</li> <li>Occupancy map information: Offers real-time information about the presence of pedestrians and other vehicles and occluded area information.</li> <li>Traffic light recognition result: Provides the current state of each traffic light in real time. The Planning Component extracts relevant information for the planned path and determines whether to stop at intersections.</li> </ul> </li> <li>From Localization<ul> <li>Vehicle motion information: Includes the ego vehicle's position, velocity, acceleration, and other motion-related data.</li> </ul> </li> <li>From System<ul> <li>Operation mode: Indicates whether the vehicle is operating in Autonomous mode.</li> </ul> </li> <li>From Human Machine Interface (HMI)<ul> <li>Feature execution: Allows for executing/authorizing autonomous driving operations, such as lane changes or entering intersections, by human operators.</li> </ul> </li> <li>From API Layer<ul> <li>Destination (Goal): Represents the final position that the Planning Component aims to reach.</li> <li>Checkpoint: Represents a midpoint along the route to the destination. This is used during route calculation.</li> <li>Velocity limit: Sets the maximum speed limit for the vehicle.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/planning/#output-from-the-planning-component","title":"Output from the planning component","text":"<ul> <li>To Control<ul> <li>Trajectory: Provides a smooth sequence of pose, twist, and acceleration that the Control Component must follow. The trajectory is typically 10 seconds long with a 0.1-second resolution.</li> <li>Turn Signals: Controls the vehicle's turn indicators, such as right, left, hazard, etc. based on the planned maneuvers.</li> </ul> </li> <li>To System<ul> <li>Diagnostics: Reports the state of the Planning Component, indicating whether the processing is running correctly and whether a safe plan is being generated.</li> </ul> </li> <li>To Human Machine Interface (HMI)<ul> <li>Feature execution availability: Indicates the status of operations that can be executed or are required, such as lane changes or entering intersections.</li> <li>Trajectory candidate: Shows the potential trajectory that will be executed after the user's execution.</li> </ul> </li> <li>To API Layer<ul> <li>Planning factors: Provides information about the reasoning behind the current planning behavior. This may include the position of target objects to avoid, obstacles that led to the decision to stop, and other relevant information.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/planning/#internal-interface-in-the-planning-component","title":"Internal interface in the planning component","text":"<ul> <li>Mission Planning to Scenario Planning<ul> <li>Route: Offers guidance for the path that needs to be followed from the starting point to the destination. This path is determined based on information such as lane IDs defined on the map. At the route level, it doesn't explicitly indicate which specific lanes to take, and the route can contain multiple lanes.</li> </ul> </li> <li>Behavior Planning to Motion Planning<ul> <li>Path: Provides a rough position and velocity to be followed by the vehicle. These path points are usually defined with an interval of about 1 meter. Although other interval distances are possible, it may impact the precision or performance of the planning component.</li> <li>Drivable area: Defines regions where the vehicle can drive, such as within lanes or physically drivable areas. It assumes that the motion planner will calculate the final trajectory within this defined area.</li> </ul> </li> <li>Scenario Planning to Validation<ul> <li>Trajectory: Defines the desired positions, velocities, and accelerations which the Control Component will try to follow. Trajectory points are defined at intervals of approximately 0.1 seconds based on the trajectory velocities.</li> </ul> </li> <li>Validation to Control Component<ul> <li>Trajectory: Same as above but with some additional safety considerations.</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/planning/#detailed-design","title":"Detailed design","text":""},{"location":"design/autoware-architecture/planning/#supported-features","title":"Supported features","text":"Feature Description Requirements Figure Demonstration Route Planning Plan route from the ego vehicle position to the destination.  Reference implementation is in Mission Planner, enabled by launching the <code>mission_planner</code> node. - Lanelet map (driving lanelets) Path Planning from Route Plan path to be followed from the given route.   Reference implementation is in Behavior Path Planner. - Lanelet map (driving lanelets) Obstacle Avoidance Plan path to avoid obstacles by steering operation.   Reference implementation is in Static Avoidance Module, Path Optimizer. Enable flag in parameter: <code>launch path_optimizer true</code> - objects information Demonstration Video Path Smoothing Plan path to achieve smooth steering.   Reference implementation is in Path Optimizer. - Lanelet map (driving lanelet) Demonstration Video Narrow Space Driving Plan path to drive within the drivable area. Furthermore, when it is not possible to drive within the drivable area, stop the vehicle to avoid exiting the drivable area.   Reference implementation is in Path Optimizer. - Lanelet map (high-precision lane boundaries) Demonstration Video Lane Change Plan path for lane change to reach the destination.   Reference implementation is in Lane Change. - Lanelet map (driving lanelets) Demonstration Video Pull Over Plan path for pull over to park at the road shoulder.   Reference implementation is in Goal Planner. - Lanelet map (shoulder lane) Demonstration Videos:  Simple Pull Over Arc Forward Pull Over Arc Backward Pull Over Pull Out Plan path for pull over to start from the road shoulder.   Reference implementation is in Start Planner. - Lanelet map (shoulder lane) Demonstration Video:  Simple Pull Out Backward Pull Out Path Shift Plan path in lateral direction in response to external instructions.   Reference implementation is in Side Shift Module. - None Obstacle Stop Plan velocity to stop for an obstacle on the path.   Reference implementation is in Obstacle Stop Planner, Obstacle Cruise Planner. <code>launch obstacle_stop_planner</code> and enable flag: <code>TODO</code>, <code>launch obstacle_cruise_planner</code> and enable flag: <code>TODO</code> - objects information Demonstration Video Obstacle Deceleration Plan velocity to decelerate for an obstacle located around the path.   Reference implementation is in Obstacle Stop Planner, Obstacle Cruise Planner. - objects information Demonstration Video Adaptive Cruise Control Plan velocity to follow the vehicle driving in front of the ego vehicle.   Reference implementation is in Obstacle Stop Planner, Obstacle Cruise Planner. - objects information Decelerate for cut-in vehicles Plan velocity to avoid a risk for cutting-in vehicle to ego lane.   Reference implementation is in Obstacle Cruise Planner. - objects information Surround Check at starting Plan velocity to prevent moving when an obstacle exists around the vehicle.   Reference implementation is in Surround Obstacle Checker. Enable flag in parameter: <code>use_surround_obstacle_check true</code> in tier4_planning_component.launch.xml &lt; - objects information Demonstration Video Curve Deceleration Plan velocity to decelerate the speed on a curve.   Reference implementation is in Motion Velocity Smoother. - None Curve Deceleration for Obstacle Plan velocity to decelerate the speed on a curve for a risk of obstacle collision around the path.   Reference implementation is in Obstacle Velocity Limiter. - objects information  - Lanelet map (static obstacle) Demonstration Video Crosswalk Plan velocity to stop or decelerate for pedestrians approaching or walking on a crosswalk.   Reference implementation is in Crosswalk Module. - objects information  - Lanelet map (pedestrian crossing) Demonstration Video Intersection Oncoming Vehicle Check Plan velocity for turning right/left at intersection to avoid a risk with oncoming other vehicles.   Reference implementation is in Intersection Module. - objects information  - Lanelet map (intersection lane and yield lane) Demonstration Video Intersection Blind Spot Check Plan velocity for turning right/left at intersection to avoid a risk with other vehicles or motorcycles coming from behind blind spot.   Reference implementation is in Blind Spot Module. - objects information  - Lanelet map (intersection lane) Demonstration Video Intersection Occlusion Check Plan velocity for turning right/left at intersection to avoid a risk with the possibility of coming vehicles from occlusion area.   Reference implementation is in Intersection Module. - objects information  - Lanelet map (intersection lane) Demonstration Video Intersection Traffic Jam Detection Plan velocity for intersection not to enter the intersection when a vehicle is stopped ahead for a traffic jam.   Reference implementation is in Intersection Module. - objects information  - Lanelet map (intersection lane) Demonstration Video Traffic Light Plan velocity for intersection according to a traffic light signal.   Reference implementation is in Traffic Light Module. - Traffic light color information Demonstration Video Run-out Check Plan velocity to decelerate for the possibility of nearby objects running out into the path.   Reference implementation is in Run Out Module. - objects information Demonstration Video Stop Line Plan velocity to stop at a stop line.   Reference implementation is in Stop Line Module. - Lanelet map (stop line) Demonstration Video Occlusion Spot Check Plan velocity to decelerate for objects running out from occlusion area, for example, from behind a large vehicle.   Reference implementation is in Occlusion Spot Module. - objects information  - Lanelet map (private/public lane) Demonstration Video No Stop Area Plan velocity not to stop in areas where stopping is prohibited, such as in front of the fire station entrance.   Reference implementation is in No Stopping Area Module. - Lanelet map (no stopping area) Merge from Private Area to Public Road Plan velocity for entering the public road from a private driveway to avoid a risk of collision with pedestrians or other vehicles.   Reference implementation is in Merge from Private Area Module. - objects information  - Lanelet map (private/public lane) WIP Speed Bump Plan velocity to decelerate for speed bumps.   Reference implementation is in Speed Bump Module. - Lanelet map (speed bump) Demonstration Video Detection Area Plan velocity to stop at the corresponding stop when an object exist in the designated detection area.   Reference implementation is in Detection Area Module. - Lanelet map (detection area) Demonstration Video No Drivable Lane Plan velocity to stop before exiting the area designated by ODD (Operational Design Domain) or stop the vehicle if autonomous mode started in out of ODD lane.   Reference implementation is in No Drivable Lane Module. - Lanelet map (no drivable lane) Collision Detection when deviating from lane Plan velocity to avoid conflict with other vehicles driving in the another lane when the ego vehicle is deviating from own lane.   Reference implementation is in Out of Lane Module. - objects information  - Lanelet map (driving lane) WIP Parking Plan path and velocity for given goal in parking area.   Reference implementation is in Free Space Planner. - objects information  - Lanelet map (parking area) Demonstration Video Autonomous Emergency Braking (AEB) Perform an emergency stop if a collision with an object ahead is anticipated. It is noted that this function is expected as a final safety layer, and this should work even in the event of failures in the Localization or Perception system.   Reference implementation is in Out of Lane Module. - Primitive objects Minimum Risk Maneuver (MRM) Provide appropriate MRM (Minimum Risk Maneuver) instructions when a hazardous event occurs. For example, when a sensor trouble found, send an instruction for emergency braking, moderate stop, or pulling over to the shoulder, depending on the severity of the situation.   Reference implementation is in TODO - TODO WIP Trajectory Validation Check the planned trajectory is safe. If it is unsafe, take appropriate action, such as modify the trajectory, stop sending the trajectory or report to the autonomous driving system.   Reference implementation is in Planning Validator. - None Running Lane Map Generation Generate lane map from localization data recorded in manual driving.   Reference implementation is in WIP - None WIP Running Lane Optimization Optimize the centerline (reference path) of the map to make it smooth considering the vehicle kinematics.   Reference implementation is in Static Centerline Optimizer. - Lanelet map (driving lanes) WIP"},{"location":"design/autoware-architecture/planning/#reference-implementation","title":"Reference Implementation","text":"<p>The following diagram describes the reference implementation of the Planning component. By adding new modules or extending the functionalities, various ODDs can be supported.</p> <p>Note that some implementation does not adhere to the high-level architecture design due to the difficulties of the implementation and require updating.</p> <p></p> <p>For more details, please refer to the design documents in each package.</p> <ul> <li>mission_planner: calculate route from start to goal based on the map information.</li> <li>behavior_path_planner: calculates path and drivable area based on the traffic rules.<ul> <li>lane_following</li> <li>lane_change</li> <li>static_obstacle_avoidance</li> <li>pull_over</li> <li>pull_out</li> <li>side_shift</li> </ul> </li> <li>behavior_velocity_planner: calculates max speed based on the traffic rules.<ul> <li>detection_area</li> <li>blind_spot</li> <li>cross_walk</li> <li>stop_line</li> <li>traffic_light</li> <li>intersection</li> <li>no_stopping_area</li> <li>virtual_traffic_light</li> <li>occlusion_spot</li> <li>run_out</li> </ul> </li> <li>obstacle_avoidance_planner: calculate path shape under obstacle and drivable area constraints</li> <li>surround_obstacle_checker: keeps the vehicle being stopped when there are obstacles around the ego-vehicle. It works only when the vehicle is stopped.</li> <li>obstacle_stop_planner: When there are obstacles on or near the trajectory, it calculates the maximum velocity of the trajectory points depending on the situation: stopping, slowing down, or adaptive cruise (following the car).<ul> <li>stop</li> <li>slow_down</li> <li>adaptive_cruise</li> </ul> </li> <li>costmap_generator: generates a costmap for path generation from dynamic objects and lane information.</li> <li>freespace_planner: calculates trajectory considering the feasibility (e.g. curvature) for the freespace scene. Algorithms are described here.</li> <li>scenario_selector : chooses a trajectory according to the current scenario.</li> <li>external_velocity_limit_selector: takes an appropriate velocity limit from multiple candidates.</li> <li>motion_velocity_smoother: calculates final velocity considering velocity, acceleration, and jerk constraints.</li> </ul>"},{"location":"design/autoware-architecture/planning/#important-information-in-the-current-implementation","title":"Important information in the current implementation","text":"<p>An important difference compared to the high-level design is the \"introduction of the scenario layer\" and the \"clear separation of behavior and motion.\" These are introduced due to current performance and implementation challenges. Whether to define these as part of the high-level design or to improve them as part of the implementation is a matter of discussion.</p>"},{"location":"design/autoware-architecture/planning/#introducing-the-scenario-planning-layer","title":"Introducing the Scenario Planning layer","text":"<p>There are different requirements for interfaces between driving in well-structured lanes and driving in a free-space area like a parking lot. For example, while Lane Driving can handle routes with map IDs, this is not appropriate for planning in free space. The mechanism that switches planning sub-components at the scenario level (Lane Driving, Parking, etc) enables a flexible design of the interface, however, it has a drawbacks of the reuse of modules across different scenarios.</p>"},{"location":"design/autoware-architecture/planning/#separation-of-behavior-and-motion","title":"Separation of Behavior and Motion","text":"<p>One of the classic approach to Planning involves dividing it into \"Behavior\", which decides the action, and \"Motion\", which determines the final movement. However, this separation implies a trade-off with performance, as performance tends to degrade with increasing separation of functions. For example, Behavior needs to make decisions without prior knowledge of the computations that Motion will eventually perform, which generally results in conservative decision-making. On the other hand, if behavior and motion are integrated, motion performance and decision-making become interdependent, creating challenges in terms of expandability, such as when you wish to extend only the decision-making function to follow a regional traffic rules.</p> <p>To understand this background, this previously discussed document may be useful.</p>"},{"location":"design/autoware-architecture/planning/#customize-features-in-the-current-implementation","title":"Customize features in the current implementation","text":"<p>While it is possible to add module-level functionalities in the current implementation, a unified interface for all functionalities is not provided. Here's a brief explanation of the methods of extending at the module level in the current implementation.</p> <p></p>"},{"location":"design/autoware-architecture/planning/#add-new-modules-in-behavior_velocity_planner-or-behavior_path_planner","title":"Add new modules in behavior_velocity_planner or behavior_path_planner","text":"<p>ROS nodes such as behavior_path_planner and behavior_velocity_planner have a module interface available through plugins. By adding modules in accordance with the module interfaces defined in these ROS nodes, dynamic loading/unloading of modules becomes possible. For specific methods of adding modules, please refer to the documentation of each package.</p>"},{"location":"design/autoware-architecture/planning/#add-a-new-ros-node-in-the-planning-component","title":"Add a new ros node in the planning component","text":"<p>When adding modules in Motion Planning, it is necessary to create the module as a ROS Node and integrate it into the planning component. The current configuration involves adding information to the target trajectory calculated upstream, and the introduction of a ROS Node in this process allows for the expansion of functionality.</p>"},{"location":"design/autoware-architecture/planning/#add-or-replace-with-scenarios","title":"Add or replace with scenarios","text":"<p>The current implementation has introduced a scenario-level switching logic as a method for collectively switching multiple modules. This allows for the addition of new scenarios (e.g., highway driving).</p> <p>By creating a scenario as a ros node and aligning the scenario_selector ros node with it, the integration is complete. The benefit of this is that you can introduce significant new functionalities without affecting the implementation of other scenarios (like Lane Driving). However, it only allows for scenario-level coordination through scenario switching and does not enable coordination at the existing planning module level.</p>"},{"location":"design/autoware-architecture/sensing/","title":"Sensing component design","text":""},{"location":"design/autoware-architecture/sensing/#sensing-component-design","title":"Sensing component design","text":""},{"location":"design/autoware-architecture/sensing/#overview","title":"Overview","text":"<p>Sensing component is a collection of modules that apply some primitive pre-processing to the raw sensor data.</p> <p>The sensor input formats are defined in this component.</p>"},{"location":"design/autoware-architecture/sensing/#role","title":"Role","text":"<ul> <li>Abstraction of data formats to enable usage of sensors from various vendors</li> <li>Perform common/primitive sensor data processing required by each component</li> </ul>"},{"location":"design/autoware-architecture/sensing/#high-level-architecture","title":"High-level architecture","text":"<p>This diagram describes the high-level architecture of the Sensing Component.</p> <p></p>"},{"location":"design/autoware-architecture/sensing/#inputs","title":"Inputs","text":""},{"location":"design/autoware-architecture/sensing/#input-types","title":"Input types","text":"Sensor Data Message Type Point cloud (LiDARs, depth cameras, etc.) sensor_msgs/msg/PointCloud2.msg Image (RGB, monochrome, depth, etc. cameras) sensor_msgs/msg/Image.msg Radar scan radar_msgs/msg/RadarScan.msg Radar tracks radar_msgs/msg/RadarTracks.msg GNSS-INS position sensor_msgs/msg/NavSatFix.msg GNSS-INS orientation autoware_sensing_msgs/GnssInsOrientationStamped.msg GNSS-INS velocity geometry_msgs/msg/TwistWithCovarianceStamped.msg GNSS-INS acceleration geometry_msgs/msg/AccelWithCovarianceStamped.msg IMU sensor_msgs/msg/Imu.msg Ultrasonics sensor_msgs/msg/Range.msg"},{"location":"design/autoware-architecture/sensing/#design-by-data-types","title":"Design by data-types","text":"<ul> <li>GNSS/INS data pre-processing design</li> <li>Image pre-processing design</li> <li>Point cloud pre-processing design</li> <li>Radar pointcloud data pre-processing design</li> <li>Radar objects data pre-processing design</li> <li>Ultrasonics data pre-processing design</li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/gnss-ins-data/","title":"GNSS/INS data pre-processing design","text":""},{"location":"design/autoware-architecture/sensing/data-types/gnss-ins-data/#gnssins-data-pre-processing-design","title":"GNSS/INS data pre-processing design","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/autoware-architecture/sensing/data-types/image/","title":"Image pre-processing design","text":""},{"location":"design/autoware-architecture/sensing/data-types/image/#image-pre-processing-design","title":"Image pre-processing design","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/","title":"Point cloud pre-processing design","text":""},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#point-cloud-pre-processing-design","title":"Point cloud pre-processing design","text":""},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#overview","title":"Overview","text":"<p>Point cloud pre-processing is a collection of modules that apply some primitive pre-processing to the raw sensor data.</p> <p>This pipeline covers the flow of data from drivers to the perception stack.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#recommended-processing-pipeline","title":"Recommended processing pipeline","text":"<pre><code>graph TD\n    Driver[\"Lidar Driver\"] --&gt;|\"Cloud XYZIRCAEDT\"| FilterPR[\"Polygon Remover Filter / CropBox Filter\"]\n\n    subgraph \"sensing\"\n    FilterPR --&gt;|\"Cloud XYZIRCAEDT\"| FilterDC[\"Motion Distortion Corrector Filter\"]\n    FilterDC --&gt;|\"Cloud XYZIRCAEDT\"| FilterOF[\"Outlier Remover Filter\"]\n    FilterOF --&gt;|\"Cloud XYZIRC\"| FilterDS[\"Downsampler Filter\"]\n    FilterDS --&gt;|\"Cloud XYZIRC\"| FilterTrans[\"Cloud Transformer\"]\n    FilterTrans --&gt;|\"Cloud XYZIRC\"| FilterC\n\n    FilterX[\"...\"] --&gt;|\"Cloud XYZIRC (i)\"| FilterC[\"Cloud Concatenator\"]\n    end\n\n    FilterC --&gt;|\"Cloud XYZIRC\"| SegGr[\"Ground Segmentation\"]</code></pre>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#list-of-modules","title":"List of modules","text":"<p>The modules used here are from pointcloud_preprocessor package.</p> <p>For details about the modules, see the following table.</p> <p>It is recommended that these modules are used in a single container as components. For details see ROS 2 Composition</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#point-cloud-fields","title":"Point cloud fields","text":"<p>The lidar driver is expected to output a point cloud with the <code>PointXYZIRCAEDT</code> point type.</p> name datatype derived description <code>X</code> <code>FLOAT32</code> <code>false</code> X position <code>Y</code> <code>FLOAT32</code> <code>false</code> Y position <code>Z</code> <code>FLOAT32</code> <code>false</code> Z position <code>I</code> (intensity) <code>UINT8</code> <code>false</code> Measured reflectivity, intensity of the point <code>R</code> (return type) <code>UINT8</code> <code>false</code> Laser return type for dual return lidars <code>C</code> (channel) <code>UINT16</code> <code>false</code> Channel ID of the laser that measured the point <code>A</code> (azimuth) <code>FLOAT32</code> <code>true</code> <code>atan2(Y, X)</code>, Horizontal angle from the lidar origin to the point <code>E</code> (elevation) <code>FLOAT32</code> <code>true</code> <code>atan2(Z, D)</code>, Vertical angle from the lidar origin to the point <code>D</code> (distance) <code>FLOAT32</code> <code>true</code> <code>hypot(X, Y, Z)</code>, Euclidean distance from the lidar origin to the point <code>T</code> (time) <code>UINT32</code> <code>false</code> Nanoseconds passed since the time of the header when this point was measured <p>Note</p> <p><code>A (azimuth)</code>, <code>E (elevation)</code>, and <code>D (distance)</code> fields are derived fields. They are provided by the driver to reduce the computational load on some parts of the perception stack.</p> <p>Warning</p> <p>Autoware supports conversion from <code>PointXYZI</code> to <code>PointXYZIRC</code> (with channel and return type set to 0) for prototyping purposes. However, this conversion is not recommended for production use since it is not efficient.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#intensity","title":"Intensity","text":"<p>We will use following ranges for intensity, compatible with the VLP16 User Manual:</p> <p>Quoting from the VLP-16 User Manual:</p> <p>For each laser measurement, a reflectivity byte is returned in addition to distance. Reflectivity byte values are segmented into two ranges, allowing software to distinguish diffuse reflectors (e.g. tree trunks, clothing) in the low range from retroreflectors (e.g. road signs, license plates) in the high range. A retroreflector reflects light back to its source with a minimum of scattering. The VLP-16 provides its own light, with negligible separation between transmitting laser and receiving detector, so retroreflecting surfaces pop with reflected IR light compared to diffuse reflectors that tend to scatter reflected energy.</p> <ul> <li>Diffuse reflectors report values from 0 to 100 for reflectivities from 0% to 100%.</li> <li>Retroreflectors report values from 101 to 255, where 255 represents an ideal reflection.</li> </ul> <p>In a typical point cloud without retroreflectors, all intensity points will be between 0 and 100.</p> <p></p> <p>Retroreflective Gradient road sign, Image Source</p> <p>But in a point cloud with retroreflectors, the intensity points will be between 0 and 255.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#intensity-mapping-for-other-lidar-brands","title":"Intensity mapping for other lidar brands","text":""},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#hesai-pandarxt16","title":"Hesai PandarXT16","text":"<p>Hesai Pandar XT16 User Manual</p> <p>This lidar has 2 modes for reporting reflectivity:</p> <ul> <li>Linear mapping</li> <li>Non-linear mapping</li> </ul> <p>If you are using linear mapping mode, you should map from [0, 255] to [0, 100] when constructing the point cloud.</p> <p>If you are using non-linear mapping mode, you should map (hesai to autoware)</p> <ul> <li>[0, 251] to [0, 100] and</li> <li>[252, 254] to [101, 255]</li> </ul> <p>when constructing the point cloud.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#livox-mid-70","title":"Livox Mid-70","text":"<p>Livox Mid-70 User Manual</p> <p>This lidar has 2 modes for reporting reflectivity similar to Velodyne VLP-16, only the ranges are slightly different.</p> <p>You should map (livox to autoware)</p> <ul> <li>[0, 150] to [0, 100] and</li> <li>[151, 255] to [101, 255]</li> </ul> <p>when constructing the point cloud.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#robosense-rs-lidar-16","title":"RoboSense RS-LiDAR-16","text":"<p>RoboSense RS-LiDAR-16 User Manual</p> <p>No mapping required, same as Velodyne VLP-16.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#ouster-os-1-64","title":"Ouster OS-1-64","text":"<p>Software User Manual v2.0.0 for all Ouster sensors</p> <p>In the manual it is stated:</p> <p>Reflectivity [16 bit unsigned int] - sensor Signal Photons measurements are scaled based on measured range and sensor sensitivity at that range, providing an indication of target reflectivity. Calibration of this measurement has not currently been rigorously implemented, but this will be updated in a future firmware release.</p> <p>So it is advised to map the 16 bit reflectivity to [0, 100] range.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#leishen-ch64w","title":"Leishen CH64W","text":"<p>I couldn't get the english user manual, link of website</p> <p>In a user manual I was able to find it says:</p> <p>Byte 7 represents echo strength, and the value range is 0-255. (Echo strength can reflect the energy reflection characteristics of the measured object in the actual measurement environment. Therefore, the echo strength can be used to distinguish objects with different reflection characteristics.)</p> <p>So it is advised to map the [0, 255] to [0, 100] range.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#return-type","title":"Return type","text":"<p>Various lidars support multiple return modes. Velodyne lidars support Strongest and Last return modes.</p> <p>In the <code>PointXYZIRC</code> and <code>PointXYZIRCAEDT</code> types, the <code>R</code> field represents the return type with a <code>UINT8</code>. The return type is vendor-specific. The following table provides an example of return type definitions.</p> R (return type) Description <code>0</code> Unknown / Not Marked <code>1</code> Strongest <code>2</code> Last"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#channel","title":"Channel","text":"<p>The channel field is used to identify the vertical channel of the laser that measured the point. In various lidar manuals or literature, it can also be called laser id, ring, laser line.</p> <p>For Velodyne VLP-16, there are 16 channels. Default order of channels in drivers are generally in firing order.</p> <p>In the <code>PointXYZIRC</code> and <code>PointXYZIRCAEDT</code> types, the <code>C</code> field represents the vertical channel ID with a <code>UINT16</code>.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#azimuth","title":"Azimuth","text":"<p>The azimuth field gives the horizontal angle between the optical origin of the lidar and the point. Many lidar measure this with the angle of the rotary encoder when the laser was fired, and the driver typically corrects the value based on calibration data.</p> <p>In the <code>PointXYZIRCAEDT</code> type, the <code>A</code> field represents the azimuth angle in radians (clockwise) with a <code>FLOAT32</code>.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#elevation","title":"Elevation","text":"<p>The elevation field gives the vertical angle between the optical origin of the lidar and the point. In the <code>PointXYZIRCAEDT</code> type, the <code>E</code> field represents the elevation angle in radians (clockwise) with a <code>FLOAT32</code>.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#solid-state-and-petal-pattern-lidars","title":"Solid state and petal pattern lidars","text":"<p>Warning</p> <p>This section is subject to change. Following are suggestions and open for discussion.</p> <p>For solid state lidars that have lines, assign row number as the channel id.</p> <p>For petal pattern lidars, you can keep channel 0.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#time-stamp","title":"Time stamp","text":"<p>In lidar point clouds, each point measurement can have its individual time stamp. This information can be used to eliminate the motion blur that is caused by the movement of the lidar during the scan.</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#point-cloud-header-time","title":"Point cloud header time","text":"<p>The header contains a Time field. The time field has 2 components:</p> Field Type Description <code>sec</code> <code>int32</code> Unix time (seconds elapsed since January 1, 1970) <code>nanosec</code> <code>uint32</code> Nanoseconds elapsed since the <code>sec</code> field <p>The header of the point cloud message is expected to have the time of the earliest point it has.</p> <p>Note</p> <p>The <code>sec</code> field is <code>int32</code> in ROS 2 humble. The largest value it can represent is 2^31 seconds, it is subject to year 2038 problems. We will wait for actions on ROS 2 community side.</p> <p>More info at: https://github.com/ros2/rcl_interfaces/issues/85</p>"},{"location":"design/autoware-architecture/sensing/data-types/point-cloud/#individual-point-time-stamp","title":"Individual point time stamp","text":"<p>Each <code>PointXYZIRCAEDT</code> point type has the <code>T</code> field for representing the nanoseconds passed since the first-shot point of the point cloud.</p> <p>To calculate exact time each point was shot, the <code>T</code> nanoseconds are added to the header time.</p> <p>Note</p> <p>The <code>T</code> field is <code>uint32</code> type. The largest value it can represent is 2^32 nanoseconds, which equates to roughly 4.29 seconds. Usual point clouds don't last more than 100ms for full cycle. So this field should be enough.</p>"},{"location":"design/autoware-architecture/sensing/data-types/ultrasonics-data/","title":"Ultrasonics data pre-processing design","text":""},{"location":"design/autoware-architecture/sensing/data-types/ultrasonics-data/#ultrasonics-data-pre-processing-design","title":"Ultrasonics data pre-processing design","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/","title":"Radar objects data pre-processing design","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#radar-objects-data-pre-processing-design","title":"Radar objects data pre-processing design","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#overview","title":"Overview","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#pipeline","title":"Pipeline","text":"<p>This diagram describes the pre-process pipeline for radar objects.</p> <p></p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#interface","title":"Interface","text":"<ul> <li>Input<ul> <li>Radar data from device</li> <li>Twist information of ego vehicle motion</li> </ul> </li> <li>Output<ul> <li>Merged radar objects information</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#note","title":"Note","text":"<ul> <li>The radar pre-process package filters noise through the <code>ros-perception/radar_msgs/msg/RadarTrack.msg</code> message type with sensor coordinate.</li> <li>It is recommended to change the coordinate system from each sensor to base_link with message converter.</li> <li>If there are multiple radar objects, the object merger package concatenates these objects.</li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#input","title":"Input","text":"<p>Autoware uses radar objects data type as radar_msgs/msg/RadarTracks.msg. In detail, please see Data message for radars.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#reference-implementations","title":"Reference implementations","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#device-driver-for-radars","title":"Device driver for radars","text":"<p>Autoware supports <code>ros-perception/radar_msgs/msg/RadarScan.msg</code> and <code>autoware_auto_perception_msgs/msg/TrackedObjects.msg</code> for Radar drivers.</p> <p>In detail, please see Device driver for radars.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#noise-filter","title":"Noise filter","text":"<ul> <li>radar_tracks_noise_filter</li> </ul> <p>Radar can detect x-axis velocity as doppler velocity, but cannot detect y-axis velocity. Some radar can estimate y-axis velocity inside the device, but it sometimes lack precision. This package treats these objects as noise by y-axis threshold filter.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#message-converter","title":"Message converter","text":"<ul> <li>radar_tracks_msgs_converter</li> </ul> <p>This package converts from <code>radar_msgs/msg/RadarTracks</code> into <code>autoware_auto_perception_msgs/msg/DetectedObject</code> with ego vehicle motion compensation and coordinate transform.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#object-merger","title":"Object merger","text":"<ul> <li>object_merger</li> </ul> <p>This package can merge 2 topics of <code>autoware_auto_perception_msgs/msg/DetectedObject</code>.</p> <ul> <li>simple_object_merger</li> </ul> <p>This package can merge simply multiple topics of <code>autoware_auto_perception_msgs/msg/DetectedObject</code>. Different from object_merger, this package doesn't use association algorithm and can merge with low calculation cost.</p> <ul> <li>topic_tools</li> </ul> <p>If a vehicle has 1 radar, the topic relay tool in <code>topic_tools</code> can be used. Example is as below.</p> <pre><code>&lt;launch&gt;\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"radar\"/&gt;\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"front_center\"/&gt;\n&lt;include file=\"$(find-pkg-share example_launch)/launch/ars408.launch.xml\"&gt;\n&lt;arg name=\"interface\" value=\"can0\" /&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n&lt;node pkg=\"topic_tools\" exec=\"relay\" name=\"radar_relay\" output=\"log\" args=\"front_center/detected_objects detected_objects\"/&gt;\n&lt;/group&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#appendix","title":"Appendix","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-objects-data/#discussion","title":"Discussion","text":"<p>Radar architecture design is discussed as below.</p> <ul> <li>Discussion 2531</li> <li>Discussion 2532.</li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/","title":"Radar pointcloud data pre-processing design","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#radar-pointcloud-data-pre-processing-design","title":"Radar pointcloud data pre-processing design","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#overview","title":"Overview","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#pipeline","title":"Pipeline","text":"<p>This diagram describes the pre-process pipeline for radar pointcloud.</p> <p></p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#interface","title":"Interface","text":"<ul> <li>Input<ul> <li>Radar data from device</li> <li>Twist information of ego vehicle motion</li> </ul> </li> <li>Output<ul> <li>Dynamic radar pointcloud (<code>ros-perception/radar_msgs/msg/RadarScan.msg</code>)</li> <li>Noise filtered radar pointcloud (<code>sensor_msgs/msg/Pointcloud2.msg</code>)</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#note","title":"Note","text":"<ul> <li>In the sensing layer, the radar pre-process packages filter noise through the <code>ros-perception/radar_msgs/msg/RadarScan.msg</code> message type with sensor coordinate.</li> <li>For use of radar pointcloud data by LiDAR packages, we would like to propose a converter for creating <code>sensor_msgs/msg/Pointcloud2.msg</code> from <code>ros-perception/radar_msgs/msg/RadarScan.msg</code>.</li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#reference-implementations","title":"Reference implementations","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#data-message-for-radars","title":"Data message for radars","text":"<p>Autoware uses radar objects data type as radar_msgs/msg/RadarScan.msg. In detail, please see Data message for radars.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#device-driver-for-radars","title":"Device driver for radars","text":"<p>Autoware support <code>ros-perception/radar_msgs/msg/RadarScan.msg</code> and <code>autoware_auto_perception_msgs/msg/TrackedObjects.msg</code> for Radar drivers.</p> <p>In detail, please see Device driver for radars.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#basic-noise-filter","title":"Basic noise filter","text":"<ul> <li>radar_threshold_filter</li> </ul> <p>This package removes pointcloud noise with low amplitude, edge angle, too near pointcloud by threshold. The noise depends on the radar devices and installation location.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#filter-to-staticdynamic-pointcloud","title":"Filter to static/dynamic pointcloud","text":"<ul> <li>radar_static_pointcloud_filter</li> </ul> <p>This package extracts static/dynamic radar pointcloud by using doppler velocity and ego motion. The static radar pointcloud can be used for localization like NDT scan matching, and the dynamic radar pointcloud can be used for dynamic object detection.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#message-converter-from-radarscan-to-pointcloud2","title":"Message converter from RadarScan to Pointcloud2","text":"<ul> <li>radar_scan_to_pointcloud2</li> </ul> <p>For convenient use of radar pointcloud within existing LiDAR packages, we suggest a <code>radar_scan_to_pointcloud2_convertor</code> package for conversion from <code>ros-perception/radar_msgs/msg/RadarScan.msg</code> to <code>sensor_msgs/msg/Pointcloud2.msg</code>.</p> LiDAR package Radar package message <code>sensor_msgs/msg/Pointcloud2.msg</code> <code>ros-perception/radar_msgs/msg/RadarScan.msg</code> coordinate (x, y, z) (r, \u03b8, \u03c6) value intensity amplitude, doppler velocity <p>For considered use cases,</p> <ul> <li>Use pointcloud_preprocessor for radar scan.</li> <li>Apply obstacle segmentation like ground segmentation to radar points for LiDAR-less (camera + radar) systems.</li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#appendix","title":"Appendix","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/radar-pointcloud-data/#discussion","title":"Discussion","text":"<p>Radar architecture design is discussed as below.</p> <ul> <li>Discussion 2531</li> <li>Discussion 2532.</li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/","title":"Data message for radars","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/#data-message-for-radars","title":"Data message for radars","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/#summary","title":"Summary","text":"<p>To sum up, Autoware uses radar data type as below.</p> <ul> <li>radar_msgs/msg/RadarScan.msg for radar pointcloud</li> <li>radar_msgs/msg/RadarTracks.msg for radar objects.</li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/#radar-data-message-for-pointcloud","title":"Radar data message for pointcloud","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/#message-definition","title":"Message definition","text":"<ul> <li>ros2/msg/RadarScan.msg</li> </ul> <pre><code>std_msgs/Header header\nradar_msgs/RadarReturn[] returns\n</code></pre> <ul> <li>ros2/msg/RadarReturn.msg</li> </ul> <pre><code># All variables below are relative to the radar's frame of reference.\n# This message is not meant to be used alone but as part of a stamped or array message.\n\nfloat32 range                            # Distance (m) from the sensor to the detected return.\nfloat32 azimuth                          # Angle (in radians) in the azimuth plane between the sensor and the detected return.\n#    Positive angles are anticlockwise from the sensor and negative angles clockwise from the sensor as per REP-0103.\nfloat32 elevation                        # Angle (in radians) in the elevation plane between the sensor and the detected return.\n#    Negative angles are below the sensor. For 2D radar, this will be 0.\nfloat32 doppler_velocity                 # The doppler speeds (m/s) of the return.\nfloat32 amplitude                        # The amplitude of the of the return (dB)\n</code></pre>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/#radar-data-message-for-tracked-objects","title":"Radar data message for tracked objects","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/#message-definition_1","title":"Message definition","text":"<ul> <li>radar_msgs/msg/RadarTrack.msg</li> </ul> <pre><code># Object classifications (Additional vendor-specific classifications are permitted starting from 32000 eg. Car)\nuint16 NO_CLASSIFICATION=0\nuint16 STATIC=1\nuint16 DYNAMIC=2\n\nunique_identifier_msgs/UUID uuid            # A unique ID of the object generated by the radar.\n# Note: The z component of these fields is ignored for 2D tracking.\ngeometry_msgs/Point position                # x, y, z coordinates of the centroid of the object being tracked.\ngeometry_msgs/Vector3 velocity              # The velocity of the object in each spatial dimension.\ngeometry_msgs/Vector3 acceleration          # The acceleration of the object in each spatial dimension.\ngeometry_msgs/Vector3 size                  # The object size as represented by the radar sensor eg. length, width, height OR the diameter of an ellipsoid in the x, y, z, dimensions\n# and is from the sensor frame's view.\nuint16 classification                       # An optional classification of the object (see above)\nfloat32[6] position_covariance              # Upper-triangle covariance about the x, y, z axes\nfloat32[6] velocity_covariance              # Upper-triangle covariance about the x, y, z axes\nfloat32[6] acceleration_covariance          # Upper-triangle covariance about the x, y, z axes\nfloat32[6] size_covariance                  # Upper-triangle covariance about the x, y, z axes\n</code></pre>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/#message-usage-for-radartracks","title":"Message usage for RadarTracks","text":"<ul> <li>Object classifications</li> </ul> <p>In object classifications of radar_msgs/msg/RadarTrack.msg, additional classifications label can be used by the number starting from 32000.</p> <p>To express for Autoware label definition, Autoware defines object classifications for <code>RadarTracks.msg</code> as below.</p> <pre><code>uint16 UNKNOWN = 32000;\nuint16 CAR = 32001;\nuint16 TRUCK = 32002;\nuint16 BUS = 32003;\nuint16 TRAILER = 32004;\nuint16 MOTORCYCLE = 32005;\nuint16 BICYCLE = 32006;\nuint16 PEDESTRIAN = 32007;\n</code></pre> <p>For detail implementation, please see radar_tracks_msgs_converter.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/#note","title":"Note","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/data-message/#survey-for-radar-message","title":"Survey for radar message","text":"<p>Depending on the sensor manufacturer and its purpose, each sensor might exchange raw, post-processed data. This section introduces a survey about the previously developed messaging systems in the open-source community. Although there are many kinds of outputs, radar mainly adopt two types as outputs, pointcloud and objects. Related discussion for message definition in ros-perception are PR #1, PR #2, and PR #3. Existing open source softwares for radar are summarized in these PR.</p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/device-driver/","title":"Device driver for radars","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/device-driver/#device-driver-for-radars","title":"Device driver for radars","text":""},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/device-driver/#interface-for-radar-devices","title":"Interface for radar devices","text":"<p>The radar driver converts the communication data from radars to ROS 2 topics. The following communication types are considered:</p> <ul> <li>CAN</li> <li>CAN-FD</li> <li>Ethernet</li> </ul> <p></p>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/device-driver/#software-interface","title":"Software Interface","text":"<p>Autoware support <code>ros-perception/radar_msgs/msg/RadarScan.msg</code> and <code>autoware_auto_perception_msgs/msg/TrackedObjects.msg</code> for Radar drivers.</p> <p></p> <p>ROS driver receive the data from radar devices.</p> <ul> <li>Scan (pointcloud)</li> <li>Tracked objects</li> <li>Diagnostics results</li> </ul> <p>The ROS drivers receives the following data from the radar device.</p> <ul> <li>Time synchronization</li> <li>Ego vehicle status, which often need for tracked objects calculation</li> </ul>"},{"location":"design/autoware-architecture/sensing/data-types/radar-data/reference-implementations/device-driver/#radar-driver-example","title":"Radar driver example","text":"<ul> <li>ARS408 driver</li> </ul>"},{"location":"design/autoware-architecture/vehicle/","title":"Vehicle Interface design","text":""},{"location":"design/autoware-architecture/vehicle/#vehicle-interface-design","title":"Vehicle Interface design","text":""},{"location":"design/autoware-architecture/vehicle/#abstract","title":"Abstract","text":"<p>The Vehicle Interface component provides an interface between Autoware and a vehicle that passes control signals to the vehicle\u2019s drive-by-wire system and receives vehicle information that is passed back to Autoware.</p>"},{"location":"design/autoware-architecture/vehicle/#1-requirements","title":"1. Requirements","text":"<p>Goals:</p> <ul> <li>The Vehicle Interface component converts Autoware commands to a vehicle-specific format and converts vehicle status in a vehicle-specific format to Autoware messages.</li> <li>The interface between Autoware and the Vehicle component is abstracted and independent of hardware.</li> <li>The interface is extensible such that additional vehicle-specific commands can be easily added. For example, headlight control.</li> </ul> <p>Non-goals:</p> <ul> <li>Accuracy of responses from the vehicle will not be defined, but example accuracy requirements from reference designs are provided as examples.</li> <li>Response speed will not be defined.</li> </ul>"},{"location":"design/autoware-architecture/vehicle/#2-architecture","title":"2. Architecture","text":"<p>The Vehicle Interface component consists of the following components:</p> <ul> <li>A Raw Vehicle Command Converter component that will pass through vehicle commands from the Control component if velocity/acceleration control is supported by the drive-by-wire system. Otherwise, the Control commands will be modified according to the control method (eg: converting a target acceleration from the Control component to a vehicle specific accel/brake pedal value through the use of an acceleration map)</li> <li>A Vehicle Interface component (vehicle specific) that acts as an interface between Autoware and a vehicle to communicate control signals and to obtain information about the vehicle (steer output, tyre angle etc)</li> </ul> <p>Each component contains static nodes of Autoware, while each module can be dynamically loaded and unloaded (corresponding to C++ classes). The mechanism of the Vehicle Interface component is depicted by the following figures:</p> <p></p> <p></p>"},{"location":"design/autoware-architecture/vehicle/#3-features","title":"3. Features","text":"<p>The Vehicle Interface component can provide the following features in functionality and capability:</p> <ul> <li> <p>Basic functions</p> <ul> <li>Converting Autoware control commands to vehicle specific command</li> <li>Converting vehicle specific status information (velocity, steering) to Autoware status message</li> </ul> </li> </ul> <ul> <li>Diagnostics<ul> <li>List available features</li> <li>Provide a warning if the Control component tries to use a feature that is not available in the Vehicle Interface component</li> </ul> </li> </ul> <p>Additional functionality and capability features may be added, depending on the vehicle hardware. Some example features are listed below:</p> <ul> <li>Safety features<ul> <li>Disengage autonomous driving via manual intervention.<ul> <li>This can be done through the use of an emergency disengage button, or by a safety driver manually turning the steering wheel or pressing the brake</li> </ul> </li> </ul> </li> <li>Optional controls<ul> <li>Turn indicator</li> <li>Handbrake</li> <li>Headlights</li> <li>Hazard lights</li> <li>Doors</li> <li>Horn</li> <li>Wipers</li> </ul> </li> </ul>"},{"location":"design/autoware-architecture/vehicle/#4-interface-and-data-structure","title":"4. Interface and Data Structure","text":"<p>The interface of the Vehicle Interface component for other components running in the same process space to access the functionality and capability of the Vehicle Interface component is defined as follows.</p> <p>From Control</p> <ul> <li>Actuation Command<ul> <li>target acceleration, braking, and steering angle</li> </ul> </li> </ul> <p>From Planning</p> <ul> <li>Vehicle Specific Commands (optional and a separate message for each type)<ul> <li>Shift</li> <li>Door</li> <li>Wiper</li> <li>etc</li> </ul> </li> </ul> <p>From the vehicle</p> <ul> <li>Vehicle status messages<ul> <li>Vehicle-specific format messages for conversion into Autoware-specific format messages<ul> <li>Velocity status</li> <li>Steering status (optional)</li> <li>Shift status (optional)</li> <li>Turn signal status (optional)</li> <li>Actuation status (optional)</li> </ul> </li> </ul> </li> </ul> <p>The output interface of the Vehicle Interface component:</p> <ul> <li>Vehicle control messages to the vehicle<ul> <li>Control signals to drive the vehicle</li> <li>Depends on the vehicle type/protocol, but should include steering and velocity commands at a minimum</li> </ul> </li> <li>Vehicle status messages to Autoware</li> <li>Actuation Status<ul> <li>Acceleration, brake, steering status</li> </ul> </li> <li>Vehicle odometry (output to Localization)<ul> <li>Vehicle twist information</li> </ul> </li> <li>Control mode<ul> <li>Information about whether the vehicle is under autonomous control or manual control</li> </ul> </li> <li>Shift status (optional)<ul> <li>Vehicle shift status</li> </ul> </li> <li>Turn signal status (optional)<ul> <li>Vehicle turn signal status</li> </ul> </li> </ul> <p>The data structure for the internal representation of semantics for the objects and trajectories used in the Vehicle Interface component is defined as follows:</p>"},{"location":"design/autoware-architecture/vehicle/#5-concerns-assumptions-and-limitations","title":"5. Concerns, Assumptions, and Limitations","text":"<p>Concerns</p> <ul> <li>Architectural trade-offs and scalability</li> </ul> <p>Assumptions</p> <p>-</p> <p>Limitations</p>"},{"location":"design/autoware-architecture/vehicle/#6-examples-of-accuracy-requirements-by-odd","title":"6. Examples of accuracy requirements by ODD","text":""},{"location":"design/autoware-concepts/","title":"Autoware concepts","text":""},{"location":"design/autoware-concepts/#autoware-concepts","title":"Autoware concepts","text":"<p>Autoware is the world\u2019s first open-source software for autonomous driving systems. Autoware provides value for both The technology developers of autonomous driving systems can create new components based on Autoware. The service operators of autonomous driving systems, on the other hand, can select appropriate technology components with Autoware. This is enabled by the microautonomy architecture that modularizes its software stack into the core and universe subsystems (modules).</p>"},{"location":"design/autoware-concepts/#microautonomy-architecture","title":"Microautonomy architecture","text":"<p>Autoware uses a pipeline architecture to enable the development of autonomous driving systems. The pipeline architecture used in Autoware consists of components similar to three-layer-architecture. And they run in parallel. There are 2 main modules: the Core and the Universe. The components in these modules are designed to be extensible and reusable. And we call it microautonomy architecture.</p> <p></p>"},{"location":"design/autoware-concepts/#the-core-module","title":"The Core module","text":"<p>The Core module contains basic runtimes and technology components that satisfy the basic functionality and capability of sensing, computing, and actuation required for autonomous driving systems. AWF develops and maintains the Core module with their architects and leading members through their working groups. Anyone can contribute to the Core but the PR(Pull Request) acceptance criteria is more strict compared to the Universe.</p>"},{"location":"design/autoware-concepts/#the-universe-module","title":"The Universe module","text":"<p>The Universe modules are extensions to the Core module that can be provided by the technology developers to enhance the functionality and capability of sensing, computing, and actuation. AWF provides the base Universe module to extend from. A key feature of the microautonomy architecture is that the Universe modules can be contributed to by any organization and individual. That is, you can even create your Universe and make it available for the Autoware community and ecosystem. AWF is responsible for quality control of the Universe modules through their development process. As a result, there are multiple types of the Universe modules - some are verified and validated by AWF and others are not. It is up to the users of Autoware which Universe modules are selected and integrated to build their end applications.</p>"},{"location":"design/autoware-concepts/#interface-design","title":"Interface design","text":"<p>The interface design is the most essential piece of the microautonomy architecture, which is classified into internal and external interfaces. The component interface is designed for the components in a Universe module to communicate with those in other modules, including the Core module, within Autoware internally. The AD(Autonomous Driving) API, on the other hand, is designed for the applications of Autoware to access the technology components in the Core and Universe modules of Autoware externally. Designing solid interfaces, the microautonomy architecture is made possible with AWF's partners, and at the same time is made feasible for the partners.</p>"},{"location":"design/autoware-concepts/#challenges","title":"Challenges","text":"<p>A grand challenge of the microautonomy architecture is to achieve real-time capability, which guarantees all the technology components activated in the system to predictably meet timing constraints (given deadlines). In general, it is difficult, if not impossible, to tightly estimate the worst-case execution times (WCETs) of components.</p> <p>In addition, it is also difficult, if not impossible, to tightly estimate the end-to-end latency of components connected by a DAG. Autonomous driving systems based on the microautonomy architecture, therefore, must be designed to be fail-safe but not never-fail. We accept that the timing constraints may be violated (the given deadlines may be missed) as far as the overrun is taken into account. The overrun handlers are two-fold: (i) platform-defined and (ii) user-defined. The platform-defined handler is implemented as part of the platform by default, while the user-defined handler can overwrite it or add a new handler to the system. This is what we call \u201cfail-safe\u201d on a timely basis.</p>"},{"location":"design/autoware-concepts/#requirements-and-roadmap","title":"Requirements and roadmap","text":"<p>Goals:</p> <ul> <li>All open-source</li> <li>Use case driven</li> <li>Real-time (predictable) framework with overrun handling</li> <li>Code quality</li> </ul>"},{"location":"design/autoware-concepts/difference-from-ai-and-auto/","title":"How is Autoware Core/Universe different from Autoware.AI and Autoware.Auto?","text":""},{"location":"design/autoware-concepts/difference-from-ai-and-auto/#how-is-autoware-coreuniverse-different-from-autowareai-and-autowareauto","title":"How is Autoware Core/Universe different from Autoware.AI and Autoware.Auto?","text":"<p>Autoware is the world's first \"all-in-one\" open-source software for self-driving vehicles. Since it was first released in 2015, there have been multiple releases made with differing underlying concepts, each one aimed at improving the software.</p>"},{"location":"design/autoware-concepts/difference-from-ai-and-auto/#autowareai","title":"Autoware.AI","text":"<p>Autoware.AI is the first distribution of Autoware that was released based on ROS 1. The repository contains a variety of packages covering different aspects of autonomous driving technologies - sensing, actuation, localization, mapping, perception and planning.</p> <p>While it was successful in attracting many developers and contributions, it was difficult to improve Autoware.AI's capabilities for a number of reasons:</p> <ul> <li>A lack of concrete architecture design leading to a lot of built-up technical debt, such as tight coupling between modules and unclear module responsibility.</li> <li>Differing coding standards for each package, with very low test coverage.</li> </ul> <p>Furthermore, there was no clear definition of the conditions under which an Autoware-enabled autonomous vehicle could operate, nor of the use cases or situations supported (eg: the ability to overtake a stationary vehicle).</p> <p>From the lessons learned from Autoware.AI development, a different development process was taken for Autoware.Auto to develop a ROS 2 version of Autoware.</p> <p>Warning</p> <p>Autoware.AI is currently in maintenance mode and will reach end-of-life at the end of 2022.</p>"},{"location":"design/autoware-concepts/difference-from-ai-and-auto/#autowareauto","title":"Autoware.Auto","text":"<p>Autoware.Auto is the second distribution of Autoware that was released based on ROS 2. As part of the transition to ROS 2, it was decided to avoid simply porting Autoware.AI from ROS 1 to ROS 2. Instead, the codebase was rewritten from scratch with proper engineering practices, including defining target use cases and ODDs (eg: Autonomous Valet Parking [AVP], Cargo Delivery, etc.), designing a proper architecture, writing design documents and test code.</p> <p>Autoware.Auto development seemed to work fine initially, but after completing the AVP and and Cargo Delivery ODD projects, we started to see the following issues:</p> <ul> <li>The barrier to new engineers was too high.<ul> <li>A lot of work was required to merge new features into Autoware.Auto, and so it was difficult for researchers and students to contribute to development.</li> <li>As a consequence, most Autoware.Auto developers were from companies in the Autoware Foundation and so there were very few people who were able to add state-of-the-art features from research papers.</li> </ul> </li> <li>Making large-scale architecture changes was too difficult.<ul> <li>To try out experimental architecture, there was a very large overhead involved in keeping the main branch stable whilst also making sure that every change satisfied the continuous integration requirements.</li> </ul> </li> </ul>"},{"location":"design/autoware-concepts/difference-from-ai-and-auto/#autoware-coreuniverse","title":"Autoware Core/Universe","text":"<p>In order to address the issues with Autoware.Auto development, the Autoware Foundation decided to create a new architecture called Autoware Core/Universe.</p> <p>Autoware Core carries over the original policy of Autoware.Auto to be a stable and well-tested codebase. Alongside Autoware Core is a new concept called Autoware Universe, which acts as an extension of Autoware Core with the following benefits:</p> <ul> <li>Users can easily replace a Core component with a Universe equivalent in order to use more advanced features, such as a new Localization or Perception algorithm.</li> <li>Code quality requirements for Universe are more relaxed to make it easier for new developers, students and researchers to contribute, but will still be stricter than the requirements for Autoware.AI.</li> <li>Any advanced features added to Universe that are useful to the wider Autoware community will be reviewed and considered for potential inclusion in the main Autoware Core codebase.</li> </ul> <p>This way, the primary requirement of having a stable and safe autonomous driving system can be achieved, whilst simultaneously enabling access to state-of-the-art features created by third-party contributors. For more details about the design of Autoware Core/Universe, refer to the Autoware concepts documentation page.</p>"},{"location":"design/autoware-interfaces/","title":"Autoware interface design","text":""},{"location":"design/autoware-interfaces/#autoware-interface-design","title":"Autoware interface design","text":""},{"location":"design/autoware-interfaces/#abstract","title":"Abstract","text":"<p>Autoware defines three categories of interfaces. The first one is Autoware AD API for operating the vehicle from outside the autonomous driving system such as the Fleet Management System (FMS) and Human Machine Interface (HMI) for operators or passengers. The second one is Autoware component interface for components to communicate with each other. The last one is the local interface used inside the component.</p>"},{"location":"design/autoware-interfaces/#concept","title":"Concept","text":"<ul> <li> <p>Applications can operate multiple and various vehicles in a common way.</p> <p></p> </li> </ul> <ul> <li> <p>Applications are not affected by version updates and implementation changes.</p> <p></p> </li> </ul> <ul> <li> <p>Developers only need to know the interface to add new features and hardware.</p> <p></p> </li> </ul>"},{"location":"design/autoware-interfaces/#requirements","title":"Requirements","text":"<p>Goals:</p> <ul> <li>AD API provides functionality to create the following applications:<ul> <li>Drive the vehicle on the route or drive to the requested positions in order.</li> <li>Operate vehicle behavior such as starting and stopping.</li> <li>Display or announce the vehicle status to operators, passengers, and people around.</li> <li>Control vehicle devices such as doors.</li> <li>Monitor the vehicle or drive it manually.</li> </ul> </li> <li>AD API provides stable and long-term specifications. This enables unified access to all vehicles.</li> <li>AD API hides differences in version and implementation and absorbs the impact of changes.</li> <li>AD API has a default implementation and can be applied to some simple ODDs with options.</li> <li>The AD API implementation is extensible with the third-party components as long as it meets the specifications.</li> <li>The component interface provides stable and medium-term specifications. This makes it easier to add components.</li> <li>The component interface clarifies the public and private parts of a component and improves maintainability.</li> <li>The component interface is extensible with the third-party design to improve the sub-components' reusability.</li> </ul> <p>Non-goals:</p> <ul> <li>AD API does not cover security. Use it with other reliable methods.</li> <li>The component interface is just a specification, it does not include an implementation.</li> </ul>"},{"location":"design/autoware-interfaces/#architecture","title":"Architecture","text":"<p>The components of Autoware are connected via the component interface. Each component uses the interface to provide functionality and to access other components. AD API implementation is also a component. Since the functional elements required for AD API are defined as the component interface, other components do not need to consider AD API directly. Tools for evaluation and debugging, such as simulators, access both AD API and the component interface.</p> <p></p> <p>The component interface has a hierarchical specification. The top-level architecture consists of some components. Each component has some options of the next-level architecture. Developers select one of them when implementing the component. The simplest next-level architecture is monolithic. This is an all-in-one and black box implementation, and is suitable for small group development, prototyping, and very complex functions. Others are arbitrary architecture consists of sub-components and have advantages for large group development. A sub-component can be combined with others that adopt the same architecture. Third parties can define and publish their own architecture and interface for open source development. It is desirable to propose them for standardization if they are sufficiently evaluated.</p> <p></p>"},{"location":"design/autoware-interfaces/#features","title":"Features","text":""},{"location":"design/autoware-interfaces/#communication-methods","title":"Communication methods","text":"<p>As shown in the table below, interfaces are classified into four communication methods to define their behavior. Function Call is a request-response communication and is used for processing that requires immediate results. The others are publish-subscribe communication. Notification is used to process data that changes with some event, typically a callback. Streams handle continuously changing data. Reliable Stream expects all data to arrive without loss, Realtime Stream expects the latest data to arrive with low delay.</p> Communication Method ROS Implementation Optional Implementation Function Call Service HTTP Notification Topic (reliable, transient_local) MQTT (QoS=2, retain) Reliable Stream Topic (reliable, volatile) MQTT (QoS=2) Realtime Stream Topic (best_effort, volatile) MQTT (QoS=0) <p>These methods are provided as services or topics of ROS since Autoware is developed using ROS and mainly communicates with its packages. On the other hand, FMS and HMI are often implemented without ROS, Autoware is also expected to communicate with applications that do not use ROS. It is wasteful for each of these applications to have an adapter for Autoware, and a more suitable means of communication is required. HTTP and MQTT are suggested as additional options because these protocols are widely used and can substitute the behavior of services and topics. In that case, text formats such as JSON where field names are repeated in an array of objects, are inefficient and it is necessary to consider the serialization.</p>"},{"location":"design/autoware-interfaces/#naming-convention","title":"Naming convention","text":"<p>The name of the interface must be <code>/&lt;component name&gt;/api/&lt;interface name&gt;</code>, where <code>&lt;component name&gt;</code> is the name of the component. For an AD API component, omit this part and start with <code>/api</code>. The <code>&lt;interface name&gt;</code> is an arbitrary string separated by slashes. Note that this rule causes a restriction that the namespace <code>api</code> must not be used as a name other than AD API and the component interface.</p> <p>The following are examples of correct interface names for AD API and the component interface:</p> <ul> <li>/api/autoware/state</li> <li>/api/autoware/engage</li> <li>/planning/api/route/set</li> <li>/vehicle/api/status</li> </ul> <p>The following are examples of incorrect interface names for AD API and the component interface:</p> <ul> <li>/ad_api/autoware/state</li> <li>/autoware/engage</li> <li>/planning/route/set/api</li> <li>/vehicle/my_api/status</li> </ul>"},{"location":"design/autoware-interfaces/#logging","title":"Logging","text":"<p>It is recommended to log the interface for analysis of vehicle behavior. If logging is needed, rosbag is available for topics, and use logger in rclcpp or rclpy for services. Typically, create a wrapper for service and client classes that logs when a service is called.</p>"},{"location":"design/autoware-interfaces/#restrictions","title":"Restrictions","text":"<p>For each API, consider the restrictions such as following and describe them if necessary.</p> <p>Services:</p> <ul> <li>response time</li> <li>pre-condition</li> <li>post-condition</li> <li>execution order</li> <li>concurrent execution</li> </ul> <p>Topics:</p> <ul> <li>recommended delay range</li> <li>maximum delay</li> <li>recommended frequency range</li> <li>minimum frequency</li> <li>default frequency</li> </ul>"},{"location":"design/autoware-interfaces/#data-structure","title":"Data structure","text":""},{"location":"design/autoware-interfaces/#data-type-definition","title":"Data type definition","text":"<p>Do not share the types in AD API unless they are obviously the same to avoid changes in one API affecting another. Also, implementation-dependent types, including the component interface, should not be used in AD API for the same reason. Use the type in AD API in implementation, or create the same type and copy the data to convert the type.</p>"},{"location":"design/autoware-interfaces/#constants-and-enumeration","title":"Constants and enumeration","text":"<p>Since ROS don't support enumeration, use constants instead. The default value of type such as zero and empty string should not be used to detect that a variable is unassigned. Alternatively, assign it a dedicated name to indicate that it is undefined. If one type has multiple enumerations, comment on the correspondence between constants and variables. Do not use enumeration values directly, as assignments are subject to change when the version is updated.</p>"},{"location":"design/autoware-interfaces/#time-stamp","title":"Time stamp","text":"<p>Clarify what the timestamp indicates. for example, send time, measurement time, update time, etc. Consider having multiple timestamps if necessary. Use <code>std_msgs/msg/Header</code> when using ROS transform. Also consider whether the header is common to all data, independent for each data, or additional timestamp is required.</p>"},{"location":"design/autoware-interfaces/#request-header","title":"Request header","text":"<p>Currently, there is no required header.</p>"},{"location":"design/autoware-interfaces/#response-status","title":"Response status","text":"<p>The interfaces whose communication method is Function Call use a common response status to unify the error format. These interfaces should include a variable of ResponseStatus with the name status in the response. See autoware_adapi_v1_msgs/msg/ResponseStatus for details.</p>"},{"location":"design/autoware-interfaces/#concerns-assumptions-and-limitations","title":"Concerns, assumptions and limitations","text":"<ul> <li>The applications use the version information provided by AD API to check compatibility.   Unknown versions are also treated as available as long as the major versions match (excluding major version 0).   Compatibility between AD API and the component interface is assumed to be maintained by the version management system.</li> <li>If an unintended behavior of AD API is detected, the application should take appropriate action.   Autoware tries to keep working as long as possible, but it is not guaranteed to be safe.   Safety should be considered for the entire system, including the applications.</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/","title":"Autoware AD API","text":""},{"location":"design/autoware-interfaces/ad-api/#autoware-ad-api","title":"Autoware AD API","text":""},{"location":"design/autoware-interfaces/ad-api/#overview","title":"Overview","text":"<p>Autoware AD API is the interface for operating the vehicle from outside the autonomous driving system. See here for the overall interface design of Autoware.</p>"},{"location":"design/autoware-interfaces/ad-api/#user-stories","title":"User stories","text":"<p>The user stories are service scenarios that AD API assumes. AD API is designed based on these scenarios. Each scenario is realized by a combination of use cases described later. If there are scenarios that cannot be covered, please discuss adding a user story.</p> <ul> <li>Bus service</li> <li>Taxi service</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/#use-cases","title":"Use cases","text":"<p>Use cases are partial scenarios derived from the user story and generically designed. Service providers can combine these use cases to define user stories and check if AD API can be applied to their own scenarios.</p> <ul> <li>Launch and terminate</li> <li>Initialize the pose</li> <li>Change the operation mode</li> <li>Drive to the designated position</li> <li>Get on and get off</li> <li>Vehicle monitoring</li> <li>Vehicle operation</li> <li>System monitoring</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/#features","title":"Features","text":"<ul> <li>Interface</li> <li>Operation Mode</li> <li>Routing</li> <li>Localization</li> <li>Motion</li> <li>Planning</li> <li>Perception</li> <li>Fail-safe</li> <li>Vehicle status</li> <li>Vehicle doors</li> <li>Cooperation</li> <li>Heartbeat</li> <li>Diagnostics</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/release/","title":"Release notes","text":""},{"location":"design/autoware-interfaces/ad-api/release/#release-notes","title":"Release notes","text":""},{"location":"design/autoware-interfaces/ad-api/release/#v150","title":"v1.5.0","text":"<ul> <li>[New] Add /api/routing/change_route_points</li> <li>[New] Add /api/routing/change_route</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/release/#v140","title":"v1.4.0","text":"<ul> <li>[New] Add /api/vehicle/status</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/release/#v130","title":"v1.3.0","text":"<ul> <li>[New] Add heartbeat API</li> <li>[New] Add diagnostics API</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/release/#v120","title":"v1.2.0","text":"<ul> <li>[New] Add vehicle doors API</li> <li>[Change] Add pull-over constants to /api/fail_safe/mrm_state</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/release/#v110","title":"v1.1.0","text":"<ul> <li>[New] Add /api/fail_safe/mrm_state</li> <li>[New] Add /api/vehicle/dimensions</li> <li>[New] Add /api/vehicle/kinematics</li> <li>[Change] Add options to the routing API</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/release/#v100","title":"v1.0.0","text":"<ul> <li>[New] Add interface API</li> <li>[New] Add localization API</li> <li>[New] Add routing API</li> <li>[New] Add operation mode API</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/cooperation/","title":"Cooperation","text":""},{"location":"design/autoware-interfaces/ad-api/features/cooperation/#cooperation","title":"Cooperation","text":""},{"location":"design/autoware-interfaces/ad-api/features/cooperation/#related-api","title":"Related API","text":"<ul> <li>/api/planning/velocity_factors</li> <li>/api/planning/steering_factors</li> <li>/api/planning/cooperation/set_commands</li> <li>/api/planning/cooperation/set_policies</li> <li>/api/planning/cooperation/get_policies</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/cooperation/#description","title":"Description","text":"<p>Request to cooperate (RTC) is a feature that enables a human operator to support the decision in autonomous driving mode. Autoware usually drives the vehicle using its own decisions, but the operator may prefer to make their decisions in experiments and complex situations.</p> <p>The planning component manages each situation that requires decision as a scene. Each scene has an ID that doesn't change until the scene is completed or canceled. The operator can override the decision of the target scene using this ID. In practice, the user interface application can hides the specification of the ID and provides an abstracted interface to the operator.</p> <p>For example, in the situation in the diagram below, vehicle is expected to make two lane changes and turning left at the intersection. Therefore the planning component generates three scene instances for each required action, and each scene instance will wait for the decision to be made, in this case \"changing or keeping lane\" and \"turning left or waiting at the intersection\". Here Autoware decides not to change lanes a second time due to the obstacle, so the vehicle will stop there. However, operator could overwrite that decision through RTC function and force the lane change so that vehicle could reach to it's goal. Using RTC, the operator can override these decisions to continue driving the vehicle to the goal.</p> <p></p>"},{"location":"design/autoware-interfaces/ad-api/features/cooperation/#architecture","title":"Architecture","text":"<p>Modules that support RTC have the operator decision and cooperation policy in addition to the module decision as shown below. These modules use the merged decision that is determined by these values when planning vehicle behavior. See decisions section for details of these values. The cooperation policy is used when there is no operator decision and has a default value set by the system settings. If the module supports RTC, these information are available in velocity factors or steering factors as cooperation status.</p> <p></p>"},{"location":"design/autoware-interfaces/ad-api/features/cooperation/#sequence","title":"Sequence","text":"<p>This is an example sequence that overrides the scene decision to force a lane change. It is for the second scene in the diagram in the architecture section. Here let's assume the cooperation policy is set to optional, see the decisions section described later for details.</p> <ol> <li>A planning module creates a scene instance with unique ID when approaching a place where a lane change is needed.</li> <li>The scene instance generates the module decision from the current situation. In this case, the module decision is not to do a lane change due to the obstacle.</li> <li>The scene instance generates the merged decision. At this point, there is no operator decision yet, so it is based on the module decision.</li> <li>The scene instance plans the vehicle to keep the lane according to the merged decision.</li> <li>The scene instance sends a cooperation status.</li> <li>The operator receives the cooperation status.</li> <li>The operator sends a cooperation command to override the module decision and to do a lane change.</li> <li>The scene instance receives the cooperation command and update the operator decision.</li> <li>The scene instance updates the module decision from the current situation.</li> <li>The scene instance updates the merged decision. It is based on the operator decision received.</li> <li>The scene instance plans the vehicle to change the lane according to the merged decision.</li> </ol>"},{"location":"design/autoware-interfaces/ad-api/features/cooperation/#decisions","title":"Decisions","text":"<p>The merged decision is determined by the module decision, operator decision, and cooperation policy, each of which takes the value shown in the table below.</p> Status Values merged decision deactivate, activate module decision deactivate, activate operator decision deactivate, activate, autonomous, none cooperation policy required, optional <p>The meanings of these values are as follows. Note that the cooperation policy is common per module, so changing it will affect all scenes in the same module.</p> Value Description deactivate An operator/module decision to plan vehicle behavior with priority on safety. activate An operator/module decision to plan vehicle behavior with priority on driving. autonomous An operator decision that follows the module decision. none An initial value for operator decision, indicating that there is no operator decision yet. required A policy that requires the operator decision to continue driving. optional A policy that does not require the operator decision to continue driving. <p>The following flow is how the merged decision is determined.</p> <p></p>"},{"location":"design/autoware-interfaces/ad-api/features/cooperation/#examples","title":"Examples","text":"<p>This is an example of cooperation for lane change module. The behaviors by the combination of decisions are as follows.</p> Operator decision Policy Module decision Description deactivate - - The operator instructs to keep lane regardless the module decision. So the vehicle keeps the lane by the operator decision. activate - - The operator instructs to change lane regardless the module decision. So the vehicle changes the lane by the operator decision. autonomous - deactivate The operator instructs to follow the module decision. So the vehicle keeps the lane by the module decision. autonomous - activate The operator instructs to follow the module decision. So the vehicle changes the lane by the module decision. none required - The required policy is used because no operator instruction. So the vehicle keeps the lane by the cooperation policy. none optional deactivate The optional policy is used because no operator instruction. So the vehicle keeps the lane by the module decision. none optional activate The optional policy is used because no operator instruction. So the vehicle change the lane by the module decision."},{"location":"design/autoware-interfaces/ad-api/features/diagnostics/","title":"Diagnostics","text":""},{"location":"design/autoware-interfaces/ad-api/features/diagnostics/#diagnostics","title":"Diagnostics","text":""},{"location":"design/autoware-interfaces/ad-api/features/diagnostics/#related-api","title":"Related API","text":"<ul> <li>/api/system/diagnostics/struct</li> <li>/api/system/diagnostics/status</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/diagnostics/#description","title":"Description","text":"<p>This API provides a diagnostic graph consisting of error levels for functional units of Autoware. The system groups functions into arbitrary units depending on configuration and diagnoses their error levels. Each functional unit has dependencies, so the whole looks like a fault tree analysis (FTA). In practice, it becomes a directed acyclic graph (DAG) because multiple parents may share the same child. Below is an example of the diagnostics provided by this API. The <code>path</code> in the diagram is an arbitrary string that describes the functional unit, and the <code>level</code> is its error level. For error level, the same value as <code>diagnostic_msgs/msg/DiagnosticStatus</code> is used.</p> <p></p> <p>The diagnostics data has static and dynamic parts, so the API provides these separately for efficiency. Below is an example of a message that corresponds to the above diagram. The static part of the diagnostic is published only once as the DiagGraphStruct that contains nodes and links. The links specify dependencies between nodes by index into an array of nodes. The dynamic part of the diagnostic is published periodically as DiagGraphStatus. The status has an array of nodes of the same length as the struct, with the same index representing the same functional unit.</p> <p></p>"},{"location":"design/autoware-interfaces/ad-api/features/fail-safe/","title":"Fail-safe","text":""},{"location":"design/autoware-interfaces/ad-api/features/fail-safe/#fail-safe","title":"Fail-safe","text":""},{"location":"design/autoware-interfaces/ad-api/features/fail-safe/#related-api","title":"Related API","text":"<ul> <li>/api/fail_safe/mrm_state</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/fail-safe/#description","title":"Description","text":"<p>This API manages the behavior related to the abnormality of the vehicle. It provides the state of Request to Intervene (RTI), Minimal Risk Maneuver (MRM) and Minimal Risk Condition (MRC). As shown below, Autoware has the gate to switch between the command during normal operation and the command during abnormal operation. For safety, Autoware switches the operation to MRM when an abnormality is detected. Since the required behavior differs depending on the situation, MRM is implemented in various places as a specific mode in a normal module or as an independent module. The fail-safe module selects the behavior of MRM according to the abnormality and switches the gate output to that command.</p> <p></p>"},{"location":"design/autoware-interfaces/ad-api/features/fail-safe/#states","title":"States","text":"<p>The MRM state indicates whether MRM is operating. This state also provides success or failure. Generally, MRM will switch to another behavior if it fails.</p> <p></p> State Description NONE MRM is not operating. OPERATING MRM is operating because an abnormality has been detected. SUCCEEDED MRM succeeded. The vehicle is in a safe condition. FAILED MRM failed. The vehicle is still in an unsafe condition."},{"location":"design/autoware-interfaces/ad-api/features/fail-safe/#behavior","title":"Behavior","text":"<p>There is a dependency between MRM behaviors. For example, it switches from a comfortable stop to a emergency stop, but not the other way around. This is service dependent. Autoware supports the following transitions by default.</p> <p></p> State Description NONE MRM is not operating or is operating but no special behavior is required. COMFORTABLE_STOP The vehicle will stop quickly with a comfortable deceleration. EMERGENCY_STOP The vehicle will stop immediately with as much deceleration as possible. PULL_OVER The vehicle will stop after moving to the side of the road."},{"location":"design/autoware-interfaces/ad-api/features/heartbeat/","title":"Heartbeat","text":""},{"location":"design/autoware-interfaces/ad-api/features/heartbeat/#heartbeat","title":"Heartbeat","text":""},{"location":"design/autoware-interfaces/ad-api/features/heartbeat/#related-api","title":"Related API","text":"<ul> <li>/api/system/heartbeat</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/heartbeat/#description","title":"Description","text":"<p>This API is used to check whether applications and Autoware are communicating properly. The message contains timestamp and sequence number to check for communication delays, order, and losses.</p>"},{"location":"design/autoware-interfaces/ad-api/features/interface/","title":"Interface","text":""},{"location":"design/autoware-interfaces/ad-api/features/interface/#interface","title":"Interface","text":""},{"location":"design/autoware-interfaces/ad-api/features/interface/#related-api","title":"Related API","text":"<ul> <li>/api/interface/version</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/interface/#description","title":"Description","text":"<p>This API provides the interface version of the set of AD APIs. It follows Semantic Versioning in order to provide an intuitive understanding of the changes between versions.</p>"},{"location":"design/autoware-interfaces/ad-api/features/localization/","title":"Localization","text":""},{"location":"design/autoware-interfaces/ad-api/features/localization/#localization","title":"Localization","text":""},{"location":"design/autoware-interfaces/ad-api/features/localization/#related-api","title":"Related API","text":"<ul> <li>/api/localization/initialization_state</li> <li>/api/localization/initialize</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/localization/#description","title":"Description","text":"<p>This API manages the initialization of localization. Autoware requires a global pose as the initial guess for localization.</p>"},{"location":"design/autoware-interfaces/ad-api/features/localization/#states","title":"States","text":"State Description UNINITIALIZED Localization is not initialized. Waiting for a global pose as the initial guess. INITIALIZING Localization is initializing. INITIALIZED Localization is initialized. Initialization can be requested again if necessary."},{"location":"design/autoware-interfaces/ad-api/features/motion/","title":"Motion","text":""},{"location":"design/autoware-interfaces/ad-api/features/motion/#motion","title":"Motion","text":""},{"location":"design/autoware-interfaces/ad-api/features/motion/#related-api","title":"Related API","text":"<ul> <li>/api/motion/state</li> <li>/api/motion/accept_start</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/motion/#description","title":"Description","text":"<p>This API manages the current behavior of the vehicle. Applications can notify the vehicle behavior to the people around and visualize it for operator and passengers.</p>"},{"location":"design/autoware-interfaces/ad-api/features/motion/#states","title":"States","text":"<p>The motion state manages the stop and start of the vehicle. Once the vehicle has stopped, the state will be STOPPED. After this, when the vehicle tries to start (is still stopped), the state will be STARTING. In this state, calling the start API changes the state to MOVING and the vehicle starts. This mechanism can add processing such as announcements before the vehicle starts. Depending on the configuration, the state may transition directly from STOPPED to MOVING.</p> <p></p> State Description STOPPED The vehicle is stopped. STARTING The vehicle is stopped, but is trying to start. MOVING The vehicle is moving. BRAKING (T.B.D.) The vehicle is decelerating strongly."},{"location":"design/autoware-interfaces/ad-api/features/operation_mode/","title":"Operation mode","text":""},{"location":"design/autoware-interfaces/ad-api/features/operation_mode/#operation-mode","title":"Operation mode","text":""},{"location":"design/autoware-interfaces/ad-api/features/operation_mode/#related-api","title":"Related API","text":"<ul> <li>/api/operation_mode/state</li> <li>/api/operation_mode/change_to_autonomous</li> <li>/api/operation_mode/change_to_stop</li> <li>/api/operation_mode/change_to_local</li> <li>/api/operation_mode/change_to_remote</li> <li>/api/operation_mode/enable_autoware_control</li> <li>/api/operation_mode/disable_autoware_control</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/operation_mode/#description","title":"Description","text":"<p>As shown below, Autoware assumes that the vehicle interface has two modes, Autoware control and direct control. In direct control mode, the vehicle is operated using devices such as steering and pedals. If the vehicle does not support direct control mode, it is always treated as Autoware control mode. Autoware control mode has four operation modes.</p> Mode Description Stop Keep the vehicle stopped. Autonomous Autonomously control the vehicle. Local Manually control the vehicle from nearby with some device such as a joystick. Remote Manually control the vehicle from a web application on the cloud. <p></p>"},{"location":"design/autoware-interfaces/ad-api/features/operation_mode/#states","title":"States","text":""},{"location":"design/autoware-interfaces/ad-api/features/operation_mode/#autoware-control-flag","title":"Autoware control flag","text":"<p>The flag <code>is_autoware_control_enabled</code> indicates if the vehicle is controlled by Autoware. The enable and disable APIs can be used if the control can be switched by software. These APIs will always fail if the vehicle does not support mode switching or is switched by hardware.</p>"},{"location":"design/autoware-interfaces/ad-api/features/operation_mode/#operation-mode-and-change-flags","title":"Operation mode and change flags","text":"<p>The state <code>operation_mode</code> indicates what command is used when Autoware control is enabled. The flags <code>change_to_*</code> can be used to check if it is possible to transition to each mode.</p>"},{"location":"design/autoware-interfaces/ad-api/features/operation_mode/#transition-flag","title":"Transition flag","text":"<p>Since Autoware may not be able to guarantee safety, such as switching to autonomous mode during overspeed. There is the flag <code>is_in_transition</code> for this situation and it will be true when changing modes. The operator who changed the mode should ensure safety while this flag is true. The flag will be false when the mode change is complete.</p>"},{"location":"design/autoware-interfaces/ad-api/features/perception/","title":"Perception","text":""},{"location":"design/autoware-interfaces/ad-api/features/perception/#perception","title":"Perception","text":""},{"location":"design/autoware-interfaces/ad-api/features/perception/#related-api","title":"Related API","text":"<ul> <li>/api/perception/objects</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/perception/#description","title":"Description","text":"<p>API for perception related topic.</p>"},{"location":"design/autoware-interfaces/ad-api/features/planning-factors/","title":"Planning factors","text":""},{"location":"design/autoware-interfaces/ad-api/features/planning-factors/#planning-factors","title":"Planning factors","text":""},{"location":"design/autoware-interfaces/ad-api/features/planning-factors/#related-api","title":"Related API","text":"<ul> <li>/api/planning/velocity_factors</li> <li>/api/planning/steering_factors</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/planning-factors/#description","title":"Description","text":"<p>This API manages the planned behavior of the vehicle. Applications can notify the vehicle behavior to the people around and visualize it for operator and passengers.</p>"},{"location":"design/autoware-interfaces/ad-api/features/planning-factors/#velocity-factors","title":"Velocity factors","text":"<p>The velocity factors is an array of information on the behavior that the vehicle stops or slows down. Each factor has a behavior type which is described below. Some behavior types have sequence and details as additional information.</p> Behavior Description surrounding-obstacle There are obstacles immediately around the vehicle. route-obstacle There are obstacles along the route ahead. intersection There are obstacles in other lanes in the path. crosswalk There are obstacles on the crosswalk. rear-check There are obstacles behind that would be in a human driver's blind spot. user-defined-attention-area There are obstacles in the predefined attention area. no-stopping-area There is not enough space beyond the no stopping area. stop-sign A stop by a stop sign. traffic-signal A stop by a traffic signal. v2x-gate-area A stop by a gate area. It has enter and leave as sequences and v2x type as details. merge A stop before merging lanes. sidewalk A stop before crossing the sidewalk. lane-change A lane change. avoidance A path change to avoid an obstacle in the current lane. emergency-operation A stop by emergency instruction from the operator. <p>Each factor also provides status, poses in the base link frame, and distance from that pose. As the vehicle approaches the stop position, this factor appears with a status of APPROACHING. And when the vehicle reaches that position and stops, the status will be STOPPED. The pose indicates the stop position, or the base link if the stop position cannot be calculated.</p> <p></p>"},{"location":"design/autoware-interfaces/ad-api/features/planning-factors/#steering-factors","title":"Steering factors","text":"<p>The steering factors is an array of information on the maneuver that requires use of turn indicators, such as turning left or right. Each factor has a behavior type which is described below and steering direction. Some behavior types have sequence and details as additional information.</p> Behavior Description intersection A turning left or right at an intersection. lane-change A lane change. avoidance A path change to avoid an obstacle. It has a sequence of change and return. start-planner T.B.D. goal-planner T.B.D. emergency-operation A path change by emergency instruction from the operator. <p>Each factor also provides status, poses in the base link frame, and distances from that poses. As the vehicle approaches the position to start steering, this factor appears with a status of APPROACHING. And when the vehicle reaches that position, the status will be TURNING. The poses indicate the start and end position of the section where the status is TURNING.</p> <p></p> <p>In cases such as lane change and avoidance, the vehicle will start steering at any position in the range depending on the situation. For these types, the section where the status is TURNING will be updated dynamically and the poses will follow that.</p> <p></p>"},{"location":"design/autoware-interfaces/ad-api/features/routing/","title":"Routing","text":""},{"location":"design/autoware-interfaces/ad-api/features/routing/#routing","title":"Routing","text":""},{"location":"design/autoware-interfaces/ad-api/features/routing/#related-api","title":"Related API","text":"<ul> <li>/api/routing/state</li> <li>/api/routing/route</li> <li>/api/routing/clear_route</li> <li>/api/routing/set_route_points</li> <li>/api/routing/set_route</li> <li>/api/routing/change_route_points</li> <li>/api/routing/change_route</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/routing/#description","title":"Description","text":"<p>This API manages destination and waypoints. Note that waypoints are not like stops and just points passing through. In other words, Autoware does not support the route with multiple stops, the application needs to split it up and switch them. There are two ways to set the route. The one is a generic method that uses pose, another is a map-dependent.</p>"},{"location":"design/autoware-interfaces/ad-api/features/routing/#states","title":"States","text":"State Description UNSET The route is not set. Waiting for a route request. SET The route is set. ARRIVED The vehicle has arrived at the destination. CHANGING Trying to change the route."},{"location":"design/autoware-interfaces/ad-api/features/routing/#options","title":"Options","text":"<p>The route set and change APIs have route options that allow applications to choose several behaviors regarding route planning. See the sections below for supported options and details.</p>"},{"location":"design/autoware-interfaces/ad-api/features/routing/#allow_goal_modification","title":"allow_goal_modification","text":"<p>[v1.1.0] Autoware tries to look for an alternate goal when goal is unreachable (e.g., when there is an obstacle on the given goal). When setting a route from the API, applications can choose whether they allow Autoware to adjust goal pose in such situation. When set false, Autoware may get stuck until the given goal becomes reachable.</p>"},{"location":"design/autoware-interfaces/ad-api/features/vehicle-doors/","title":"Vehicle doors","text":""},{"location":"design/autoware-interfaces/ad-api/features/vehicle-doors/#vehicle-doors","title":"Vehicle doors","text":""},{"location":"design/autoware-interfaces/ad-api/features/vehicle-doors/#related-api","title":"Related API","text":"<ul> <li>/api/vehicle/doors/layout</li> <li>/api/vehicle/doors/status</li> <li>/api/vehicle/doors/command</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/vehicle-doors/#description","title":"Description","text":"<p>This feature is available if the vehicle provides a software interface for the doors. It can be used to create user interfaces for passengers or to control sequences at bus stops.</p>"},{"location":"design/autoware-interfaces/ad-api/features/vehicle-doors/#layout","title":"Layout","text":"<p>Each door in a vehicle is assigned an array index. This assignment is vehicle dependent. The layout API returns this information. The description field is a string to display in the user interface, etc. This is an arbitrary string and is not recommended to use for processing in applications. Use the roles field to know doors for getting on and off. Below is an example of the information returned by the layout API.</p> Index Description Roles 0 front right - 1 front left GET_ON 2 rear right GET_OFF 3 rear left GET_ON, GET_OFF"},{"location":"design/autoware-interfaces/ad-api/features/vehicle-doors/#status","title":"Status","text":"<p>The status API provides an array of door status. This array order is consistent with the layout API.</p>"},{"location":"design/autoware-interfaces/ad-api/features/vehicle-doors/#control","title":"Control","text":"<p>Use the command API to control doors. Unlike the status and layout APIs, array index do not correspond to doors. The command has a field to specify the target door index.</p>"},{"location":"design/autoware-interfaces/ad-api/features/vehicle-status/","title":"Vehicle status","text":""},{"location":"design/autoware-interfaces/ad-api/features/vehicle-status/#vehicle-status","title":"Vehicle status","text":""},{"location":"design/autoware-interfaces/ad-api/features/vehicle-status/#related-api","title":"Related API","text":"<ul> <li>/api/vehicle/kinematics</li> <li>/api/vehicle/status</li> <li>/api/vehicle/dimensions</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/features/vehicle-status/#kinematics","title":"Kinematics","text":"<p>This is an estimate of the vehicle kinematics. The vehicle position is necessary for applications to schedule dispatches. Also, using velocity and acceleration, applications can find vehicles that need operator assistance, such as stuck or brake suddenly.</p>"},{"location":"design/autoware-interfaces/ad-api/features/vehicle-status/#status","title":"Status","text":"<p>This is the status provided by the vehicle. The indicators and steering are mainly used for visualization and remote control. The remaining energy can be also used for vehicle scheduling.</p>"},{"location":"design/autoware-interfaces/ad-api/features/vehicle-status/#dimensions","title":"Dimensions","text":"<p>The vehicle dimensions are used to know the actual distance between the vehicle and objects because the vehicle position in kinematics is the coordinates of the base link. This is necessary for visualization when supporting vehicles remotely.</p>"},{"location":"design/autoware-interfaces/ad-api/list/","title":"List of Autoware AD API","text":""},{"location":"design/autoware-interfaces/ad-api/list/#list-of-autoware-ad-api","title":"List of Autoware AD API","text":"API Release /api/fail_safe/mrm_state v1.1.0 /api/interface/version v1.0.0 /api/localization/initialization_state v1.0.0 /api/localization/initialize v1.0.0 /api/motion/accept_start not released /api/motion/state not released /api/operation_mode/change_to_autonomous v1.0.0 /api/operation_mode/change_to_local v1.0.0 /api/operation_mode/change_to_remote v1.0.0 /api/operation_mode/change_to_stop v1.0.0 /api/operation_mode/disable_autoware_control v1.0.0 /api/operation_mode/enable_autoware_control v1.0.0 /api/operation_mode/state v1.0.0 /api/perception/objects not released /api/planning/cooperation/get_policies not released /api/planning/cooperation/set_commands not released /api/planning/cooperation/set_policies not released /api/planning/steering_factors not released /api/planning/velocity_factors not released /api/routing/change_route v1.5.0 /api/routing/change_route_points v1.5.0 /api/routing/clear_route v1.0.0 /api/routing/route v1.0.0 /api/routing/set_route v1.0.0 /api/routing/set_route_points v1.0.0 /api/routing/state v1.0.0 /api/system/diagnostics/status v1.3.0 /api/system/diagnostics/struct v1.3.0 /api/system/heartbeat v1.3.0 /api/vehicle/dimensions v1.1.0 /api/vehicle/doors/command v1.2.0 /api/vehicle/doors/layout v1.2.0 /api/vehicle/doors/status v1.2.0 /api/vehicle/kinematics v1.1.0 /api/vehicle/status v1.4.0"},{"location":"design/autoware-interfaces/ad-api/list/api/fail_safe/mrm_state/","title":"/api/fail_safe/mrm_state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/fail_safe/mrm_state/#apifail_safemrm_state","title":"/api/fail_safe/mrm_state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/fail_safe/mrm_state/#status","title":"Status","text":"<ul> <li>Latest Version: v1.1.0</li> <li>Method: notification</li> <li>Data Type: autoware_adapi_v1_msgs/msg/MrmState</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/fail_safe/mrm_state/#description","title":"Description","text":"<p>Get the MRM state. For details, see the fail-safe.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/fail_safe/mrm_state/#message","title":"Message","text":"Name Type Description state uint16 The state of MRM operation. behavior uint16 The currently selected behavior of MRM."},{"location":"design/autoware-interfaces/ad-api/list/api/interface/version/","title":"/api/interface/version","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/interface/version/#apiinterfaceversion","title":"/api/interface/version","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/interface/version/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_version_msgs/srv/InterfaceVersion</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/interface/version/#description","title":"Description","text":"<p>Get the interface version. The version follows Semantic Versioning.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/interface/version/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/interface/version/#response","title":"Response","text":"Name Type Description major uint16 major version minor uint16 minor version patch uint16 patch version"},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialization_state/","title":"/api/localization/initialization_state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialization_state/#apilocalizationinitialization_state","title":"/api/localization/initialization_state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialization_state/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: notification</li> <li>Data Type: autoware_adapi_v1_msgs/msg/LocalizationInitializationState</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialization_state/#description","title":"Description","text":"<p>Get the initialization state of localization. For details, see the localization.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialization_state/#message","title":"Message","text":"Name Type Description state uint16 A value of the localization initialization state."},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialize/","title":"/api/localization/initialize","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialize/#apilocalizationinitialize","title":"/api/localization/initialize","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialize/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/InitializeLocalization</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialize/#description","title":"Description","text":"<p>Request to initialize localization. For details, see the localization.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialize/#request","title":"Request","text":"Name Type Description pose geometry_msgs/msg/PoseWithCovarianceStamped[&lt;=1] A global pose as the initial guess. If omitted, the GNSS pose will be used."},{"location":"design/autoware-interfaces/ad-api/list/api/localization/initialize/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/motion/accept_start/","title":"/api/motion/accept_start","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/motion/accept_start/#apimotionaccept_start","title":"/api/motion/accept_start","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/motion/accept_start/#status","title":"Status","text":"<ul> <li>Latest Version: not released</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/AcceptStart</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/motion/accept_start/#description","title":"Description","text":"<p>Accept the vehicle to start. This API can be used when the motion state is STARTING.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/motion/accept_start/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/motion/accept_start/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/motion/state/","title":"/api/motion/state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/motion/state/#apimotionstate","title":"/api/motion/state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/motion/state/#status","title":"Status","text":"<ul> <li>Latest Version: not released</li> <li>Method: notification</li> <li>Data Type: autoware_adapi_v1_msgs/msg/MotionState</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/motion/state/#description","title":"Description","text":"<p>Get the motion state. For details, see the motion state.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/motion/state/#message","title":"Message","text":"Name Type Description state uint16 A value of the motion state."},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_autonomous/","title":"/api/operation_mode/change_to_autonomous","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_autonomous/#apioperation_modechange_to_autonomous","title":"/api/operation_mode/change_to_autonomous","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_autonomous/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/ChangeOperationMode</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_autonomous/#description","title":"Description","text":"<p>Change the operation mode to autonomous. For details, see the operation mode.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_autonomous/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_autonomous/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_local/","title":"/api/operation_mode/change_to_local","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_local/#apioperation_modechange_to_local","title":"/api/operation_mode/change_to_local","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_local/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/ChangeOperationMode</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_local/#description","title":"Description","text":"<p>Change the operation mode to local. For details, see the operation mode.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_local/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_local/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_remote/","title":"/api/operation_mode/change_to_remote","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_remote/#apioperation_modechange_to_remote","title":"/api/operation_mode/change_to_remote","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_remote/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/ChangeOperationMode</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_remote/#description","title":"Description","text":"<p>Change the operation mode to remote. For details, see the operation mode.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_remote/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_remote/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_stop/","title":"/api/operation_mode/change_to_stop","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_stop/#apioperation_modechange_to_stop","title":"/api/operation_mode/change_to_stop","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_stop/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/ChangeOperationMode</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_stop/#description","title":"Description","text":"<p>Change the operation mode to stop. For details, see the operation mode.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_stop/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/change_to_stop/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/disable_autoware_control/","title":"/api/operation_mode/disable_autoware_control","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/disable_autoware_control/#apioperation_modedisable_autoware_control","title":"/api/operation_mode/disable_autoware_control","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/disable_autoware_control/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/ChangeOperationMode</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/disable_autoware_control/#description","title":"Description","text":"<p>Disable vehicle control by Autoware. For details, see the operation mode. This API fails if the vehicle does not support mode change by software.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/disable_autoware_control/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/disable_autoware_control/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/enable_autoware_control/","title":"/api/operation_mode/enable_autoware_control","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/enable_autoware_control/#apioperation_modeenable_autoware_control","title":"/api/operation_mode/enable_autoware_control","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/enable_autoware_control/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/ChangeOperationMode</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/enable_autoware_control/#description","title":"Description","text":"<p>Enable vehicle control by Autoware. For details, see the operation mode. This API fails if the vehicle does not support mode change by software.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/enable_autoware_control/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/enable_autoware_control/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/state/","title":"/api/operation_mode/state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/state/#apioperation_modestate","title":"/api/operation_mode/state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/state/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: notification</li> <li>Data Type: autoware_adapi_v1_msgs/msg/OperationModeState</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/state/#description","title":"Description","text":"<p>Get the operation mode state. For details, see the operation mode.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/operation_mode/state/#message","title":"Message","text":"Name Type Description mode uint8 The selected command for Autoware control. is_autoware_control_enabled bool True if vehicle control by Autoware is enabled. is_in_transition bool True if the operation mode is in transition. is_stop_mode_available bool True if the operation mode can be changed to stop. is_autonomous_mode_available bool True if the operation mode can be changed to autonomous. is_local_mode_available bool True if the operation mode can be changed to local. is_remote_mode_available bool True if the operation mode can be changed to remote."},{"location":"design/autoware-interfaces/ad-api/list/api/perception/objects/","title":"/api/perception/objects","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/perception/objects/#apiperceptionobjects","title":"/api/perception/objects","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/perception/objects/#status","title":"Status","text":"<ul> <li>Latest Version: not released</li> <li>Method: realtime stream</li> <li>Data Type: autoware_adapi_v1_msgs/msg/DynamicObjectArray</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/perception/objects/#description","title":"Description","text":"<p>Get the recognized objects array with label, shape, current position and predicted path For details, see the perception.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/perception/objects/#message","title":"Message","text":"Name Type Description objects.id unique_identifier_msgs/msg/UUID The UUID of each object objects.existence_probability float64 The probability of the object exits objects.classification autoware_adapi_v1_msgs/msg/ObjectClassification[] The type of the object recognized and the confidence level objects.kinematics autoware_adapi_v1_msgs/msg/DynamicObjectKinematics Consist of the object pose, twist, acceleration and the predicted_paths objects.shape shape_msgs/msg/SolidPrimitive escribe the shape of the object with dimension, and polygon"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/steering_factors/","title":"/api/planning/steering_factors","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/steering_factors/#apiplanningsteering_factors","title":"/api/planning/steering_factors","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/steering_factors/#status","title":"Status","text":"<ul> <li>Latest Version: not released</li> <li>Method: realtime stream</li> <li>Data Type: autoware_adapi_v1_msgs/msg/SteeringFactorArray</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/steering_factors/#description","title":"Description","text":"<p>Get the steering factors, sorted in ascending order of distance. For details, see the planning factors.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/steering_factors/#message","title":"Message","text":"Name Type Description factors.pose geometry_msgs/msg/Pose[2] The base link pose related to the steering factor. factors.distance float32[2] The distance from the base link to the above pose. factors.direction uint16 The direction of the steering factor. factors.status uint16 The status of the steering factor. factors.behavior string The behavior type of the steering factor. factors.sequence string The sequence type of the steering factor. factors.detail string The additional information of the steering factor. factors.cooperation autoware_adapi_v1_msgs/msg/CooperationStatus[&lt;=1] The cooperation status if the module supports."},{"location":"design/autoware-interfaces/ad-api/list/api/planning/velocity_factors/","title":"/api/planning/velocity_factors","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/velocity_factors/#apiplanningvelocity_factors","title":"/api/planning/velocity_factors","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/velocity_factors/#status","title":"Status","text":"<ul> <li>Latest Version: not released</li> <li>Method: realtime stream</li> <li>Data Type: autoware_adapi_v1_msgs/msg/VelocityFactorArray</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/velocity_factors/#description","title":"Description","text":"<p>Get the velocity factors, sorted in ascending order of distance. For details, see the planning factors.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/velocity_factors/#message","title":"Message","text":"Name Type Description factors.pose geometry_msgs/msg/Pose The base link pose related to the velocity factor. factors.distance float32 The distance from the base link to the above pose. factors.status uint16 The status of the velocity factor. factors.behavior string The behavior type of the velocity factor. factors.sequence string The sequence type of the velocity factor. factors.detail string The additional information of the velocity factor. factors.cooperation autoware_adapi_v1_msgs/msg/CooperationStatus[&lt;=1] The cooperation status if the module supports."},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/get_policies/","title":"/api/planning/cooperation/get_policies","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/get_policies/#apiplanningcooperationget_policies","title":"/api/planning/cooperation/get_policies","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/get_policies/#status","title":"Status","text":"<ul> <li>Latest Version: not released</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/GetCooperationPolicies</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/get_policies/#description","title":"Description","text":"<p>Get the default decision that is used instead when the operator's decision is undecided. For details, see the cooperation.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/get_policies/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/get_policies/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status policies.behavior string The type of the target behavior. policies.sequence string The type of the target sequence. policies.policy uint8 The type of the cooperation policy."},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_commands/","title":"/api/planning/cooperation/set_commands","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_commands/#apiplanningcooperationset_commands","title":"/api/planning/cooperation/set_commands","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_commands/#status","title":"Status","text":"<ul> <li>Latest Version: not released</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/SetCooperationCommands</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_commands/#description","title":"Description","text":"<p>Set the operator's decision for cooperation. For details, see the cooperation.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_commands/#request","title":"Request","text":"Name Type Description commands.uuid unique_identifier_msgs/msg/UUID The ID in the cooperation status. commands.cooperator autoware_adapi_v1_msgs/msg/CooperationDecision The operator's decision."},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_commands/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_policies/","title":"/api/planning/cooperation/set_policies","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_policies/#apiplanningcooperationset_policies","title":"/api/planning/cooperation/set_policies","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_policies/#status","title":"Status","text":"<ul> <li>Latest Version: not released</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/SetCooperationPolicies</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_policies/#description","title":"Description","text":"<p>Set the default decision that is used instead when the operator's decision is undecided. For details, see the cooperation.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_policies/#request","title":"Request","text":"Name Type Description policies.behavior string The type of the target behavior. policies.sequence string The type of the target sequence. policies.policy uint8 The type of the cooperation policy."},{"location":"design/autoware-interfaces/ad-api/list/api/planning/cooperation/set_policies/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route/","title":"/api/routing/change_route","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route/#apiroutingchange_route","title":"/api/routing/change_route","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route/#status","title":"Status","text":"<ul> <li>Latest Version: v1.5.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/SetRoute</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route/#description","title":"Description","text":"<p>Same as /api/routing/set_route, but change the route while driving. This API only accepts the route when the route state is SET. In any other state, set the route first or wait for the route change to complete.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route/#request","title":"Request","text":"Name Type Description header std_msgs/msg/Header header for pose transformation goal geometry_msgs/msg/Pose goal pose segments autoware_adapi_v1_msgs/msg/RouteSegment[] waypoint segments in lanelet format"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route_points/","title":"/api/routing/change_route_points","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route_points/#apiroutingchange_route_points","title":"/api/routing/change_route_points","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route_points/#status","title":"Status","text":"<ul> <li>Latest Version: v1.5.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/SetRoutePoints</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route_points/#description","title":"Description","text":"<p>Same as /api/routing/set_route_points, but change the route while driving. This API only accepts the route when the route state is SET. In any other state, set the route first or wait for the route change to complete.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route_points/#request","title":"Request","text":"Name Type Description header std_msgs/msg/Header header for pose transformation goal geometry_msgs/msg/Pose goal pose waypoints geometry_msgs/msg/Pose[] waypoint poses"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/change_route_points/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/clear_route/","title":"/api/routing/clear_route","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/clear_route/#apiroutingclear_route","title":"/api/routing/clear_route","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/clear_route/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/ClearRoute</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/clear_route/#description","title":"Description","text":"<p>Clear the route.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/clear_route/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/clear_route/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/route/","title":"/api/routing/route","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/route/#apiroutingroute","title":"/api/routing/route","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/route/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: notification</li> <li>Data Type: autoware_adapi_v1_msgs/msg/Route</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/route/#description","title":"Description","text":"<p>Get the route with the waypoint segments in lanelet format. It is empty if route is not set.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/route/#message","title":"Message","text":"Name Type Description header std_msgs/msg/Header header for pose transformation data autoware_adapi_v1_msgs/msg/RouteData[&lt;=1] The route in lanelet format"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route/","title":"/api/routing/set_route","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route/#apiroutingset_route","title":"/api/routing/set_route","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/SetRoute</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route/#description","title":"Description","text":"<p>Set the route with the waypoint segments in lanelet format. If start pose is not specified, the current pose will be used. This API only accepts the route when the route state is UNSET. In any other state, clear the route first.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route/#request","title":"Request","text":"Name Type Description header std_msgs/msg/Header header for pose transformation goal geometry_msgs/msg/Pose goal pose segments autoware_adapi_v1_msgs/msg/RouteSegment[] waypoint segments in lanelet format"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route_points/","title":"/api/routing/set_route_points","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route_points/#apiroutingset_route_points","title":"/api/routing/set_route_points","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route_points/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/SetRoutePoints</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route_points/#description","title":"Description","text":"<p>Set the route with the waypoint poses. If start pose is not specified, the current pose will be used. This API only accepts the route when the route state is UNSET. In any other state, clear the route first.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route_points/#request","title":"Request","text":"Name Type Description header std_msgs/msg/Header header for pose transformation goal geometry_msgs/msg/Pose goal pose waypoints geometry_msgs/msg/Pose[] waypoint poses"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/set_route_points/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/state/","title":"/api/routing/state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/state/#apiroutingstate","title":"/api/routing/state","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/routing/state/#status","title":"Status","text":"<ul> <li>Latest Version: v1.0.0</li> <li>Method: notification</li> <li>Data Type: autoware_adapi_v1_msgs/msg/RouteState</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/state/#description","title":"Description","text":"<p>Get the route state. For details, see the routing.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/routing/state/#message","title":"Message","text":"Name Type Description state uint16 A value of the route state."},{"location":"design/autoware-interfaces/ad-api/list/api/system/heartbeat/","title":"/api/system/heartbeat","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/system/heartbeat/#apisystemheartbeat","title":"/api/system/heartbeat","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/system/heartbeat/#status","title":"Status","text":"<ul> <li>Latest Version: v1.3.0</li> <li>Method: realtime stream</li> <li>Data Type: autoware_adapi_v1_msgs/msg/Heartbeat</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/system/heartbeat/#description","title":"Description","text":"<p>The heartbeat frequency is 10 Hz.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/system/heartbeat/#message","title":"Message","text":"Name Type Description stamp builtin_interfaces/msg/Time Timestamp in Autoware for delay checking. seq uint16 Sequence number for order verification, wraps at 65535."},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/status/","title":"/api/system/diagnostics/status","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/status/#apisystemdiagnosticsstatus","title":"/api/system/diagnostics/status","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/status/#status","title":"Status","text":"<ul> <li>Latest Version: v1.3.0</li> <li>Method: realtime stream</li> <li>Data Type: autoware_adapi_v1_msgs/msg/DiagGraphStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/status/#description","title":"Description","text":"<p>This is the dynamic part of the diagnostics. If static data is published with new ID, ignore dynamic data with old ID. See diagnostics for details.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/status/#message","title":"Message","text":"Name Type Description stamp builtin_interfaces/msg/Time Timestamp when this message was sent id string ID to check correspondence between struct and status. nodes autoware_adapi_v1_msgs/msg/DiagNodeStatus[] Dynamic data for nodes in diagnostic graph."},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/struct/","title":"/api/system/diagnostics/struct","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/struct/#apisystemdiagnosticsstruct","title":"/api/system/diagnostics/struct","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/struct/#status","title":"Status","text":"<ul> <li>Latest Version: v1.3.0</li> <li>Method: notification</li> <li>Data Type: autoware_adapi_v1_msgs/msg/DiagGraphStruct</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/struct/#description","title":"Description","text":"<p>This is the static part of the diagnostics. If static data is published with new ID, ignore dynamic data with old ID. See diagnostics for details.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/system/diagnostics/struct/#message","title":"Message","text":"Name Type Description stamp builtin_interfaces/msg/Time Timestamp when this message was sent. id string ID to check correspondence between struct and status. nodes autoware_adapi_v1_msgs/msg/DiagNodeStruct[] Static data for nodes in diagnostic graph. links autoware_adapi_v1_msgs/msg/DiagLinkStruct[] Static data for links in diagnostic graph."},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/dimensions/","title":"/api/vehicle/dimensions","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/dimensions/#apivehicledimensions","title":"/api/vehicle/dimensions","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/dimensions/#status","title":"Status","text":"<ul> <li>Latest Version: v1.1.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/GetVehicleDimensions</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/dimensions/#description","title":"Description","text":"<p>Get the vehicle dimensions. See here for the definition of each value.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/dimensions/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/dimensions/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status dimensions autoware_adapi_v1_msgs/msg/VehicleDimensions vehicle dimensions"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/kinematics/","title":"/api/vehicle/kinematics","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/kinematics/#apivehiclekinematics","title":"/api/vehicle/kinematics","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/kinematics/#status","title":"Status","text":"<ul> <li>Latest Version: v1.1.0</li> <li>Method: realtime stream</li> <li>Data Type: autoware_adapi_v1_msgs/msg/VehicleKinematics</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/kinematics/#description","title":"Description","text":"<p>Publish vehicle kinematics.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/kinematics/#message","title":"Message","text":"Name Type Description geographic_pose geographic_msgs/msg/GeoPointStamped The longitude and latitude of the vehicle. If the map uses local coordinates, it will not be available. pose geometry_msgs/msg/PoseWithCovarianceStamped The pose with covariance from the base link. twist geometry_msgs/msg/TwistWithCovarianceStamped Vehicle current twist with covariance. accel geometry_msgs/msg/AccelWithCovarianceStamped Vehicle current acceleration with covariance."},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/status/","title":"/api/vehicle/status","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/status/#apivehiclestatus","title":"/api/vehicle/status","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/status/#status","title":"Status","text":"<ul> <li>Latest Version: v1.4.0</li> <li>Method: notification</li> <li>Data Type: autoware_adapi_v1_msgs/msg/VehicleStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/status/#description","title":"Description","text":"<p>Publish vehicle state information.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/status/#message","title":"Message","text":"Name Type Description gear autoware_adapi_v1_msgs/msg/Gear Gear status. turn_indicators autoware_adapi_v1_msgs/msg/TurnIndicators Turn indicators status, only either left or right will be enabled. hazard_lights autoware_adapi_v1_msgs/msg/HazardLights Hazard lights status. steering_tire_angle float64 Vehicle current tire angle in radian."},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/command/","title":"/api/vehicle/doors/command","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/command/#apivehicledoorscommand","title":"/api/vehicle/doors/command","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/command/#status","title":"Status","text":"<ul> <li>Latest Version: v1.2.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/SetDoorCommand</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/command/#description","title":"Description","text":"<p>Set the door command. This API is only available if the vehicle supports software door control.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/command/#request","title":"Request","text":"Name Type Description doors.index uint32 The index of the target door. doors.command uint8 The command for the target door."},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/command/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/layout/","title":"/api/vehicle/doors/layout","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/layout/#apivehicledoorslayout","title":"/api/vehicle/doors/layout","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/layout/#status","title":"Status","text":"<ul> <li>Latest Version: v1.2.0</li> <li>Method: function call</li> <li>Data Type: autoware_adapi_v1_msgs/srv/GetDoorLayout</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/layout/#description","title":"Description","text":"<p>Get the door layout. It is an array of roles and descriptions for each door.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/layout/#request","title":"Request","text":"<p>None</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/layout/#response","title":"Response","text":"Name Type Description status autoware_adapi_v1_msgs/msg/ResponseStatus response status doors.roles uint8[] The roles of the door in the service the vehicle provides. doors.description string The description of the door for display in the interface."},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/status/","title":"/api/vehicle/doors/status","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/status/#apivehicledoorsstatus","title":"/api/vehicle/doors/status","text":""},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/status/#status","title":"Status","text":"<ul> <li>Latest Version: v1.2.0</li> <li>Method: notification</li> <li>Data Type: autoware_adapi_v1_msgs/msg/DoorStatusArray</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/status/#description","title":"Description","text":"<p>The status of each door such as opened or closed.</p>"},{"location":"design/autoware-interfaces/ad-api/list/api/vehicle/doors/status/#message","title":"Message","text":"Name Type Description doors.status uint8 current door status"},{"location":"design/autoware-interfaces/ad-api/stories/bus-service/","title":"User story of bus service","text":""},{"location":"design/autoware-interfaces/ad-api/stories/bus-service/#user-story-of-bus-service","title":"User story of bus service","text":""},{"location":"design/autoware-interfaces/ad-api/stories/bus-service/#overview","title":"Overview","text":"<p>This user story is a bus service that goes around the designated stops.</p>"},{"location":"design/autoware-interfaces/ad-api/stories/bus-service/#scenario","title":"Scenario","text":"Step Operation Use Case 1 Startup the autonomous driving system. Launch and terminate 2 Drive the vehicle from the garage to the waiting position. Change the operation mode 3 Enable autonomous control. Change the operation mode 4 Drive the vehicle to the next bus stop. Drive to the designated position 5 Get on and off the vehicle. Get on and get off 6 Return to step 4 unless it's the last bus stop. 7 Drive the vehicle to the waiting position. Drive to the designated position 8 Drive the vehicle from the waiting position to the garage. Change the operation mode 9 Shutdown the autonomous driving system. Launch and terminate"},{"location":"design/autoware-interfaces/ad-api/stories/taxi-service/","title":"User story of bus service","text":""},{"location":"design/autoware-interfaces/ad-api/stories/taxi-service/#user-story-of-bus-service","title":"User story of bus service","text":""},{"location":"design/autoware-interfaces/ad-api/stories/taxi-service/#overview","title":"Overview","text":"<p>This user story is a taxi service that picks up passengers and drives them to their destination.</p>"},{"location":"design/autoware-interfaces/ad-api/stories/taxi-service/#scenario","title":"Scenario","text":"Step Operation Use Case 1 Startup the autonomous driving system. Launch and terminate 2 Drive the vehicle from the garage to the waiting position. Change the operation mode 3 Enable autonomous control. Change the operation mode 4 Drive the vehicle to the position to pick up. Drive to the designated position 5 Get on the vehicle. Get on and get off 6 Drive the vehicle to the destination. Drive to the designated position 7 Get off the vehicle. Get on and get off 8 Drive the vehicle to the waiting position. Drive to the designated position 9 Return to step 4 if there is another request. 10 Drive the vehicle from the waiting position to the garage. Change the operation mode 11 Shutdown the autonomous driving system. Launch and terminate"},{"location":"design/autoware-interfaces/ad-api/types/","title":"Types of Autoware AD API","text":""},{"location":"design/autoware-interfaces/ad-api/types/#types-of-autoware-ad-api","title":"Types of Autoware AD API","text":"<ul> <li>autoware_adapi_v1_msgs/msg/CooperationCommand</li> <li>autoware_adapi_v1_msgs/msg/CooperationDecision</li> <li>autoware_adapi_v1_msgs/msg/CooperationPolicy</li> <li>autoware_adapi_v1_msgs/msg/CooperationStatus</li> <li>autoware_adapi_v1_msgs/msg/DiagGraphStatus</li> <li>autoware_adapi_v1_msgs/msg/DiagGraphStruct</li> <li>autoware_adapi_v1_msgs/msg/DiagLinkStruct</li> <li>autoware_adapi_v1_msgs/msg/DiagNodeStatus</li> <li>autoware_adapi_v1_msgs/msg/DiagNodeStruct</li> <li>autoware_adapi_v1_msgs/msg/DoorCommand</li> <li>autoware_adapi_v1_msgs/msg/DoorLayout</li> <li>autoware_adapi_v1_msgs/msg/DoorStatus</li> <li>autoware_adapi_v1_msgs/msg/DoorStatusArray</li> <li>autoware_adapi_v1_msgs/msg/DynamicObject</li> <li>autoware_adapi_v1_msgs/msg/DynamicObjectArray</li> <li>autoware_adapi_v1_msgs/msg/DynamicObjectKinematics</li> <li>autoware_adapi_v1_msgs/msg/DynamicObjectPath</li> <li>autoware_adapi_v1_msgs/msg/Gear</li> <li>autoware_adapi_v1_msgs/msg/HazardLights</li> <li>autoware_adapi_v1_msgs/msg/Heartbeat</li> <li>autoware_adapi_v1_msgs/msg/LocalizationInitializationState</li> <li>autoware_adapi_v1_msgs/msg/MotionState</li> <li>autoware_adapi_v1_msgs/msg/MrmState</li> <li>autoware_adapi_v1_msgs/msg/ObjectClassification</li> <li>autoware_adapi_v1_msgs/msg/OperationModeState</li> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> <li>autoware_adapi_v1_msgs/msg/Route</li> <li>autoware_adapi_v1_msgs/msg/RouteData</li> <li>autoware_adapi_v1_msgs/msg/RouteOption</li> <li>autoware_adapi_v1_msgs/msg/RoutePrimitive</li> <li>autoware_adapi_v1_msgs/msg/RouteSegment</li> <li>autoware_adapi_v1_msgs/msg/RouteState</li> <li>autoware_adapi_v1_msgs/msg/SteeringFactor</li> <li>autoware_adapi_v1_msgs/msg/SteeringFactorArray</li> <li>autoware_adapi_v1_msgs/msg/TurnIndicators</li> <li>autoware_adapi_v1_msgs/msg/VehicleDimensions</li> <li>autoware_adapi_v1_msgs/msg/VehicleKinematics</li> <li>autoware_adapi_v1_msgs/msg/VehicleStatus</li> <li>autoware_adapi_v1_msgs/msg/VelocityFactor</li> <li>autoware_adapi_v1_msgs/msg/VelocityFactorArray</li> <li>autoware_adapi_v1_msgs/srv/AcceptStart</li> <li>autoware_adapi_v1_msgs/srv/ChangeOperationMode</li> <li>autoware_adapi_v1_msgs/srv/ClearRoute</li> <li>autoware_adapi_v1_msgs/srv/GetCooperationPolicies</li> <li>autoware_adapi_v1_msgs/srv/GetDoorLayout</li> <li>autoware_adapi_v1_msgs/srv/GetVehicleDimensions</li> <li>autoware_adapi_v1_msgs/srv/InitializeLocalization</li> <li>autoware_adapi_v1_msgs/srv/SetCooperationCommands</li> <li>autoware_adapi_v1_msgs/srv/SetCooperationPolicies</li> <li>autoware_adapi_v1_msgs/srv/SetDoorCommand</li> <li>autoware_adapi_v1_msgs/srv/SetRoute</li> <li>autoware_adapi_v1_msgs/srv/SetRoutePoints</li> <li>autoware_adapi_version_msgs/srv/InterfaceVersion</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationCommand/","title":"autoware_adapi_v1_msgs/msg/CooperationCommand","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationCommand/#autoware_adapi_v1_msgsmsgcooperationcommand","title":"autoware_adapi_v1_msgs/msg/CooperationCommand","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationCommand/#definition","title":"Definition","text":"<pre><code>unique_identifier_msgs/UUID uuid\nautoware_adapi_v1_msgs/CooperationDecision cooperator\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationCommand/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/CooperationDecision</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationCommand/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/srv/SetCooperationCommands</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationDecision/","title":"autoware_adapi_v1_msgs/msg/CooperationDecision","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationDecision/#autoware_adapi_v1_msgsmsgcooperationdecision","title":"autoware_adapi_v1_msgs/msg/CooperationDecision","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationDecision/#definition","title":"Definition","text":"<pre><code>uint8 UNKNOWN = 0\nuint8 DEACTIVATE = 1\nuint8 ACTIVATE = 2\nuint8 AUTONOMOUS = 3\nuint8 UNDECIDED = 4\n\nuint8 decision\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationDecision/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationDecision/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/CooperationCommand</li> <li>autoware_adapi_v1_msgs/msg/CooperationStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationPolicy/","title":"autoware_adapi_v1_msgs/msg/CooperationPolicy","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationPolicy/#autoware_adapi_v1_msgsmsgcooperationpolicy","title":"autoware_adapi_v1_msgs/msg/CooperationPolicy","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationPolicy/#definition","title":"Definition","text":"<pre><code>uint8 OPTIONAL = 1\nuint8 REQUIRED = 2\n\nstring behavior\nstring sequence\nuint8 policy\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationPolicy/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationPolicy/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/srv/GetCooperationPolicies</li> <li>autoware_adapi_v1_msgs/srv/SetCooperationPolicies</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationStatus/","title":"autoware_adapi_v1_msgs/msg/CooperationStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationStatus/#autoware_adapi_v1_msgsmsgcooperationstatus","title":"autoware_adapi_v1_msgs/msg/CooperationStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationStatus/#definition","title":"Definition","text":"<pre><code>unique_identifier_msgs/UUID uuid\nautoware_adapi_v1_msgs/CooperationDecision autonomous\nautoware_adapi_v1_msgs/CooperationDecision cooperator\nbool cancellable\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationStatus/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/CooperationDecision</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/CooperationStatus/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/SteeringFactor</li> <li>autoware_adapi_v1_msgs/msg/VelocityFactor</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStatus/","title":"autoware_adapi_v1_msgs/msg/DiagGraphStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStatus/#autoware_adapi_v1_msgsmsgdiaggraphstatus","title":"autoware_adapi_v1_msgs/msg/DiagGraphStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStatus/#definition","title":"Definition","text":"<pre><code>builtin_interfaces/Time stamp\nstring id\nautoware_adapi_v1_msgs/DiagNodeStatus[] nodes\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStatus/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DiagNodeStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStatus/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStruct/","title":"autoware_adapi_v1_msgs/msg/DiagGraphStruct","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStruct/#autoware_adapi_v1_msgsmsgdiaggraphstruct","title":"autoware_adapi_v1_msgs/msg/DiagGraphStruct","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStruct/#definition","title":"Definition","text":"<pre><code>builtin_interfaces/Time stamp\nstring id\nautoware_adapi_v1_msgs/DiagNodeStruct[] nodes\nautoware_adapi_v1_msgs/DiagLinkStruct[] links\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStruct/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DiagLinkStruct</li> <li>autoware_adapi_v1_msgs/msg/DiagNodeStruct</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagGraphStruct/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagLinkStruct/","title":"autoware_adapi_v1_msgs/msg/DiagLinkStruct","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagLinkStruct/#autoware_adapi_v1_msgsmsgdiaglinkstruct","title":"autoware_adapi_v1_msgs/msg/DiagLinkStruct","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagLinkStruct/#definition","title":"Definition","text":"<pre><code># The index of nodes in the graph struct message.\nuint32 parent\nuint32 child\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagLinkStruct/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagLinkStruct/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DiagGraphStruct</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStatus/","title":"autoware_adapi_v1_msgs/msg/DiagNodeStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStatus/#autoware_adapi_v1_msgsmsgdiagnodestatus","title":"autoware_adapi_v1_msgs/msg/DiagNodeStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStatus/#definition","title":"Definition","text":"<pre><code># The level of diagnostic_msgs/msg/DiagnosticStatus.\nbyte level\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStatus/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStatus/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DiagGraphStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStruct/","title":"autoware_adapi_v1_msgs/msg/DiagNodeStruct","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStruct/#autoware_adapi_v1_msgsmsgdiagnodestruct","title":"autoware_adapi_v1_msgs/msg/DiagNodeStruct","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStruct/#definition","title":"Definition","text":"<pre><code>string path\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStruct/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DiagNodeStruct/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DiagGraphStruct</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorCommand/","title":"autoware_adapi_v1_msgs/msg/DoorCommand","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorCommand/#autoware_adapi_v1_msgsmsgdoorcommand","title":"autoware_adapi_v1_msgs/msg/DoorCommand","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorCommand/#definition","title":"Definition","text":"<pre><code>uint8 OPEN = 1\nuint8 CLOSE = 2\n\nuint32 index\nuint8 command\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorCommand/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorCommand/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/srv/SetDoorCommand</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorLayout/","title":"autoware_adapi_v1_msgs/msg/DoorLayout","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorLayout/#autoware_adapi_v1_msgsmsgdoorlayout","title":"autoware_adapi_v1_msgs/msg/DoorLayout","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorLayout/#definition","title":"Definition","text":"<pre><code>uint8 GET_ON = 1\nuint8 GET_OFF = 2\n\nuint8[] roles\nstring description\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorLayout/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorLayout/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/srv/GetDoorLayout</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatus/","title":"autoware_adapi_v1_msgs/msg/DoorStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatus/#autoware_adapi_v1_msgsmsgdoorstatus","title":"autoware_adapi_v1_msgs/msg/DoorStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatus/#definition","title":"Definition","text":"<pre><code>uint8 UNKNOWN = 0\nuint8 NOT_AVAILABLE = 1\nuint8 OPENED = 2\nuint8 CLOSED = 3\nuint8 OPENING = 4\nuint8 CLOSING = 5\n\nuint8 status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatus/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatus/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DoorStatusArray</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatusArray/","title":"autoware_adapi_v1_msgs/msg/DoorStatusArray","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatusArray/#autoware_adapi_v1_msgsmsgdoorstatusarray","title":"autoware_adapi_v1_msgs/msg/DoorStatusArray","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatusArray/#definition","title":"Definition","text":"<pre><code>builtin_interfaces/Time stamp\nautoware_adapi_v1_msgs/DoorStatus[] doors\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatusArray/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DoorStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DoorStatusArray/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObject/","title":"autoware_adapi_v1_msgs/msg/DynamicObject","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObject/#autoware_adapi_v1_msgsmsgdynamicobject","title":"autoware_adapi_v1_msgs/msg/DynamicObject","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObject/#definition","title":"Definition","text":"<pre><code>unique_identifier_msgs/UUID id\nfloat64 existence_probability\nautoware_adapi_v1_msgs/ObjectClassification[] classification\nautoware_adapi_v1_msgs/DynamicObjectKinematics kinematics\nshape_msgs/SolidPrimitive shape\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObject/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DynamicObjectKinematics</li> <li>autoware_adapi_v1_msgs/msg/ObjectClassification</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObject/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DynamicObjectArray</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectArray/","title":"autoware_adapi_v1_msgs/msg/DynamicObjectArray","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectArray/#autoware_adapi_v1_msgsmsgdynamicobjectarray","title":"autoware_adapi_v1_msgs/msg/DynamicObjectArray","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectArray/#definition","title":"Definition","text":"<pre><code>std_msgs/Header header\nautoware_adapi_v1_msgs/DynamicObject[] objects\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectArray/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DynamicObject</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectArray/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectKinematics/","title":"autoware_adapi_v1_msgs/msg/DynamicObjectKinematics","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectKinematics/#autoware_adapi_v1_msgsmsgdynamicobjectkinematics","title":"autoware_adapi_v1_msgs/msg/DynamicObjectKinematics","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectKinematics/#definition","title":"Definition","text":"<pre><code>geometry_msgs/Pose pose\ngeometry_msgs/Twist twist\ngeometry_msgs/Accel accel\n\nautoware_adapi_v1_msgs/DynamicObjectPath[] predicted_paths\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectKinematics/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DynamicObjectPath</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectKinematics/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DynamicObject</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectPath/","title":"autoware_adapi_v1_msgs/msg/DynamicObjectPath","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectPath/#autoware_adapi_v1_msgsmsgdynamicobjectpath","title":"autoware_adapi_v1_msgs/msg/DynamicObjectPath","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectPath/#definition","title":"Definition","text":"<pre><code>geometry_msgs/Pose[] path\nbuiltin_interfaces/Duration time_step\nfloat64 confidence\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectPath/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/DynamicObjectPath/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DynamicObjectKinematics</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Gear/","title":"autoware_adapi_v1_msgs/msg/Gear","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Gear/#autoware_adapi_v1_msgsmsggear","title":"autoware_adapi_v1_msgs/msg/Gear","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Gear/#definition","title":"Definition","text":"<pre><code># constants\nuint8 UNKNOWN = 0\nuint8 NEUTRAL = 1\nuint8 DRIVE = 2\nuint8 REVERSE = 3\nuint8 PARK = 4\nuint8 LOW = 5\n\nuint8 status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Gear/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Gear/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/VehicleStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/HazardLights/","title":"autoware_adapi_v1_msgs/msg/HazardLights","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/HazardLights/#autoware_adapi_v1_msgsmsghazardlights","title":"autoware_adapi_v1_msgs/msg/HazardLights","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/HazardLights/#definition","title":"Definition","text":"<pre><code># constants\nuint8 UNKNOWN = 0\nuint8 DISABLE = 1\nuint8 ENABLE = 2\n\nuint8 status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/HazardLights/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/HazardLights/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/VehicleStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Heartbeat/","title":"autoware_adapi_v1_msgs/msg/Heartbeat","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Heartbeat/#autoware_adapi_v1_msgsmsgheartbeat","title":"autoware_adapi_v1_msgs/msg/Heartbeat","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Heartbeat/#definition","title":"Definition","text":"<pre><code># Timestamp in Autoware for delay checking.\nbuiltin_interfaces/Time stamp\n\n# Sequence number for order verification, wraps at 65535.\nuint16 seq\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Heartbeat/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Heartbeat/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/LocalizationInitializationState/","title":"autoware_adapi_v1_msgs/msg/LocalizationInitializationState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/LocalizationInitializationState/#autoware_adapi_v1_msgsmsglocalizationinitializationstate","title":"autoware_adapi_v1_msgs/msg/LocalizationInitializationState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/LocalizationInitializationState/#definition","title":"Definition","text":"<pre><code>uint16 UNKNOWN = 0\nuint16 UNINITIALIZED = 1\nuint16 INITIALIZING = 2\nuint16 INITIALIZED = 3\n\nbuiltin_interfaces/Time stamp\nuint16 state\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/LocalizationInitializationState/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/LocalizationInitializationState/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MotionState/","title":"autoware_adapi_v1_msgs/msg/MotionState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MotionState/#autoware_adapi_v1_msgsmsgmotionstate","title":"autoware_adapi_v1_msgs/msg/MotionState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MotionState/#definition","title":"Definition","text":"<pre><code>uint16 UNKNOWN = 0\nuint16 STOPPED = 1\nuint16 STARTING = 2\nuint16 MOVING = 3\n\nbuiltin_interfaces/Time stamp\nuint16 state\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MotionState/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MotionState/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MrmState/","title":"autoware_adapi_v1_msgs/msg/MrmState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MrmState/#autoware_adapi_v1_msgsmsgmrmstate","title":"autoware_adapi_v1_msgs/msg/MrmState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MrmState/#definition","title":"Definition","text":"<pre><code>builtin_interfaces/Time stamp\n\n# For common use\nuint16 UNKNOWN = 0\n\n# For state\nuint16 NORMAL = 1\nuint16 MRM_OPERATING = 2\nuint16 MRM_SUCCEEDED = 3\nuint16 MRM_FAILED = 4\n\n# For behavior\nuint16 NONE = 1\nuint16 EMERGENCY_STOP = 2\nuint16 COMFORTABLE_STOP = 3\nuint16 PULL_OVER = 4\n\nuint16 state\nuint16 behavior\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MrmState/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/MrmState/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ObjectClassification/","title":"autoware_adapi_v1_msgs/msg/ObjectClassification","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ObjectClassification/#autoware_adapi_v1_msgsmsgobjectclassification","title":"autoware_adapi_v1_msgs/msg/ObjectClassification","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ObjectClassification/#definition","title":"Definition","text":"<pre><code>uint8 UNKNOWN=0\nuint8 CAR=1\nuint8 TRUCK=2\nuint8 BUS=3\nuint8 TRAILER = 4\nuint8 MOTORCYCLE = 5\nuint8 BICYCLE = 6\nuint8 PEDESTRIAN = 7\n\nuint8 label\nfloat64 probability\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ObjectClassification/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ObjectClassification/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DynamicObject</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/OperationModeState/","title":"autoware_adapi_v1_msgs/msg/OperationModeState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/OperationModeState/#autoware_adapi_v1_msgsmsgoperationmodestate","title":"autoware_adapi_v1_msgs/msg/OperationModeState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/OperationModeState/#definition","title":"Definition","text":"<pre><code># constants for mode\nuint8 UNKNOWN = 0\nuint8 STOP = 1\nuint8 AUTONOMOUS = 2\nuint8 LOCAL = 3\nuint8 REMOTE = 4\n\n# variables\nbuiltin_interfaces/Time stamp\nuint8 mode\nbool is_autoware_control_enabled\nbool is_in_transition\nbool is_stop_mode_available\nbool is_autonomous_mode_available\nbool is_local_mode_available\nbool is_remote_mode_available\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/OperationModeState/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/OperationModeState/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ResponseStatus/","title":"autoware_adapi_v1_msgs/msg/ResponseStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ResponseStatus/#autoware_adapi_v1_msgsmsgresponsestatus","title":"autoware_adapi_v1_msgs/msg/ResponseStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ResponseStatus/#definition","title":"Definition","text":"<pre><code># error code\nuint16 UNKNOWN = 50000\nuint16 SERVICE_UNREADY = 50001\nuint16 SERVICE_TIMEOUT = 50002\nuint16 TRANSFORM_ERROR = 50003\nuint16 PARAMETER_ERROR = 50004\n\n# warning code\nuint16 DEPRECATED = 60000\nuint16 NO_EFFECT = 60001\n\n# variables\nbool   success\nuint16 code\nstring message\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ResponseStatus/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/ResponseStatus/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/srv/AcceptStart</li> <li>autoware_adapi_v1_msgs/srv/ChangeOperationMode</li> <li>autoware_adapi_v1_msgs/srv/ClearRoute</li> <li>autoware_adapi_v1_msgs/srv/GetCooperationPolicies</li> <li>autoware_adapi_v1_msgs/srv/GetDoorLayout</li> <li>autoware_adapi_v1_msgs/srv/GetVehicleDimensions</li> <li>autoware_adapi_v1_msgs/srv/InitializeLocalization</li> <li>autoware_adapi_v1_msgs/srv/SetCooperationCommands</li> <li>autoware_adapi_v1_msgs/srv/SetCooperationPolicies</li> <li>autoware_adapi_v1_msgs/srv/SetDoorCommand</li> <li>autoware_adapi_v1_msgs/srv/SetRoute</li> <li>autoware_adapi_v1_msgs/srv/SetRoutePoints</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Route/","title":"autoware_adapi_v1_msgs/msg/Route","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Route/#autoware_adapi_v1_msgsmsgroute","title":"autoware_adapi_v1_msgs/msg/Route","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Route/#definition","title":"Definition","text":"<pre><code>std_msgs/Header header\nautoware_adapi_v1_msgs/RouteData[&lt;=1] data\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Route/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/RouteData</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/Route/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteData/","title":"autoware_adapi_v1_msgs/msg/RouteData","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteData/#autoware_adapi_v1_msgsmsgroutedata","title":"autoware_adapi_v1_msgs/msg/RouteData","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteData/#definition","title":"Definition","text":"<pre><code>geometry_msgs/Pose start\ngeometry_msgs/Pose goal\nautoware_adapi_v1_msgs/RouteSegment[] segments\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteData/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/RouteSegment</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteData/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/Route</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteOption/","title":"autoware_adapi_v1_msgs/msg/RouteOption","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteOption/#autoware_adapi_v1_msgsmsgrouteoption","title":"autoware_adapi_v1_msgs/msg/RouteOption","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteOption/#definition","title":"Definition","text":"<pre><code>bool allow_goal_modification\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteOption/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteOption/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/srv/SetRoute</li> <li>autoware_adapi_v1_msgs/srv/SetRoutePoints</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RoutePrimitive/","title":"autoware_adapi_v1_msgs/msg/RoutePrimitive","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RoutePrimitive/#autoware_adapi_v1_msgsmsgrouteprimitive","title":"autoware_adapi_v1_msgs/msg/RoutePrimitive","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RoutePrimitive/#definition","title":"Definition","text":"<pre><code>int64 id\nstring type  # The same id may be used for each type.\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RoutePrimitive/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RoutePrimitive/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/RouteSegment</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteSegment/","title":"autoware_adapi_v1_msgs/msg/RouteSegment","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteSegment/#autoware_adapi_v1_msgsmsgroutesegment","title":"autoware_adapi_v1_msgs/msg/RouteSegment","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteSegment/#definition","title":"Definition","text":"<pre><code>autoware_adapi_v1_msgs/RoutePrimitive   preferred\nautoware_adapi_v1_msgs/RoutePrimitive[] alternatives  # Does not include the preferred primitive.\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteSegment/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/RoutePrimitive</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteSegment/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/RouteData</li> <li>autoware_adapi_v1_msgs/srv/SetRoute</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteState/","title":"autoware_adapi_v1_msgs/msg/RouteState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteState/#autoware_adapi_v1_msgsmsgroutestate","title":"autoware_adapi_v1_msgs/msg/RouteState","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteState/#definition","title":"Definition","text":"<pre><code>uint16 UNKNOWN = 0\nuint16 UNSET = 1\nuint16 SET = 2\nuint16 ARRIVED = 3\nuint16 CHANGING = 4\n\nbuiltin_interfaces/Time stamp\nuint16 state\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteState/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/RouteState/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactor/","title":"autoware_adapi_v1_msgs/msg/SteeringFactor","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactor/#autoware_adapi_v1_msgsmsgsteeringfactor","title":"autoware_adapi_v1_msgs/msg/SteeringFactor","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactor/#definition","title":"Definition","text":"<pre><code># constants for common use\nuint16 UNKNOWN = 0\n\n# constants for direction\nuint16 LEFT = 1\nuint16 RIGHT = 2\nuint16 STRAIGHT = 3\n\n# constants for status\nuint16 APPROACHING = 1\nuint16 TURNING = 3\n\n# variables\ngeometry_msgs/Pose[2] pose\nfloat32[2] distance\nuint16 direction\nuint16 status\nstring behavior\nstring sequence\nstring detail\nautoware_adapi_v1_msgs/CooperationStatus[&lt;=1] cooperation\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactor/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/CooperationStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactor/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/SteeringFactorArray</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactorArray/","title":"autoware_adapi_v1_msgs/msg/SteeringFactorArray","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactorArray/#autoware_adapi_v1_msgsmsgsteeringfactorarray","title":"autoware_adapi_v1_msgs/msg/SteeringFactorArray","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactorArray/#definition","title":"Definition","text":"<pre><code>std_msgs/Header header\nautoware_adapi_v1_msgs/SteeringFactor[] factors\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactorArray/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/SteeringFactor</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/SteeringFactorArray/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/TurnIndicators/","title":"autoware_adapi_v1_msgs/msg/TurnIndicators","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/TurnIndicators/#autoware_adapi_v1_msgsmsgturnindicators","title":"autoware_adapi_v1_msgs/msg/TurnIndicators","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/TurnIndicators/#definition","title":"Definition","text":"<pre><code># constants\nuint8 UNKNOWN = 0\nuint8 DISABLE = 1\nuint8 LEFT = 2\nuint8 RIGHT = 3\n\nuint8 status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/TurnIndicators/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/TurnIndicators/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/VehicleStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleDimensions/","title":"autoware_adapi_v1_msgs/msg/VehicleDimensions","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleDimensions/#autoware_adapi_v1_msgsmsgvehicledimensions","title":"autoware_adapi_v1_msgs/msg/VehicleDimensions","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleDimensions/#definition","title":"Definition","text":"<pre><code>float32 wheel_radius\nfloat32 wheel_width\nfloat32 wheel_base\nfloat32 wheel_tread\nfloat32 front_overhang\nfloat32 rear_overhang\nfloat32 left_overhang\nfloat32 right_overhang\nfloat32 height\ngeometry_msgs/Polygon footprint\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleDimensions/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleDimensions/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/srv/GetVehicleDimensions</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleKinematics/","title":"autoware_adapi_v1_msgs/msg/VehicleKinematics","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleKinematics/#autoware_adapi_v1_msgsmsgvehiclekinematics","title":"autoware_adapi_v1_msgs/msg/VehicleKinematics","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleKinematics/#definition","title":"Definition","text":"<pre><code># Geographic point, using the WGS 84 reference ellipsoid.\n# This data will be invalid If Autoware does not provide projection information between geographic coordinates and local coordinates.\ngeographic_msgs/GeoPointStamped geographic_pose\n\n# Local coordinate from the autoware\ngeometry_msgs/PoseWithCovarianceStamped pose\ngeometry_msgs/TwistWithCovarianceStamped twist\ngeometry_msgs/AccelWithCovarianceStamped accel\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleKinematics/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleKinematics/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleStatus/","title":"autoware_adapi_v1_msgs/msg/VehicleStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleStatus/#autoware_adapi_v1_msgsmsgvehiclestatus","title":"autoware_adapi_v1_msgs/msg/VehicleStatus","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleStatus/#definition","title":"Definition","text":"<pre><code>builtin_interfaces/Time stamp\nautoware_adapi_v1_msgs/Gear gear\nautoware_adapi_v1_msgs/TurnIndicators turn_indicators\nautoware_adapi_v1_msgs/HazardLights hazard_lights\nfloat64 steering_tire_angle\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleStatus/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/Gear</li> <li>autoware_adapi_v1_msgs/msg/HazardLights</li> <li>autoware_adapi_v1_msgs/msg/TurnIndicators</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VehicleStatus/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactor/","title":"autoware_adapi_v1_msgs/msg/VelocityFactor","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactor/#autoware_adapi_v1_msgsmsgvelocityfactor","title":"autoware_adapi_v1_msgs/msg/VelocityFactor","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactor/#definition","title":"Definition","text":"<pre><code># constants for common use\nuint16 UNKNOWN = 0\n\n# constants for status\nuint16 APPROACHING = 1\nuint16 STOPPED = 2\n\n# variables\ngeometry_msgs/Pose pose\nfloat32 distance\nuint16 status\nstring behavior\nstring sequence\nstring detail\nautoware_adapi_v1_msgs/CooperationStatus[&lt;=1] cooperation\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactor/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/CooperationStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactor/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>autoware_adapi_v1_msgs/msg/VelocityFactorArray</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactorArray/","title":"autoware_adapi_v1_msgs/msg/VelocityFactorArray","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactorArray/#autoware_adapi_v1_msgsmsgvelocityfactorarray","title":"autoware_adapi_v1_msgs/msg/VelocityFactorArray","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactorArray/#definition","title":"Definition","text":"<pre><code>std_msgs/Header header\nautoware_adapi_v1_msgs/VelocityFactor[] factors\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactorArray/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/VelocityFactor</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/msg/VelocityFactorArray/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/AcceptStart/","title":"autoware_adapi_v1_msgs/srv/AcceptStart","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/AcceptStart/#autoware_adapi_v1_msgssrvacceptstart","title":"autoware_adapi_v1_msgs/srv/AcceptStart","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/AcceptStart/#definition","title":"Definition","text":"<pre><code>---\nuint16 ERROR_NOT_STARTING = 1\nautoware_adapi_v1_msgs/ResponseStatus status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/AcceptStart/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/AcceptStart/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ChangeOperationMode/","title":"autoware_adapi_v1_msgs/srv/ChangeOperationMode","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ChangeOperationMode/#autoware_adapi_v1_msgssrvchangeoperationmode","title":"autoware_adapi_v1_msgs/srv/ChangeOperationMode","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ChangeOperationMode/#definition","title":"Definition","text":"<pre><code>---\nuint16 ERROR_NOT_AVAILABLE = 1\nuint16 ERROR_IN_TRANSITION = 2\nautoware_adapi_v1_msgs/ResponseStatus status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ChangeOperationMode/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ChangeOperationMode/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ClearRoute/","title":"autoware_adapi_v1_msgs/srv/ClearRoute","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ClearRoute/#autoware_adapi_v1_msgssrvclearroute","title":"autoware_adapi_v1_msgs/srv/ClearRoute","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ClearRoute/#definition","title":"Definition","text":"<pre><code>---\nautoware_adapi_v1_msgs/ResponseStatus status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ClearRoute/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/ClearRoute/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetCooperationPolicies/","title":"autoware_adapi_v1_msgs/srv/GetCooperationPolicies","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetCooperationPolicies/#autoware_adapi_v1_msgssrvgetcooperationpolicies","title":"autoware_adapi_v1_msgs/srv/GetCooperationPolicies","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetCooperationPolicies/#definition","title":"Definition","text":"<pre><code>---\nautoware_adapi_v1_msgs/ResponseStatus status\nautoware_adapi_v1_msgs/CooperationPolicy[] policies\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetCooperationPolicies/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/CooperationPolicy</li> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetCooperationPolicies/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetDoorLayout/","title":"autoware_adapi_v1_msgs/srv/GetDoorLayout","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetDoorLayout/#autoware_adapi_v1_msgssrvgetdoorlayout","title":"autoware_adapi_v1_msgs/srv/GetDoorLayout","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetDoorLayout/#definition","title":"Definition","text":"<pre><code>---\nautoware_adapi_v1_msgs/ResponseStatus status\nautoware_adapi_v1_msgs/DoorLayout[] doors\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetDoorLayout/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DoorLayout</li> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetDoorLayout/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetVehicleDimensions/","title":"autoware_adapi_v1_msgs/srv/GetVehicleDimensions","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetVehicleDimensions/#autoware_adapi_v1_msgssrvgetvehicledimensions","title":"autoware_adapi_v1_msgs/srv/GetVehicleDimensions","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetVehicleDimensions/#definition","title":"Definition","text":"<pre><code>---\nautoware_adapi_v1_msgs/ResponseStatus status\nautoware_adapi_v1_msgs/VehicleDimensions dimensions\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetVehicleDimensions/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> <li>autoware_adapi_v1_msgs/msg/VehicleDimensions</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/GetVehicleDimensions/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/InitializeLocalization/","title":"autoware_adapi_v1_msgs/srv/InitializeLocalization","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/InitializeLocalization/#autoware_adapi_v1_msgssrvinitializelocalization","title":"autoware_adapi_v1_msgs/srv/InitializeLocalization","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/InitializeLocalization/#definition","title":"Definition","text":"<pre><code>geometry_msgs/PoseWithCovarianceStamped[&lt;=1] pose\n---\nuint16 ERROR_UNSAFE = 1\nuint16 ERROR_GNSS_SUPPORT = 2\nuint16 ERROR_GNSS = 3\nuint16 ERROR_ESTIMATION = 4\nautoware_adapi_v1_msgs/ResponseStatus status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/InitializeLocalization/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/InitializeLocalization/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationCommands/","title":"autoware_adapi_v1_msgs/srv/SetCooperationCommands","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationCommands/#autoware_adapi_v1_msgssrvsetcooperationcommands","title":"autoware_adapi_v1_msgs/srv/SetCooperationCommands","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationCommands/#definition","title":"Definition","text":"<pre><code>autoware_adapi_v1_msgs/CooperationCommand[] commands\n---\nautoware_adapi_v1_msgs/ResponseStatus status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationCommands/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/CooperationCommand</li> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationCommands/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationPolicies/","title":"autoware_adapi_v1_msgs/srv/SetCooperationPolicies","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationPolicies/#autoware_adapi_v1_msgssrvsetcooperationpolicies","title":"autoware_adapi_v1_msgs/srv/SetCooperationPolicies","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationPolicies/#definition","title":"Definition","text":"<pre><code>autoware_adapi_v1_msgs/CooperationPolicy[] policies\n---\nautoware_adapi_v1_msgs/ResponseStatus status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationPolicies/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/CooperationPolicy</li> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetCooperationPolicies/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetDoorCommand/","title":"autoware_adapi_v1_msgs/srv/SetDoorCommand","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetDoorCommand/#autoware_adapi_v1_msgssrvsetdoorcommand","title":"autoware_adapi_v1_msgs/srv/SetDoorCommand","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetDoorCommand/#definition","title":"Definition","text":"<pre><code>autoware_adapi_v1_msgs/DoorCommand[] doors\n---\nautoware_adapi_v1_msgs/ResponseStatus status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetDoorCommand/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/DoorCommand</li> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetDoorCommand/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoute/","title":"autoware_adapi_v1_msgs/srv/SetRoute","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoute/#autoware_adapi_v1_msgssrvsetroute","title":"autoware_adapi_v1_msgs/srv/SetRoute","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoute/#definition","title":"Definition","text":"<pre><code>std_msgs/Header header\nautoware_adapi_v1_msgs/RouteOption option\ngeometry_msgs/Pose goal\nautoware_adapi_v1_msgs/RouteSegment[] segments\n---\nuint16 ERROR_ROUTE_EXISTS = 1 # Deprecated. Use ERROR_INVALID_STATE.\nuint16 ERROR_INVALID_STATE = 1\nuint16 ERROR_PLANNER_UNREADY = 2\nuint16 ERROR_PLANNER_FAILED = 3\nuint16 ERROR_REROUTE_FAILED = 4\nautoware_adapi_v1_msgs/ResponseStatus status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoute/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> <li>autoware_adapi_v1_msgs/msg/RouteOption</li> <li>autoware_adapi_v1_msgs/msg/RouteSegment</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoute/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoutePoints/","title":"autoware_adapi_v1_msgs/srv/SetRoutePoints","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoutePoints/#autoware_adapi_v1_msgssrvsetroutepoints","title":"autoware_adapi_v1_msgs/srv/SetRoutePoints","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoutePoints/#definition","title":"Definition","text":"<pre><code>std_msgs/Header header\nautoware_adapi_v1_msgs/RouteOption option\ngeometry_msgs/Pose goal\ngeometry_msgs/Pose[] waypoints\n---\nuint16 ERROR_ROUTE_EXISTS = 1 # Deprecated. Use ERROR_INVALID_STATE.\nuint16 ERROR_INVALID_STATE = 1\nuint16 ERROR_PLANNER_UNREADY = 2\nuint16 ERROR_PLANNER_FAILED = 3\nuint16 ERROR_REROUTE_FAILED = 4\nautoware_adapi_v1_msgs/ResponseStatus status\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoutePoints/#this-type-uses","title":"This type uses","text":"<ul> <li>autoware_adapi_v1_msgs/msg/ResponseStatus</li> <li>autoware_adapi_v1_msgs/msg/RouteOption</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_v1_msgs/srv/SetRoutePoints/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_version_msgs/srv/InterfaceVersion/","title":"autoware_adapi_version_msgs/srv/InterfaceVersion","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_version_msgs/srv/InterfaceVersion/#autoware_adapi_version_msgssrvinterfaceversion","title":"autoware_adapi_version_msgs/srv/InterfaceVersion","text":""},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_version_msgs/srv/InterfaceVersion/#definition","title":"Definition","text":"<pre><code>---\nuint16 major\nuint16 minor\nuint16 patch\n</code></pre>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_version_msgs/srv/InterfaceVersion/#this-type-uses","title":"This type uses","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/types/autoware_adapi_version_msgs/srv/InterfaceVersion/#this-type-is-used-by","title":"This type is used by","text":"<ul> <li>None</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/use-cases/change-operation-mode/","title":"Change the operation mode","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/change-operation-mode/#change-the-operation-mode","title":"Change the operation mode","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/change-operation-mode/#related-api","title":"Related API","text":"<ul> <li>Operation mode</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/use-cases/change-operation-mode/#sequence","title":"Sequence","text":"<ul> <li> <p>Change the mode with software switch.</p> <p></p> </li> </ul> <ul> <li> <p>Change the mode with hardware switch.</p> <p></p> </li> </ul>"},{"location":"design/autoware-interfaces/ad-api/use-cases/drive-designated-position/","title":"Drive to the designated position","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/drive-designated-position/#drive-to-the-designated-position","title":"Drive to the designated position","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/drive-designated-position/#related-api","title":"Related API","text":"<ul> <li>Operation mode</li> <li>Routing</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/use-cases/drive-designated-position/#sequence","title":"Sequence","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/get-on-off/","title":"Get on and get off","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/get-on-off/#get-on-and-get-off","title":"Get on and get off","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/get-on-off/#related-api","title":"Related API","text":"<ul> <li>Vehicle doors</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/use-cases/get-on-off/#sequence","title":"Sequence","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/initialize-pose/","title":"Initialize the pose","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/initialize-pose/#initialize-the-pose","title":"Initialize the pose","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/initialize-pose/#related-api","title":"Related API","text":"<ul> <li>Localization</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/use-cases/initialize-pose/#sequence","title":"Sequence","text":"<ul> <li> <p>Initialization of the pose using input.</p> <p></p> </li> </ul> <ul> <li> <p>Initialization of the pose using GNSS.</p> <p></p> </li> </ul>"},{"location":"design/autoware-interfaces/ad-api/use-cases/launch-terminate/","title":"Launch and terminate","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/launch-terminate/#launch-and-terminate","title":"Launch and terminate","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/launch-terminate/#related-api","title":"Related API","text":"<ul> <li>T.B.D.</li> </ul>"},{"location":"design/autoware-interfaces/ad-api/use-cases/launch-terminate/#sequence","title":"Sequence","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/system-monitoring/","title":"System monitoring","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/system-monitoring/#system-monitoring","title":"System monitoring","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/system-monitoring/#heartbeat","title":"Heartbeat","text":"<p>Heartbeat is a reference for checking whether communication with Autoware is being performed properly.</p>"},{"location":"design/autoware-interfaces/ad-api/use-cases/system-monitoring/#diagnostics","title":"Diagnostics","text":"<p>Diagnostics is a set of error levels for each functional unit of Autoware. The design and structure of functional units are system dependent. This is useful to identify the cause of an abnormality.</p>"},{"location":"design/autoware-interfaces/ad-api/use-cases/vehicle-monitoring/","title":"Vehicle monitoring","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/vehicle-monitoring/#vehicle-monitoring","title":"Vehicle monitoring","text":"<p>AD API provides current vehicle status for remote monitoring, visualization for passengers, etc. Use the API below depending on the data you want to monitor.</p>"},{"location":"design/autoware-interfaces/ad-api/use-cases/vehicle-monitoring/#vehicle-status","title":"Vehicle status","text":"<p>The vehicle status provides basic information such as kinematics, indicators, and dimensions. This allows a remote operator to know the position and velocity of the vehicle. For applications such as FMS, it can help find vehicles that need assistance, such as vehicles that are stuck or brake suddenly. It is also possible to determine the actual distance to an object from the vehicle dimensions.</p>"},{"location":"design/autoware-interfaces/ad-api/use-cases/vehicle-monitoring/#planning-factors","title":"Planning factors","text":"<p>The planning factors provides the planning status of the vehicle. HMI can use this to warn of sudden movements of the vehicle, and to share the stop reason with passengers for comfortable driving.</p>"},{"location":"design/autoware-interfaces/ad-api/use-cases/vehicle-monitoring/#detected-objects","title":"Detected objects","text":"<p>The perception provides the objects detected by Autoware. HMI can use this to visualize objects around the vehicle.</p>"},{"location":"design/autoware-interfaces/ad-api/use-cases/vehicle-operation/","title":"Vehicle operation","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/vehicle-operation/#vehicle-operation","title":"Vehicle operation","text":""},{"location":"design/autoware-interfaces/ad-api/use-cases/vehicle-operation/#request-to-intervene","title":"Request to intervene","text":"<p>Request to intervene (RTI) is a feature that requires the operator to switch to manual driving mode. It is also called Take Over Request (TOR). Interfaces for RTI are currently being discussed. For now assume that manual driving is requested if the MRM state is not NORMAL. See fail-safe for details.</p>"},{"location":"design/autoware-interfaces/ad-api/use-cases/vehicle-operation/#request-to-cooperate","title":"Request to cooperate","text":"<p>Request to cooperate (RTC) is a feature that the operator supports the decision in autonomous driving mode. Autoware usually drives the vehicle using its own decisions, but the operator may prefer to make their own decisions in complex situations. Since RTC only overrides the decision and does not need to change operation mode, the vehicle can continue autonomous driving, unlike RTC. See cooperation for details.</p>"},{"location":"design/autoware-interfaces/components/","title":"Component interfaces","text":""},{"location":"design/autoware-interfaces/components/#component-interfaces","title":"Component interfaces","text":"<p>Warning</p> <p>Under Construction</p> <p>See here for an overview.</p>"},{"location":"design/autoware-interfaces/components/control/","title":"Control","text":""},{"location":"design/autoware-interfaces/components/control/#control","title":"Control","text":""},{"location":"design/autoware-interfaces/components/control/#inputs","title":"Inputs","text":""},{"location":"design/autoware-interfaces/components/control/#vehicle-kinematic-state","title":"Vehicle kinematic state","text":"<p>Current position and orientation of ego. Published by the Localization module.</p> <ul> <li>nav_msgs/Odometry<ul> <li>std_msgs/Header header</li> <li>string child_frame_id</li> <li>geometry_msgs/PoseWithCovariance pose</li> <li>geometry_msgs/TwistWithCovariance twist</li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/control/#trajectory","title":"Trajectory","text":"<p>trajectory to be followed by the controller. See Outputs of Planning.</p>"},{"location":"design/autoware-interfaces/components/control/#steering-status","title":"Steering Status","text":"<p>Current steering of the ego vehicle. Published by the Vehicle Interface.</p> <ul> <li>Steering message (github discussion).<ul> <li>builtin_interfaces::msg::Time stamp</li> <li>float32 steering_angle</li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/control/#actuation-status","title":"Actuation Status","text":"<p>Actuation status of the ego vehicle for acceleration, steering, and brake.</p> <p>TODO This represents the reported physical efforts exerted by the vehicle actuators. Published by the Vehicle Interface.</p> <ul> <li>ActuationStatus (github discussion).<ul> <li>builtin_interfaces::msg::Time stamp</li> <li>float32 acceleration</li> <li>float32 steering</li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/control/#output","title":"Output","text":""},{"location":"design/autoware-interfaces/components/control/#vehicle-control-command","title":"Vehicle Control Command","text":"<p>A motion signal to drive the vehicle, achieved by the low-level controller in the vehicle layer. Used by the Vehicle Interface.</p> <ul> <li>autoware_auto_control_msgs/AckermannControlCommand<ul> <li>builtin_interfaces::msg::Time stamp</li> <li>autoware_auto_control_msgs/AckermannLateralCommand lateral<ul> <li>builtin_interfaces::msg::Time stamp</li> <li>float steering_tire_angle</li> <li>float steering_tire_rotation_rate</li> </ul> </li> <li>autoware_auto_control_msgs/LongitudinalCommand longitudinal<ul> <li>builtin_interfaces::msg::Time stamp</li> <li>builtin_interfaces::msg::Duration duration</li> <li>builtin_interfaces::msg::Duration time_step</li> <li>float[] speeds</li> <li>float[] accelerations</li> <li>float[] jerks</li> </ul> </li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/localization/","title":"Localization","text":""},{"location":"design/autoware-interfaces/components/localization/#localization","title":"Localization","text":""},{"location":"design/autoware-interfaces/components/localization/#inputs","title":"Inputs","text":""},{"location":"design/autoware-interfaces/components/localization/#pointcloud-map","title":"Pointcloud Map","text":"<p>Environment map created with point cloud, published by the map server.</p> <ul> <li>sensor_msgs/msg/PointCloud2</li> </ul> <p>A 3d point cloud map is used for LiDAR-based localization in Autoware.</p>"},{"location":"design/autoware-interfaces/components/localization/#manual-initial-pose","title":"Manual Initial Pose","text":"<p>Start pose of ego, published by the user interface.</p> <ul> <li>geometry_msgs/msg/PoseWithCovarianceStamped<ul> <li>std_msgs/msg/Header header</li> <li>geometry_msgs/msg/PoseWithCovariance pose<ul> <li>geometry_msgs/msg/Pose pose<ul> <li>geometry_msgs/msg/Point position</li> <li>geometry_msg/msg/Quaternion orientation</li> </ul> </li> <li>double[36] covariance</li> </ul> </li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/localization/#3d-lidar-scanning","title":"3D-LiDAR Scanning","text":"<p>LiDAR scanning for NDT matching, published by the LiDAR sensor.</p> <ul> <li>sensor_msgs/msg/PointCloud2</li> </ul> <p>The raw 3D-LiDAR data needs to be processed by the point cloud pre-processing modules before being used for localization.</p>"},{"location":"design/autoware-interfaces/components/localization/#automatic-initial-pose","title":"Automatic Initial pose","text":"<p>Start pose of ego, calculated from INS(Inertial navigation sensor) sensing data.</p> <ul> <li>geometry_msgs/msg/PoseWithCovarianceStamped<ul> <li>std_msgs/msg/Header header</li> <li>geometry_msgs/msg/PoseWithCovariance pose<ul> <li>geometry_msgs/msg/Pose pose<ul> <li>geometry_msgs/msg/Point position</li> <li>geometry_msg/msg/Quaternion orientation</li> </ul> </li> <li>double[36] covariance</li> </ul> </li> </ul> </li> </ul> <p>When the initial pose is not set manually, the message can be used for automatic pose initialization.</p> <p>Current Geographic coordinate of the ego, published by the GNSS sensor.</p> <ul> <li>sensor_msgs/msg/NavSatFix<ul> <li>std_msgs/msg/Header header</li> <li>sensor_msgs/msg/NavSatStatus status</li> <li>double latitude</li> <li>double longitude</li> <li>double altitude</li> <li>double[9] position_covariance</li> <li>unit8 position_covariance_type</li> </ul> </li> </ul> <p>Current orientation of the ego, published by the GNSS-INS.</p> <ul> <li>autoware_sensing_msgs/msg/GnssInsOrientationStamped<ul> <li>std_msgs/Header header</li> <li>autoware_sensing_msgs/msg/GnssInsOrientation orientation<ul> <li>geometry_msgs/Quaternion orientation</li> <li>float32 rmse_rotation_x</li> <li>float32 rmse_rotation_y</li> <li>float32 rmse_rotation_z</li> </ul> </li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/localization/#imu-data","title":"IMU Data","text":"<p>Current orientation, angular velocity and linear acceleration of ego, calculated from IMU sensing data.</p> <ul> <li>sensor_msgs/msg/Imu<ul> <li>std_msgs/msg/Header header</li> <li>geometry_msgs/msg/Quaternion orientation</li> <li>double[9] orientation_covariance</li> <li>geometry_msgs/msg/Vector3 angular_velocity</li> <li>double[9] angular_velocity_covariance</li> <li>geometry_msgs/msg/Vector3 linear_acceleration</li> <li>double[9] linear_acceleration_covariance</li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/localization/#vehicle-velocity-status","title":"Vehicle Velocity Status","text":"<p>Current velocity of the ego vehicle, published by the vehicle interface.</p> <ul> <li>autoware_auto_vehicle_msgs/msg/VelocityReport<ul> <li>std_msgs/msg/Header header;</li> <li>float longitudinal_velocity;</li> <li>float lateral_velocity;</li> <li>float heading_rate;</li> </ul> </li> </ul> <p>Before the velocity input localization interface, module <code>vehicle_velocity_converter</code> converts message type <code>autoware_auto_vehicle_msgs/msg/VelocityReport</code> to <code>geometry_msgs/msg/TwistWithCovarianceStamped</code>.</p>"},{"location":"design/autoware-interfaces/components/localization/#outputs","title":"Outputs","text":""},{"location":"design/autoware-interfaces/components/localization/#vehicle-pose","title":"Vehicle pose","text":"<p>Current pose of ego, calculated from localization interface.</p> <ul> <li>geometry_msgs/msg/PoseWithCovarianceStamped<ul> <li>std_msgs/msg/Header header</li> <li>geometry_msg/PoseWithCovariance pose<ul> <li>geometry_msgs/msg/Pose pose<ul> <li>geometry_msgs/msg/Point position</li> <li>geometry_msgs/msg/Quaternion orientation</li> </ul> </li> <li>double[36] covariance</li> </ul> </li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/localization/#vehicle-velocity","title":"Vehicle velocity","text":"<p>Current velocity of ego, calculated from localization interface.</p> <ul> <li>geometry_msgs/msg/TwistWithCovarianceStamped<ul> <li>std_msgs/msg/Header header</li> <li>geometry_msg/TwistWithCovariance twist<ul> <li>geometry_msgs/msg/Twist twist<ul> <li>geometry_msgs/msg/Vector3 linear</li> <li>geometry_msgs/msg/Vector3 angular</li> </ul> </li> <li>double[36] covariance</li> </ul> </li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/localization/#vehicle-acceleration","title":"Vehicle acceleration","text":"<p>Current acceleration of ego, calculated from localization interface.</p> <ul> <li>geometry_msgs/msg/AccelWithCovarianceStamped<ul> <li>std_msgs/msg/Header header</li> <li>geometry_msg/AccelWithCovariance accel<ul> <li>geometry_msgs/msg/Accel accel<ul> <li>geometry_msgs/msg/Vector3 linear</li> <li>geometry_msgs/msg/Vector3 angular</li> </ul> </li> <li>double[36] covariance</li> </ul> </li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/localization/#vehicle-kinematic-state","title":"Vehicle kinematic state","text":"<p>Current pose, velocity and acceleration of ego, calculated from localization interface.</p> <p>Note: Kinematic state contains pose, velocity and acceleration. In the future, pose, velocity and acceleration will not be used as output for localization.</p> <ul> <li>autoware_msgs/autoware_localization_msgs/msg/KinematicState<ul> <li>std_msgs/msg/Header header</li> <li>string child_frame_id</li> <li>geometry_msgs/PoseWithCovariance pose_with_covariance</li> <li>geometry_msgs/TwistWithCovariance twist_with_covariance</li> <li>geometry_msgs/AccelWithCovariance accel_with_covariance</li> </ul> </li> </ul> <p>The message will be subscribed by the planning and control module.</p>"},{"location":"design/autoware-interfaces/components/localization/#localization-accuracy","title":"Localization Accuracy","text":"<p>Diagnostics information that indicates if the localization module works properly.</p> <p>TBD.</p>"},{"location":"design/autoware-interfaces/components/map/","title":"Map","text":""},{"location":"design/autoware-interfaces/components/map/#map","title":"Map","text":""},{"location":"design/autoware-interfaces/components/map/#overview","title":"Overview","text":"<p>Autoware relies on high-definition point cloud maps and vector maps of the driving environment to perform various tasks. Before launching Autoware, you need to load the pre-created map files.</p>"},{"location":"design/autoware-interfaces/components/map/#inputs","title":"Inputs","text":"<ul> <li>Point cloud maps (<code>.pcd</code>)</li> <li>Lanelet2 maps (<code>.osm</code>)</li> </ul> <p>Refer to Creating maps on how to create maps.</p>"},{"location":"design/autoware-interfaces/components/map/#outputs","title":"Outputs","text":""},{"location":"design/autoware-interfaces/components/map/#point-cloud-map","title":"Point cloud map","text":"<p>It loads point cloud files and publishes the maps to the other Autoware nodes in various configurations. Currently, it supports the following types:</p> <ul> <li>Raw point cloud map (sensor_msgs/msg/PointCloud2)</li> <li>Downsampled point cloud map (sensor_msgs/msg/PointCloud2)</li> <li>Partial point cloud map loading via ROS service (autoware_map_msgs/srv/GetPartialPointCloudMap)</li> <li>Differential point cloud map loading via ROS service (autoware_map_msgs/srv/GetDifferentialPointCloudMap)</li> </ul>"},{"location":"design/autoware-interfaces/components/map/#lanelet2-map","title":"Lanelet2 map","text":"<p>It loads a Lanelet2 file and publishes the map data as <code>autoware_auto_mapping_msgs/msg/HADMapBin</code> message. The lan/lon coordinates are projected onto the MGRS coordinates.</p> <ul> <li>autoware_auto_mapping_msgs/msg/HADMapBin<ul> <li>std_msgs/Header header</li> <li>string version_map_format</li> <li>string version_map</li> <li>string name_map</li> <li>uint8[] data</li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/map/#lanelet2-map-visualization","title":"Lanelet2 map visualization","text":"<p>Visualize <code>autoware_auto_mapping_msgs/HADMapBin</code> messages in <code>Rviz</code>.</p> <ul> <li>visualization_msgs/msg/MarkerArray</li> </ul>"},{"location":"design/autoware-interfaces/components/perception-interface/","title":"Perception","text":""},{"location":"design/autoware-interfaces/components/perception-interface/#perception","title":"Perception","text":"<pre><code>graph TD\n    cmp_sen(\"Sensing\"):::cls_sen\n    cmp_loc(\"Localization\"):::cls_loc\n    cmp_per(\"Perception\"):::cls_per\n    cmp_plan(\"Planning\"):::cls_plan\n\n    msg_img(\"&lt;font size=2&gt;&lt;b&gt;Camera Image&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/Image&lt;/font size&gt;\"):::cls_sen\n\n    msg_ldr(\"&lt;font size=2&gt;&lt;b&gt;Lidar Point Cloud&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/PointCloud2&lt;/font size&gt;\"):::cls_sen\n\n    msg_lanenet(\"&lt;font size=2&gt;&lt;b&gt;Lanelet2 Map&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;autoware_auto_mapping_msgs/HADMapBin&lt;/font size&gt;\"):::cls_loc\n\n    msg_vks(\"&lt;font size=2&gt;&lt;b&gt;Vehicle Kinematic State&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;nav_msgs/Odometry&lt;/font size&gt;\"):::cls_loc\n\n    msg_obj(\"&lt;font size=2&gt;&lt;b&gt;3D Object Predictions &lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;autoware_auto_perception_msgs/PredictedObjects&lt;/font size&gt;\"):::cls_per\n\n    msg_tl(\"&lt;font size=2&gt;&lt;b&gt;Traffic Light Response &lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;autoware_perception_msgs/TrafficSignalArray&lt;/font size&gt;\"):::cls_per\n\n    msg_tq(\"&lt;font size=2&gt;&lt;b&gt;Traffic Light Query &lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;TBD&lt;/font size&gt;\"):::cls_plan\n\n\n    cmp_sen --&gt; msg_img --&gt; cmp_per\n    cmp_sen --&gt; msg_ldr --&gt; cmp_per\n    cmp_per --&gt; msg_obj --&gt; cmp_plan\n    cmp_per --&gt; msg_tl --&gt; cmp_plan\n    cmp_plan --&gt; msg_tq --&gt;cmp_per\n\n    cmp_loc --&gt; msg_vks --&gt; cmp_per\n    cmp_loc --&gt; msg_lanenet --&gt; cmp_per\n\nclassDef cmp_sen fill:#F8CECC,stroke:#999,stroke-width:1px;\nclassDef cls_loc fill:#D5E8D4,stroke:#999,stroke-width:1px;\nclassDef cls_per fill:#FFF2CC,stroke:#999,stroke-width:1px;\nclassDef cls_plan fill:#5AB8FF,stroke:#999,stroke-width:1px;</code></pre>"},{"location":"design/autoware-interfaces/components/perception-interface/#inputs","title":"Inputs","text":""},{"location":"design/autoware-interfaces/components/perception-interface/#pointcloud","title":"PointCloud","text":"<p>PointCloud data published by Lidar.</p> <ul> <li>sensor_msgs/msg/PointCloud2</li> </ul>"},{"location":"design/autoware-interfaces/components/perception-interface/#image","title":"Image","text":"<p>Image frame captured by camera.</p> <ul> <li>sensor_msgs/msg/Image</li> </ul>"},{"location":"design/autoware-interfaces/components/perception-interface/#vehicle-kinematic-state","title":"Vehicle kinematic state","text":"<p>current position of ego, used in traffic signals recognition. See output of Localization.</p>"},{"location":"design/autoware-interfaces/components/perception-interface/#lanelet2-map","title":"Lanelet2 Map","text":"<p>map of the environment. See outputs of Map.</p>"},{"location":"design/autoware-interfaces/components/perception-interface/#output","title":"Output","text":""},{"location":"design/autoware-interfaces/components/perception-interface/#3d-object-predictions","title":"3D Object Predictions","text":"<p>3D Objects detected, tracked and predicted by sensor fusing.</p> <ul> <li>autoware_auto_perception_msgs/msg/PredictedObjects<ul> <li>std_msgs/Header header</li> <li>sequence&lt;autoware_auto_perception_msgs::msg::PredictedObject&gt; objects<ul> <li>unique_identifier_msgs::msg::UUID uuid</li> <li>float existence_probability</li> <li>sequence&lt;autoware_auto_perception_msgs::msg::ObjectClassification&gt; classification<ul> <li>uint8 classification</li> <li>float probability</li> </ul> </li> <li>autoware_auto_perception_msgs::msg::PredictedObjectKinematics kinematics<ul> <li>geometry_msgs::msg::PoseWithCovariance initial_pose</li> <li>geometry_msgs::msg::TwistWithCovariance</li> <li>geometry_msgs::msg::AccelWithCovariance initial_acceleration</li> <li>sequence&lt;autoware_auto_perception_msgs::msg::PredictedPath, 10&gt; predicted_paths<ul> <li>sequence&lt;geometry_msgs::msg::Pose, 100&gt; path</li> <li>builtin_interfaces::msg::Duration time_step</li> <li>float confidence</li> </ul> </li> </ul> </li> <li>sequence&lt;autoware_auto_perception_msgs::msg::Shape, 5&gt; shape<ul> <li>geometry_msgs::msg::Polygon polygon</li> <li>float height</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/perception-interface/#traffic-signals","title":"Traffic Signals","text":"<p>traffic signals recognized by object detection model.</p> <ul> <li>autoware_perception_msgs::msg::TrafficSignalArray<ul> <li>autoware_perception_msgs::msg::TrafficSignal signals<ul> <li>autoware_perception_msgs::msg::TrafficSignalElement elements<ul> <li>uint8 UNKNOWN = 0</li> <li>uint8 Red = 1</li> <li>uint8 AMBER = 2</li> <li>uint8 WHITE = 4</li> <li>uint8 CIRCLE = 1</li> <li>uint8 LEFT_ARROW = 2</li> <li>uint8 RIGHT_ARROW = 3</li> <li>uint8 UP_ARROW = 4</li> <li>uint8 UP_LEFT_ARROW=5</li> <li>uint8 UP_RIGHT_ARROW=6</li> <li>uint8 DOWN_ARROW = 7</li> <li>uint8 DOWN_LEFT_ARROW = 8</li> <li>uint8 DOWN_RIGHT_ARROW = 9</li> <li>uint8 CROSS = 10</li> <li>uint8 SOLID_OFF = 1</li> <li>uint8 SOLID_ON = 2</li> <li>uint8 FLASHING = 3</li> <li>uint8 color</li> <li>uint8 shape</li> <li>uint8 status</li> <li>float32 confidence</li> </ul> </li> <li>int64 traffic_signal_id</li> </ul> </li> <li>builtin_interfaces::msg::Time stamp</li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/perception/","title":"Perception","text":""},{"location":"design/autoware-interfaces/components/perception/#perception","title":"Perception","text":"<p>This page provides specific specifications about the Interface of the Perception Component. Please refer to the perception architecture reference implementation design for concepts and data flow.</p>"},{"location":"design/autoware-interfaces/components/perception/#input","title":"Input","text":""},{"location":"design/autoware-interfaces/components/perception/#from-map-component","title":"From Map Component","text":"Name Topic / Service Type Description Vector Map <code>/map/vector_map</code> autoware_auto_mapping_msgs/msg/HADMapBin HD Map including the information about lanes Point Cloud Map <code>/service/get_differential_pcd_map</code> autoware_map_msgs/srv/GetDifferentialPointCloudMap Point Cloud Map <p>Notes:</p> <ul> <li>Point Cloud Map<ul> <li>input can be both topic or service, but we highly recommend to use service because since this interface enables processing without being constrained by map file size limits.</li> </ul> </li> </ul>"},{"location":"design/autoware-interfaces/components/perception/#from-sensing-component","title":"From Sensing Component","text":"Name Topic Type Description Camera Image <code>/sensing/camera/camera*/image_rect_color</code> sensor_msgs/Image Camera image data, processed with Lens Distortion Correction (LDC) Camera Image <code>/sensing/camera/camera*/image_raw</code> sensor_msgs/Image Camera image data, not processed with Lens Distortion Correction (LDC) Point Cloud <code>/sensing/lidar/concatenated/pointcloud</code> sensor_msgs/PointCloud2 Concatenated point cloud from multiple LiDAR sources Radar Object <code>/sensing/radar/detected_objects</code> autoware_auto_perception_msgs/msg/DetectedObject Radar objects"},{"location":"design/autoware-interfaces/components/perception/#from-localization-component","title":"From Localization Component","text":"Name Topic Type Description Vehicle Odometry <code>/localization/kinematic_state</code> nav_msgs/msg/Odometry Ego vehicle odometry topic"},{"location":"design/autoware-interfaces/components/perception/#from-api","title":"From API","text":"Name Topic Type Description External Traffic Signals <code>/external/traffic_signals</code> autoware_perception_msgs::msg::TrafficSignalArray The traffic signals from an external system"},{"location":"design/autoware-interfaces/components/perception/#output","title":"Output","text":""},{"location":"design/autoware-interfaces/components/perception/#to-planning","title":"To Planning","text":"<p>Please refer to the perception component design for detailed definitions of each output.\"</p> Name Topic Type Description Dynamic Objects <code>/perception/object_recognition/objects</code> autoware_auto_perception_msgs/msg/PredictedObjects Set of dynamic objects with information such as a object class and a shape of the objects. These objects did not exist when the map was generated and are not contained within the map. Obstacles <code>/perception/obstacle_segmentation/pointcloud</code> sensor_msgs/PointCloud2 Obstacles, including both dynamic objects and static obstacles that requires the ego vehicle either steer clear of them or come to a stop in front of the obstacles. Occupancy Grid Map <code>/perception/occupancy_grid_map/map</code> nav_msgs/msg/OccupancyGrid The map with the information about the presence of obstacles and blind spot Traffic Signal <code>/perception/traffic_light_recognition/traffic_signals</code> autoware_perception_msgs::msg::TrafficSignalArray The traffic signal information such as a color (green, yellow, read) and an arrow (right, left, straight)"},{"location":"design/autoware-interfaces/components/planning/","title":"Planning","text":""},{"location":"design/autoware-interfaces/components/planning/#planning","title":"Planning","text":"<p>This page provides specific specifications about the Interface of the Planning Component. Please refer to the planning architecture design document for high-level concepts and data flow.</p> <p>TODO: The detailed definitions (meanings of elements included in each topic) are not described yet, need to be updated.</p>"},{"location":"design/autoware-interfaces/components/planning/#input","title":"Input","text":""},{"location":"design/autoware-interfaces/components/planning/#from-map-component","title":"From Map Component","text":"Name Topic Type Description Vector Map <code>/map/vector_map</code> autoware_auto_mapping_msgs/msg/HADMapBin Map of the environment where the planning takes place."},{"location":"design/autoware-interfaces/components/planning/#from-localization-component","title":"From Localization Component","text":"Name Topic Type Description Vehicle Kinematic State <code>/localization/kinematic_state</code> nav_msgs/msg/Odometry Current position, orientation and velocity of ego. Vehicle Acceleration <code>/localization/acceleration</code> geometry_msgs/msg/AccelWithCovarianceStamped Current acceleration of ego. <p>TODO: acceleration information should be merged into the kinematic state.</p>"},{"location":"design/autoware-interfaces/components/planning/#from-perception-component","title":"From Perception Component","text":"Name Topic Type Description Objects <code>/perception/object_recognition/objects</code> autoware_auto_perception_msgs/msg/PredictedObjects Set of perceived objects around ego that need to be avoided or followed when planning a trajectory. This contains semantics information such as a object class (e.g. vehicle, pedestrian, etc) or a shape of the objects. Obstacles <code>/perception/obstacle_segmentation/pointcloud</code> sensor_msgs/msg/PointCloud2 Set of perceived obstacles around ego that need to be avoided or followed when planning a trajectory. This only contains a primitive information of the obstacle. No shape nor velocity information. Occupancy Grid Map <code>/perception/occupancy_grid_map/map</code> nav_msgs/msg/OccupancyGrid Contains the presence of obstacles and blind spot information (represented as UNKNOWN). Traffic Signal <code>/perception/traffic_light_recognition/traffic_signals</code> autoware_auto_perception_msgs/msg/TrafficSignalArray Contains the traffic signal information such as a color (green, yellow, read) and an arrow (right, left, straight). <p>TODO: The type of the <code>Obstacles</code> information should not depend on the specific sensor message type (now <code>PointCloud</code>). It needs to be fixed.</p>"},{"location":"design/autoware-interfaces/components/planning/#from-api","title":"From API","text":"Name Topic Type Description Max Velocity <code>/planning/scenario_planning/max_velocity_default</code> autoware_adapi_v1_msgs/srv/SetRoutePoints Indicate the maximum value of the vehicle speed plan Operation Mode <code>/system/operation_mode/state</code> autoware_adapi_v1_msgs/msg/OperationModeState Indicates the current operation mode (automatic/manual, etc.). Route Set <code>/planning/mission_planning/set_route</code> autoware_adapi_v1_msgs/srv/SetRoute Indicates to set the route when the vehicle is stopped. Route Points Set <code>/planning/mission_planning/set_route_points</code> autoware_adapi_v1_msgs/srv/SetRoutePoints Indicates to set the route with points when the vehicle is stopped. Route Change <code>/planning/mission_planning/change_route</code> autoware_adapi_v1_msgs/srv/SetRoute Indicates to change the route when the vehicle is moving. Route Points Change <code>/planning/mission_planning/change_route_points</code> autoware_adapi_v1_msgs/srv/SetRoutePoints Indicates to change the route with points when the vehicle is moving. Route Clear <code>/planning/mission_planning/clear_route</code> autoware_adapi_v1_msgs/srv/ClearRoute Indicates to clear the route information. MRM Route Set Points <code>/planning/mission_planning/mission_planner/srv/set_mrm_route</code> autoware_adapi_v1_msgs/srv/SetRoutePoints Indicates to set the emergency route. MRM Route Clear <code>/planning/mission_planning/mission_planner/srv/clear_mrm_route</code> autoware_adapi_v1_msgs/srv/SetRoutePoints Indicates to clear the emergency route."},{"location":"design/autoware-interfaces/components/planning/#output","title":"Output","text":""},{"location":"design/autoware-interfaces/components/planning/#to-control","title":"To Control","text":"Name Topic Type Description Trajectory <code>/planning/trajectory</code> autoware_auto_planning_msgs/msg/Trajectory A sequence of space and velocity and acceleration points to be followed by the controller. Turn Indicator <code>/planning/turn_indicators_cmd</code> autoware_auto_vehicle_msgs/msg/TurnIndicatorsCommand Turn indicator signal to be followed by the vehicle. Hazard Light <code>/planning/hazard_lights_cmd</code> autoware_auto_vehicle_msgs/msg/HazardLightsCommand Hazard light signal to be followed by the vehicle."},{"location":"design/autoware-interfaces/components/planning/#to-system","title":"To System","text":"Name Topic Type Description Diagnostics <code>/planning/hazard_lights_cmd</code> diagnostic_msgs/msg/DiagnosticArray Diagnostic status of the Planning component reported to the System component."},{"location":"design/autoware-interfaces/components/planning/#to-api","title":"To API","text":"Name Topic Type Description Path Candidate <code>/planning/path_candidate/*</code> autoware_auto_planning_msgs/msg/Path The path Autoware is about to take. Users can interrupt the operation based on the path candidate information. Steering Factor <code>/planning/steering_factor/*</code> autoware_adapi_v1_msgs/msg/SteeringFactorArray Information about the steering maneuvers performed by Autoware (e.g., steering to the right for a right turn, etc.) Velocity Factor <code>/planning/velocity_factors/*</code> autoware_adapi_v1_msgs/msg/VelocityFactorArray Information about the velocity maneuvers performed by Autoware (e.g., stop for an obstacle, etc.)"},{"location":"design/autoware-interfaces/components/planning/#planning-internal-interface","title":"Planning internal interface","text":"<p>This section explains the communication between the different planning modules shown in the Planning Architecture Design.</p> <p></p>"},{"location":"design/autoware-interfaces/components/planning/#from-mission-planning-to-scenario-planning","title":"From Mission Planning to Scenario Planning","text":"Name Topic Type Description Route <code>/planning/mission_planning/route</code> autoware_planning_msgs/msg/LaneletRoute A sequence of lane IDs on a Lanelet map, from the starting point to the destination."},{"location":"design/autoware-interfaces/components/planning/#from-behavior-planning-to-motion-planning","title":"From Behavior Planning to Motion Planning","text":"Name Topic Type Description Path <code>/planning/scenario_planning/lane_driving/behavior_planning/path</code> autoware_auto_planning_msgs/msg/Path A sequence of approximate vehicle positions for driving, along with information on the maximum speed and the drivable areas. Modules receiving this message are expected to make changes to the path within the constraints of the drivable areas and the maximum speed, generating the desired final trajectory."},{"location":"design/autoware-interfaces/components/planning/#from-scenario-planning-to-validation","title":"From Scenario Planning to Validation","text":"Name Topic Type Description Trajectory <code>/planning/scenario_planning/trajectory</code> autoware_auto_planning_msgs/msg/Trajectory A sequence of precise vehicle positions, speeds, and accelerations required for driving. It is expected that the vehicle will follow this trajectory."},{"location":"design/autoware-interfaces/components/sensing/","title":"Sensing","text":""},{"location":"design/autoware-interfaces/components/sensing/#sensing","title":"Sensing","text":"<pre><code>graph TD\n    cmp_drv(\"Drivers\"):::cls_drv\n    cmp_loc(\"Localization\"):::cls_loc\n    cmp_per(\"Perception\"):::cls_per\n    cmp_sen(\"Preprocessors\"):::cls_sen\n    msg_ult(\"&lt;font size=2&gt;&lt;b&gt;Ultrasonics&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/Range&lt;/font size&gt;\"):::cls_drv\n    msg_img(\"&lt;font size=2&gt;&lt;b&gt;Camera Image&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/Image&lt;/font size&gt;\"):::cls_drv\n    msg_ldr(\"&lt;font size=2&gt;&lt;b&gt;Lidar Point Cloud&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/PointCloud2&lt;/font size&gt;\"):::cls_drv\n    msg_rdr_t(\"&lt;font size=2&gt;&lt;b&gt;Radar Tracks&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;radar_msgs/RadarTracks&lt;/font size&gt;\"):::cls_drv\n    msg_rdr_s(\"&lt;font size=2&gt;&lt;b&gt;Radar Scan&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;radar_msgs/RadarScan&lt;/font size&gt;\"):::cls_drv\n    msg_gnss(\"&lt;font size=2&gt;&lt;b&gt;GNSS-INS Position&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/NavSatFix&lt;/font size&gt;\"):::cls_drv\n    msg_gnssori(\"&lt;font size=2&gt;&lt;b&gt;GNSS-INS Orientation&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;autoware_sensing_msgs/GnssInsOrientationStamped&lt;/font size&gt;\"):::cls_drv\n    msg_gnssvel(\"&lt;font size=2&gt;&lt;b&gt;GNSS Velocity&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;geometry_msgs/TwistWithCovarianceStamped&lt;/font size&gt;\"):::cls_drv\n    msg_gnssacc(\"&lt;font size=2&gt;&lt;b&gt;GNSS Acceleration&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;geometry_msgs/AccelWithCovarianceStamped&lt;/font size&gt;\"):::cls_drv\n    msg_ult_sen(\"&lt;font size=2&gt;&lt;b&gt;Ultrasonics&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/Range&lt;/font size&gt;\"):::cls_sen\n    msg_img_sen(\"&lt;font size=2&gt;&lt;b&gt;Camera Image&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/Image&lt;/font size&gt;\"):::cls_sen\n    msg_pc_combined_rdr(\"&lt;font size=2&gt;&lt;b&gt;Combined Radar Tracks&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;radar_msgs/RadarTracks&lt;/font size&gt;\"):::cls_sen\n    msg_pc_rdr(\"&lt;font size=2&gt;&lt;b&gt;Radar Pointcloud&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;radar_msgs/RadarScan&lt;/font size&gt;\"):::cls_sen\n    msg_pc_ldr(\"&lt;font size=2&gt;&lt;b&gt;Lidar Point Cloud&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/PointCloud2&lt;/font size&gt;\"):::cls_sen\n    msg_pose_gnss(\"&lt;font size=2&gt;&lt;b&gt;GNSS-INS Pose&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;geometry_msgs/PoseWithCovarianceStamped&lt;/font size&gt;\"):::cls_sen\n    msg_gnssori_sen(\"&lt;font size=2&gt;&lt;b&gt;GNSS-INS Orientation&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;sensor_msgs/Imu&lt;/font size&gt;\"):::cls_sen\n    msg_gnssvel_sen(\"&lt;font size=2&gt;&lt;b&gt;GNSS Velocity&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;geometry_msgs/TwistWithCovarianceStamped&lt;/font size&gt;\"):::cls_sen\n    msg_gnssacc_sen(\"&lt;font size=2&gt;&lt;b&gt;GNSS-INS Acceleration&lt;/b&gt;&lt;/font size&gt;\n    &lt;font size=1&gt;geometry_msgs/AccelWithCovarianceStamped&lt;/font size&gt;\"):::cls_sen\n\n    cmp_drv --&gt; msg_ult --&gt; cmp_sen\n    cmp_drv --&gt; msg_img --&gt; cmp_sen\n    cmp_drv --&gt; msg_rdr_t --&gt; cmp_sen\n    cmp_drv --&gt; msg_rdr_s --&gt; cmp_sen\n    cmp_drv --&gt; msg_ldr --&gt; cmp_sen\n    cmp_drv --&gt; msg_gnss --&gt; cmp_sen\n    cmp_drv --&gt; msg_gnssori --&gt; cmp_sen\n    cmp_drv --&gt; msg_gnssvel --&gt; cmp_sen\n    cmp_drv --&gt; msg_gnssacc --&gt; cmp_sen\n\n    cmp_sen --&gt; msg_ult_sen\n    cmp_sen --&gt; msg_img_sen\n    cmp_sen --&gt; msg_gnssori_sen\n    cmp_sen --&gt; msg_gnssvel_sen\n    cmp_sen --&gt; msg_pc_combined_rdr\n    cmp_sen --&gt; msg_pc_rdr\n    cmp_sen --&gt; msg_pc_ldr\n    cmp_sen --&gt; msg_pose_gnss\n    cmp_sen --&gt; msg_gnssacc_sen\n    msg_ult_sen --&gt; cmp_per\n    msg_img_sen --&gt; cmp_per\n    msg_pc_combined_rdr --&gt; cmp_per\n    msg_pc_rdr --&gt; cmp_per\n    msg_pc_ldr --&gt; cmp_per\n    msg_pc_ldr --&gt; cmp_loc\n    msg_pose_gnss --&gt; cmp_loc\n    msg_gnssori_sen --&gt; cmp_loc\n    msg_gnssvel_sen --&gt; cmp_loc\n    msg_gnssacc_sen --&gt; cmp_loc\nclassDef cls_drv fill:#F8CECC,stroke:#999,stroke-width:1px;\nclassDef cls_loc fill:#D5E8D4,stroke:#999,stroke-width:1px;\nclassDef cls_per fill:#FFF2CC,stroke:#999,stroke-width:1px;\nclassDef cls_sen fill:#FFE6CC,stroke:#999,stroke-width:1px;</code></pre>"},{"location":"design/autoware-interfaces/components/sensing/#inputs","title":"Inputs","text":"Name Topic Type Description Ultrasonics T.B.D sensor_msgs/Range Distance data from ultrasonic radar driver. Camera Image T.B.D sensor_msgs/Image Image data from camera driver. Radar Tracks T.B.D radar_msgs/RadarTracks Tracks from radar driver. Radar Scan T.B.D radar_msgs/RadarScan Scan from radar driver. Lidar Point Cloud <code>/sensing/lidar/&lt;lidar name&gt;/pointcloud_raw</code> sensor_msgs/PointCloud2 Pointcloud from lidar driver. GNSS-INS Position T.B.D geometry_msgs/NavSatFix Initial pose from GNSS driver. GNSS-INS Orientation T.B.D autoware_sensing_msgs/GnssInsOrientationStamped Initial orientation from GNSS driver. GNSS Velocity T.B.D geometry_msgs/TwistWithCovarianceStamped Initial velocity from GNSS driver. GNSS Acceleration T.B.D geometry_msgs/AccelWithCovarianceStamped Initial acceleration from GNSS driver."},{"location":"design/autoware-interfaces/components/sensing/#output","title":"Output","text":"Name Topic Type Description Ultrasonics T.B.D sensor_msgs/Range Distance data from ultrasonic radar. Used by the Perception. Camera Image T.B.D sensor_msgs/Image Image data from camera. Used by the Perception. Combined Radar Tracks T.B.D radar_msgs/RadarTracks.msg Radar tracks from radar. Used by the Perception. Radar Point Cloud T.B.D radar_msgs/RadarScan.msg Pointcloud from radar. Used by the Perception. Lidar Point Cloud <code>/sensing/lidar/&lt;lidar group&gt;/pointcloud</code> sensor_msgs/PointCloud2 Lidar pointcloud after preprocessing. Used by the Perception and Localization. <code>&lt;lidar group&gt;</code> is a unique name for identifying each LiDAR or the group name when multiple LiDARs are combined. Specifically, the concatenated point cloud of all LiDARs is assigned the <code>&lt;lidar group&gt;</code> name <code>concatenated</code>. GNSS-INS pose T.B.D geometry_msgs/PoseWithCovarianceStamped Initial pose of the ego vehicle from GNSS. Used by the Localization. GNSS-INS Orientation T.B.D sensor_msgs/Imu Orientation info from GNSS. Used by the Localization. GNSS Velocity T.B.D geometry_msgs/TwistWithCovarianceStamped Velocity of the ego vehicle from GNSS. Used by the Localization. GNSS Acceleration T.B.D geometry_msgs/AccelWithCovarianceStamped Acceleration of the ego vehicle from GNSS. Used by the Localization."},{"location":"design/autoware-interfaces/components/vehicle-dimensions/","title":"Vehicle dimensions","text":""},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#vehicle-dimensions","title":"Vehicle dimensions","text":""},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#vehicle-axes-and-base_link","title":"Vehicle axes and base_link","text":"<p>The <code>base_link</code> frame is used very frequently throughout the Autoware stack, and is a projection of the rear-axle center onto the ground surface.</p> <ul> <li>Localization module outputs the <code>map</code> to <code>base_link</code> transformation.</li> <li>Planning module plans the poses for where the <code>base_link</code> frame should be in the future.</li> <li>Control module tries to fit <code>base_link</code> to incoming poses.</li> </ul>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#vehicle-dimensions_1","title":"Vehicle dimensions","text":""},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#wheelbase","title":"wheelbase","text":"<p>The distance between front and rear axles.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#track_width","title":"track_width","text":"<p>The distance between left and right wheels.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#overhangs","title":"Overhangs","text":"<p>Overhangs are part of the minimum safety box calculation.</p> <p>When measuring overhangs, side mirrors, protruding sensors and wheels should be taken into consideration.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#left_overhang","title":"left_overhang","text":"<p>The distance between the axis centers of the left wheels and the left-most point of the vehicle.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#right_overhang","title":"right_overhang","text":"<p>The distance between the axis centers of the right wheels and the right-most point of the vehicle.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#front_overhang","title":"front_overhang","text":"<p>The distance between the front axle and the foremost point of the vehicle.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#rear_overhang","title":"rear_overhang","text":"<p>The distance between the rear axle and the rear-most point of the vehicle.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#vehicle_length","title":"vehicle_length","text":"<p>Total length of the vehicle. Calculated by <code>front_overhang + wheelbase + rear_overhang</code></p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#vehicle_width","title":"vehicle_width","text":"<p>Total width of the vehicle. Calculated by <code>left_overhang + track_width + right_overhang</code></p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#wheel-parameters","title":"Wheel parameters","text":""},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#wheel_width","title":"wheel_width","text":"<p>The lateral width of a wheel tire, primarily used for dead reckoning.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#wheel_radius","title":"wheel_radius","text":"<p>The radius of the wheel, primarily used for dead reckoning.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#polygon_footprint","title":"polygon_footprint","text":"<p>The polygon defines the minimum collision area for the vehicle.</p> <p>The points should be ordered clockwise, with the origin on the <code>base_link</code>.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#wheel-orientations","title":"Wheel orientations","text":"<p>If the vehicle is going forward, a positive wheel angle will result in the vehicle turning left.</p> <p>Autoware assumes the rear wheels don't turn on <code>z</code> axis.</p>"},{"location":"design/autoware-interfaces/components/vehicle-dimensions/#notice","title":"Notice","text":"<p>The vehicle used in the illustrations was created by xvlblo22 and is from https://www.turbosquid.com/3d-models/modular-sedan-3d-model-1590886.</p>"},{"location":"design/autoware-interfaces/components/vehicle-interface/","title":"Vehicle Interface","text":""},{"location":"design/autoware-interfaces/components/vehicle-interface/#vehicle-interface","title":"Vehicle Interface","text":"<p>This page describes the Vehicle Interface Component. Please refer to the Vehicle Interface design document for high-level concepts and data flow.</p> <p></p> <p>The <code>Vehicle Interface Component</code> receives <code>Vehicle commands</code> and publishes <code>Vehicle statuses</code>. It communicates with the vehicle by the vehicle-specific protocol.</p> <p>The optional <code>Vehicle command adapter</code> converts generalized control command (target steering, steering rate, velocity, acceleration) into vehicle-specific control values (steering-torque, wheel-torque, voltage, pressure, acceleration pedal position, etc).</p>"},{"location":"design/autoware-interfaces/components/vehicle-interface/#communication-with-the-vehicle","title":"Communication with the vehicle","text":"<p>The interface to communicate with the vehicle varies between brands and models. For example a vehicle specific message protocol like CAN (Controller Area Network) with a ROS 2 interface (e.g., pacmod). In addition, an Autoware specific interface is often necessary (e.g., pacmod_interface).</p>"},{"location":"design/autoware-interfaces/components/vehicle-interface/#vehicle-adapter","title":"Vehicle adapter","text":"<p>Autoware's basic control command express the target motion of the vehicle in terms of speed, acceleration, steering angle, and steering rate. This may not be suitable for all vehicles and we thus distinguish between two types of vehicles.</p> <ul> <li>Type 1: vehicle that is directly controlled by a subset of speed, acceleration, steering angle, and steering rate.</li> <li>Type 2: vehicle that uses custom commands (motor torque, voltage, pedal pressure, etc).</li> </ul> <p>For vehicles of type 2, a vehicle adapter is necessary to convert the Autoware control command into the vehicle specific commands. For an example, see the raw_vehicle_cmd_converter which converts the target speed and steering angle to acceleration, steering, and brake mechanical inputs.</p>"},{"location":"design/autoware-interfaces/components/vehicle-interface/#inputs-from-autoware","title":"Inputs from Autoware","text":"Name Topic Type Description Control command <code>/control/command/control_cmd</code> autoware_auto_control_msgs/msg/AckermannControlCommand Target controls of the vehicle (steering angle, velocity, ...) Control mode command <code>/control/control_mode_request</code> ControlModeCommand Request to switch between manual and autonomous driving Gear command <code>/control/command/gear_cmd</code> autoware_auto_vehicle_msgs/msg/GearCommand Target gear of the vehicle Hazard lights command <code>/control/command/hazard_lights_cmd</code> autoware_auto_vehicle_msgs/msg/HazardLightsCommand Target values of the hazard lights Turn indicator command <code>/control/command/turn_indicators_cmd</code> autoware_auto_vehicle_msgs/msg/TurnIndicatorsCommand Target values of the turn signals"},{"location":"design/autoware-interfaces/components/vehicle-interface/#outputs-to-autoware","title":"Outputs to Autoware","text":"Name Topic Type Optional ? Description Actuation status <code>/vehicle/status/actuation_status</code> tier4_vehicle_msgs/msg/ActuationStatusStamped Yes (vehicle with mechanical inputs) Current acceleration, brake, and steer values reported by the vehicle Control mode <code>/vehicle/status/control_mode</code> autoware_auto_vehicle_msgs/msg/ControlModeReport Current control mode (manual, autonomous, ...) Door status <code>/vehicle/status/door_status</code> tier4_api_msgs/msg/DoorStatus Yes Current door status Gear report <code>/vehicle/status/gear_status</code> autoware_auto_vehicle_msgs/msg/GearReport Current gear of the vehicle Hazard light status <code>/vehicle/status/hazard_lights_status</code> autoware_auto_vehicle_msgs/msg/HazardLightsReport Current hazard lights status Steering status <code>/vehicle/status/steering_status</code> autoware_auto_vehicle_msgs/msg/SteeringReport Current steering angle of the steering tire Steering wheel status <code>/vehicle/status/steering_wheel_status</code> tier4_vehicle_msgs/msg/SteeringWheelStatusStamped Yes Current steering wheel angle Turn indicators status <code>/vehicle/status/turn_indicators_status</code> autoware_auto_vehicle_msgs/msg/TurnIndicatorsReport Current state of the left and right turn indicators Velocity status <code>/vehicle/status/velocity_status</code> autoware_auto_vehicle_msgs/msg/VelocityReport Current velocities of the vehicle (longitudinal, lateral, heading rate)"},{"location":"design/configuration-management/","title":"Configuration management","text":""},{"location":"design/configuration-management/#configuration-management","title":"Configuration management","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/configuration-management/development-process/","title":"Development process","text":""},{"location":"design/configuration-management/development-process/#development-process","title":"Development process","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/configuration-management/release-process/","title":"Release process","text":""},{"location":"design/configuration-management/release-process/#release-process","title":"Release process","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"design/configuration-management/repository-structure/","title":"Repository structure","text":""},{"location":"design/configuration-management/repository-structure/#repository-structure","title":"Repository structure","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"how-to-guides/","title":"How-to guides","text":""},{"location":"how-to-guides/#how-to-guides","title":"How-to guides","text":""},{"location":"how-to-guides/#integrating-autoware","title":"Integrating Autoware","text":"<ul> <li>Overview</li> </ul>"},{"location":"how-to-guides/#training-machine-learning-models","title":"Training Machine Learning Models","text":"<ul> <li>Training and Deploying Models</li> </ul>"},{"location":"how-to-guides/#others","title":"Others","text":"<ul> <li>Debug Autoware</li> <li>Running Autoware without CUDA</li> <li>Fixing dependent package versions</li> <li>Add a custom ROS message</li> <li>Determining component dependencies</li> <li>Advanced usage of colcon</li> <li>Applying Clang-Tidy to ROS packages</li> <li>Defining temporal performance metrics on components</li> <li>An example procedure for adding and evaluating a new node</li> </ul> <p>TODO: Write the following contents.</p> <ul> <li>Create an Autoware package</li> <li>etc.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/overview/","title":"Overview","text":""},{"location":"how-to-guides/integrating-autoware/overview/#overview","title":"Overview","text":""},{"location":"how-to-guides/integrating-autoware/overview/#requirement-prepare-your-real-vehicle-hardware","title":"Requirement: prepare your real vehicle hardware","text":"<p>Prerequisites for the vehicle:</p> <ul> <li>An onboard computer that satisfies the Autoware installation prerequisites</li> <li>The following devices attached<ul> <li>Drive-by-wire interface</li> <li>LiDAR</li> <li>Optional: Inertial measurement unit</li> <li>Optional: Camera</li> <li>Optional: GNSS</li> </ul> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/overview/#1-creating-your-autoware-meta-repository","title":"1. Creating your Autoware meta-repository","text":"<p>Create your Autoware meta-repository. One easy way is to fork autowarefoundation/autoware and clone it. For how to fork a repository, refer to GitHub Docs.</p> <pre><code>git clone https://github.com/YOUR_NAME/autoware.git\n</code></pre> <p>If you set up multiple types of vehicles, adding a suffix like \"autoware.vehicle_A\" or \"autoware.vehicle_B\" is recommended.</p>"},{"location":"how-to-guides/integrating-autoware/overview/#2-creating-the-your-vehicle-and-sensor-description","title":"2. Creating the your vehicle and sensor description","text":"<p>Next, you need to create description packages that define the vehicle and sensor configuration of your vehicle.</p> <p>Create the following two packages:</p> <ul> <li>YOUR_VEHICLE_launch (see here for example)</li> <li>YOUR_SENSOR_KIT_launch (see here for example)</li> </ul> <p>Once created, you need to update the <code>autoware.repos</code> file of your cloned Autoware repository to refer to these two description packages.</p> <pre><code>-  # sensor_kit\n-  sensor_kit/sample_sensor_kit_launch:\n-    type: git\n-    url: https://github.com/autowarefoundation/sample_sensor_kit_launch.git\n-    version: main\n-  # vehicle\n-  vehicle/sample_vehicle_launch:\n-    type: git\n-    url: https://github.com/autowarefoundation/sample_vehicle_launch.git\n-    version: main\n+  # sensor_kit\n+  sensor_kit/YOUR_SENSOR_KIT_launch:\n+    type: git\n+    url: https://github.com/YOUR_NAME/YOUR_SENSOR_KIT_launch.git\n+    version: main\n+  # vehicle\n+  vehicle/YOUR_VEHICLE_launch:\n+    type: git\n+    url: https://github.com/YOUR_NAME/YOUR_VEHICLE_launch.git\n+    version: main\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/overview/#adapt-your_vehicle_launch-for-autoware-launching-system","title":"Adapt YOUR_VEHICLE_launch for autoware launching system","text":""},{"location":"how-to-guides/integrating-autoware/overview/#at-your_vehicle_description","title":"At YOUR_VEHICLE_description","text":"<p>Define URDF and parameters in the vehicle description package (refer to the sample vehicle description package for an example).</p>"},{"location":"how-to-guides/integrating-autoware/overview/#at-your_vehicle_launch","title":"At YOUR_VEHICLE_launch","text":"<p>Create a launch file (refer to the sample vehicle launch package for example). If you have multiple vehicles with the same hardware setup, you can specify <code>vehicle_id</code> to distinguish them.</p>"},{"location":"how-to-guides/integrating-autoware/overview/#adapt-your_sensor_kit_launch-for-autoware-launching-system","title":"Adapt YOUR_SENSOR_KIT_launch for autoware launching system","text":""},{"location":"how-to-guides/integrating-autoware/overview/#at-your_sensor_kit_description","title":"At YOUR_SENSOR_KIT_description","text":"<p>Define URDF and extrinsic parameters for all the sensors here (refer to the sample sensor kit description package for example). Note that you need to calibrate extrinsic parameters for all the sensors beforehand.</p>"},{"location":"how-to-guides/integrating-autoware/overview/#at-your_sensor_kit_launch","title":"At YOUR_SENSOR_KIT_launch","text":"<p>Create <code>launch/sensing.launch.xml</code> that launches the interfaces of all the sensors on the vehicle. (refer to the sample sensor kit launch package for example).</p> <p>Note</p> <p>At this point, you are now able to run Autoware's Planning Simulator to do a basic test of your vehicle and sensing packages. To do so, you need to build and install Autoware using your cloned repository. Follow the steps for either Docker or source installation (starting from the dependency installation step) and then run the following command:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml vehicle_model:=YOUR_VEHICLE sensor_kit:=YOUR_SENSOR_KIT map_path:=/PATH/TO/YOUR/MAP\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/overview/#3-create-a-vehicle_interface-package","title":"3. Create a <code>vehicle_interface</code> package","text":"<p>You need to create an interface package for your vehicle. The package is expected to provide the following two functions.</p> <ol> <li>Receive command messages from <code>vehicle_cmd_gate</code> and drive the vehicle accordingly</li> <li>Send vehicle status information to Autoware</li> </ol> <p>You can find detailed information about the requirements of the <code>vehicle_interface</code> package in the Vehicle Interface design documentation. You can also refer to TIER IV's pacmod_interface repository as an example of a vehicle interface package.</p>"},{"location":"how-to-guides/integrating-autoware/overview/#4-create-maps","title":"4. Create maps","text":"<p>You need both a pointcloud map and a vector map in order to use Autoware. For more information on map design, please click here.</p>"},{"location":"how-to-guides/integrating-autoware/overview/#create-a-pointcloud-map","title":"Create a pointcloud map","text":"<p>Use third-party tools such as a LiDAR-based SLAM (Simultaneous Localization And Mapping) package to create a pointcloud map in the <code>.pcd</code> format. For more information, please click here.</p>"},{"location":"how-to-guides/integrating-autoware/overview/#create-vector-map","title":"Create vector map","text":"<p>Use third-party tools such as TIER IV's Vector Map Builder to create a Lanelet2 format <code>.osm</code> file.</p>"},{"location":"how-to-guides/integrating-autoware/overview/#5-launch-autoware","title":"5. Launch Autoware","text":"<p>This section briefly explains how to run your vehicle with Autoware.</p>"},{"location":"how-to-guides/integrating-autoware/overview/#install-autoware","title":"Install Autoware","text":"<p>Follow the installation steps of Autoware.</p>"},{"location":"how-to-guides/integrating-autoware/overview/#launch-autoware","title":"Launch Autoware","text":"<p>Launch Autoware with the following command:</p> <pre><code>ros2 launch autoware_launch autoware.launch.xml vehicle_model:=YOUR_VEHICLE sensor_kit:=YOUR_SENSOR_KIT map_path:=/PATH/TO/YOUR/MAP\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/overview/#set-initial-pose","title":"Set initial pose","text":"<p>If GNSS is available, Autoware automatically initializes the vehicle's pose.</p> <p>If not, you need to set the initial pose using the RViz GUI.</p> <ol> <li>Click the 2D Pose estimate button in the toolbar, or hit the P key</li> <li>In the 3D View pane, click and hold the left mouse button, and then drag to set the direction for the initial pose.</li> </ol>"},{"location":"how-to-guides/integrating-autoware/overview/#set-goal-pose","title":"Set goal pose","text":"<p>Set a goal pose for the ego vehicle.</p> <ol> <li>Click the 2D Nav Goal button in the toolbar, or hit the G key</li> <li>In the 3D View pane, click and hold the left mouse button, and then drag to set the direction for the goal pose.    If successful, you will see the calculated planning path on RViz.</li> </ol>"},{"location":"how-to-guides/integrating-autoware/overview/#engage","title":"Engage","text":"<p>In your terminal, execute the following command.</p> <pre><code>source ~/autoware.YOURS/install/setup.bash\nros2 topic pub /autoware.YOURS/engage autoware_auto_vehicle_msgs/msg/Engage \"engage: true\" -1\n</code></pre> <p>You can also engage via RViz with \"AutowareStatePanel\". The panel can be found in <code>Panels &gt; Add New Panel &gt; tier4_state_rviz_plugin &gt; AutowareStatePanel</code>.</p> <p></p> <p>Now the vehicle should drive along the calculated path!</p>"},{"location":"how-to-guides/integrating-autoware/overview/#6-tune-parameters-for-your-vehicle-environment","title":"6. Tune parameters for your vehicle &amp; environment","text":"<p>You may need to tune your parameters depending on the domain in which you will operate your vehicle.</p> <p>The maximum velocity is defined here, that is 15km/h by default.</p>"},{"location":"how-to-guides/integrating-autoware/awsim-integration/","title":"How to integrate your vehicle in AWSIM environment","text":""},{"location":"how-to-guides/integrating-autoware/awsim-integration/#how-to-integrate-your-vehicle-in-awsim-environment","title":"How to integrate your vehicle in AWSIM environment","text":""},{"location":"how-to-guides/integrating-autoware/awsim-integration/#overview","title":"Overview","text":"<p>AWSIM is an open-source simulator designed by TIER IV for training and evaluating autonomous driving systems. It provides a realistic virtual environment for simulating various real-world scenarios, enabling users to test and refine their autonomous systems before deployment on actual vehicles.</p>"},{"location":"how-to-guides/integrating-autoware/awsim-integration/#setup-unity-project","title":"Setup Unity Project","text":"<p>To add your environment and vehicle to the AWSIM simulation, you need to set up the Unity environment on your computer. Please follow the steps on the <code>Setup Unity Project</code> documentation page to set up the Unity environment on your computer.</p> <p> </p>    AWSIM Unity Setup"},{"location":"how-to-guides/integrating-autoware/awsim-integration/#new-vehicle-integration","title":"New Vehicle Integration","text":"<p>To incorporate your vehicle into the AWSIM environment, you'll need a 3D model file (.dae, .fbx) of your vehicle. Please refer to the steps on the <code>Add New Vehicle documentation page</code> to add your own vehicle to the AWSIM project environment. During these steps, you'll configure your sensor URDF design on your vehicle. Our tutorial vehicle is shown in the AWSIM environment in the following image.</p> <p> </p>    Tutorial vehicle in AWSIM Unity Environment"},{"location":"how-to-guides/integrating-autoware/awsim-integration/#environment-integration","title":"Environment Integration","text":"<p>Creating custom 3D environments for AWSIM is feasible, but it's recommended to adhere to the .fbx file format. Materials and textures should be stored in separate directories for seamless integration with Unity. This format facilitates material importation and replacement during import. Please refer to the steps on the <code>Add Environment documentation page</code> to add your custom environment to the AWSIM project environment.</p> <p> </p>    Tutorial vehicle AWSIM Unity Environment"},{"location":"how-to-guides/integrating-autoware/awsim-integration/#others","title":"Others","text":"<p>Additionally, you can incorporate traffic and NPCs, generate point cloud maps using lanelet2 maps, and perform other tasks by following the relevant documentation steps provided in the <code>AWSIM documentation</code>.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/","title":"Creating maps","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/#creating-maps","title":"Creating maps","text":"<p>Autoware requires a pointcloud map and a vector map for the vehicle's operating environment. (Check the map design documentation page for the detailed specification).</p> <p>This page explains how users can create maps that can be used for Autoware.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/#creating-a-point-cloud-map","title":"Creating a point cloud map","text":"<p>Traditionally, a Mobile Mapping System (MMS) is used in order to create highly accurate large-scale point cloud maps. However, since a MMS requires high-end sensors for precise positioning, its operational cost can be very expensive and may not be suitable for a relatively small driving environment. Alternatively, a Simultaneous Localization And Mapping (SLAM) algorithm can be used to create a point cloud map from recorded LiDAR scans. Some of the useful open-source SLAM implementations are listed in this page.</p> <p>If you prefer proprietary software that is easy to use, you can try a fully automatic mapping tool from MAP IV, Inc., MapIV Engine. They currently provide a trial license for Autoware users free of charge.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/#creating-a-vector-map","title":"Creating a vector map","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/#quick-way-to-create-simple-maps","title":"Quick way to create simple maps","text":"<p>bag2lanelet is a tool to create virtual lanes from self-location data. Whether in a real environment or a simulation, you can use this tool to generate simple lanelets from a rosbag with self-location information, allowing you to quickly test Autoware's performance. A key use case for this tool is to emulate autonomous driving on routes that were initially driven manually.</p> <p></p> <p>However, it is important to note that this tool has very limited functionalities and can only generate single-lane maps. To enable more comprehensive mapping and navigation capabilities, we recommend using the 'Vector Map Builder' described in the next section.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/#tools-for-a-vector-map-creation","title":"Tools for a vector map creation","text":"<p>The recommended way to create an Autoware-compatible vector map is to use Vector Map Builder, a free web-based tool provided by TIER IV, Inc.. Vector Map Builder allows you to create lanes and add additional regulatory elements such as stop signs or traffic lights using a point cloud map as a reference.</p> <p></p> <p>For open-source software options, MapToolbox is a plugin for Unity specifically designed to create Lanelet2 maps for Autoware. Although JOSM is another open-source tool that can be used to create Lanelet2 maps, be aware that a number of modifications must be done manually to make the map compatible with Autoware. This process can be tedious and time-consuming, so the use of JOSM is not recommended.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/#autoware-compatible-map-providers","title":"Autoware-compatible map providers","text":"<p>If it is not possible to create HD maps yourself, you can use a mapping service from the following Autoware-compatible map providers instead:</p> <ul> <li>MAP IV, Inc.</li> <li>AISAN TECHNOLOGY CO., LTD.</li> <li>TomTom</li> </ul> <p>The table below shows each company's mapping technology and the types of HD maps they support.</p> Company Mapping technology Available maps MAP IV, Inc. SLAM Point cloud and vector maps AISAN TECHNOLOGY CO., LTD. MMS Point cloud and vector maps TomTom MMS Vector map* <p>Note</p> <p>Maps provided by TomTom use their proprietary AutoStream format, not Lanelet2. The open-source AutoStreamForAutoware tool can be used to convert an AutoStream map to a Lanelet2 map. However, the converter is still in its early stages and has some known limitations.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/converting-utm-to-mgrs-map/","title":"Converting UTM maps to MGRS map format","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/converting-utm-to-mgrs-map/#converting-utm-maps-to-mgrs-map-format","title":"Converting UTM maps to MGRS map format","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/converting-utm-to-mgrs-map/#overview","title":"Overview","text":"<p>If you want to use MGRS (Military Grid Reference System) format in Autoware, you need to convert UTM (Universal Transverse Mercator) map to MGRS format. In order to do that, we will use UTM to MGRS pointcloud converter ROS 2 package provided by Leo Drive.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/converting-utm-to-mgrs-map/#installation","title":"Installation","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/converting-utm-to-mgrs-map/#dependencies","title":"Dependencies","text":"<ul> <li>ROS 2</li> <li>PCL-conversions</li> <li>GeographicLib</li> </ul> <p>To install dependencies:</p> <pre><code>sudo apt install ros-humble-pcl-conversions \\\ngeographiclib-tools\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/converting-utm-to-mgrs-map/#building","title":"Building","text":"<pre><code>    cd &lt;PATH-TO-YOUR-ROS-2-WORKSPACE&gt;/src\n    git clone https://github.com/leo-drive/pc_utm_to_mgrs_converter.git\n    cd ..\n    colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/converting-utm-to-mgrs-map/#usage","title":"Usage","text":"<p>After the installation of converter tool, we need to define northing, easting and ellipsoid height of local UTM map origin in <code>pc_utm_to_mgrs_converter.param.yaml</code>. For example, you can use latitude, longitude and altitude values in the navsatfix message from your GNSS/INS sensor.</p> Sample ROS 2 topic echo from navsatfix message <pre><code>header:\nstamp:\nsec: 1694612439\nnanosec: 400000000\nframe_id: GNSS_INS/gnss_ins_link\nstatus:\nstatus: 0\nservice: 1\nlatitude: 41.0216110801253\nlongitude: 28.887096461148346\naltitude: 74.28264078891529\nposition_covariance:\n- 0.0014575386885553598\n- 0.0\n- 0.0\n- 0.0\n- 0.004014162812381983\n- 0.0\n- 0.0\n- 0.0\n- 0.0039727711118757725\nposition_covariance_type: 2\n</code></pre> <p>After that, you need to convert latitude and longitude values to northing and easting values. You can use any converter on the internet for converting latitude longitude values to UTM. (i.e., UTMconverter)</p> <p>Now, we are ready to update <code>pc_utm_to_mgrs_converter.param.yaml</code>, example for our navsatfix message:</p> <pre><code>/**:\n  ros__parameters:\n      # Northing of local origin\n-     Northing: 4520550.0\n+     Northing: 4542871.33\n\n     # Easting of local origin\n-     Easting: 698891.0\n+     Easting: 658659.84\n\n     # Elipsoid Height of local origin\n-     ElipsoidHeight: 47.62\n+     ElipsoidHeight: 74.28\n</code></pre> <p>Lastly, we will update input and pointcloud the map path in <code>pc_utm_to_mgrs_converter.launch.xml</code>:</p> <pre><code>...\n- &lt;arg name=\"input_file_path\" default=\"/home/melike/projects/autoware_data/gebze_pospac_map/pointcloud_map.pcd\"/&gt;\n+ &lt;arg name=\"input_file_path\" default=\"&lt;PATH-TO-YOUR-INPUT-PCD-MAP&gt;\"/&gt;\n- &lt;arg name=\"output_file_path\" default=\"/home/melike/projects/autoware_data/gebze_pospac_map/pointcloud_map_mgrs_orto.pcd\"/&gt;\n+ &lt;arg name=\"output_file_path\" default=\"&lt;PATH-TO-YOUR-OUTPUT-PCD-MAP&gt;\"/&gt;\n...\n</code></pre> <p>After the setting of the package, we will launch pc_utm_to_mgrs_converter:</p> <pre><code>ros2 launch pc_utm_to_mgrs_converter pc_utm_to_mgrs_converter.launch.xml\n</code></pre> <p>The conversion process will be started, you should see <code>Saved &lt;YOUR-MAP-POINTS-SIZE&gt; data points saved to &lt;YOUR-OUTPUT-MAP-PATH&gt;</code> message on your terminal. MGRS format pointcloud map should be saved on your output map directory.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/","title":"Creating a vector map","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/#creating-a-vector-map","title":"Creating a vector map","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/#overview","title":"Overview","text":"<p>In this section, we will explain how to create Lanelet2 maps with TIER IV's Vector Map Builder tool.</p> <p>There are alternative tools such as Unity-based app MapToolbox and Java-based app JOSM that you may use for creating a Lanelet2 map. We will be using TIER IV's Vector Map Builder in the tutorial since it works on a browser without installation of extra dependency applications.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/#vector-map-builder","title":"Vector Map Builder","text":"<p>You need a TIER IV account for using Vector Map Builder tool. If it is the first time to use the tool, create a TIER IV account in order to use Vector Map Builder tool. For more information about this tool, please check the official guide.</p> <p>You can follow these pages for creating a Lanelet2 map and understanding its regulatory elements.</p> <ul> <li>Lanelet2</li> <li>Crosswalk</li> <li>Stop Line</li> <li>Traffic Light</li> <li>Speed Bump</li> <li>Detection Area</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/crosswalk/","title":"Crosswalk attribute","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/crosswalk/#crosswalk-attribute","title":"Crosswalk attribute","text":"<p>Behavior velocity planner's crosswalk module plans velocity to stop or decelerate for pedestrians approaching or walking on a crosswalk. In order to operate that, we will add crosswalk attribute to our lanelet2 map.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/crosswalk/#creating-a-crosswalk-attribute","title":"Creating a crosswalk attribute","text":"<p>In order to create a crosswalk on your map, please follow these steps:</p> <ol> <li>Click <code>Abstraction</code> button on top panel.</li> <li>Select <code>Crosswalk</code> from the panel.</li> <li>Click and draw crosswalk on your pointcloud map.</li> </ol> <p>You can see these steps in the crosswalk creating demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/crosswalk/#testing-created-crosswalk-with-planning-simulator","title":"Testing created crosswalk with planning simulator","text":"<p>After the completing of creating the map, we need to save it. To that please click <code>File</code> --&gt; <code>Export Lanelet2Maps</code> then download.</p> <p>After the download is finished, we need to put lanelet2 map and pointcloud map on the same location. The directory structure should be like this:</p> <pre><code>+ &lt;YOUR-MAP-DIRECTORY&gt;/\n+  \u251c\u2500 pointcloud_map.pcd\n+  \u2514\u2500 lanelet2_map.osm\n</code></pre> <p>If your .osm or .pcd map file's name is different from these names, you need to update autoware.launch.xml:</p> <pre><code>  &lt;!-- Map --&gt;\n-  &lt;arg name=\"lanelet2_map_file\" default=\"lanelet2_map.osm\" description=\"lanelet2 map file name\"/&gt;\n+  &lt;arg name=\"lanelet2_map_file\" default=\"&lt;YOUR-LANELET-MAP-NAME&gt;.osm\" description=\"lanelet2 map file name\"/&gt;\n-  &lt;arg name=\"pointcloud_map_file\" default=\"pointcloud_map.pcd\" description=\"pointcloud map file name\"/&gt;\n+  &lt;arg name=\"pointcloud_map_file\" default=\"&lt;YOUR-POINTCLOUD-MAP-NAME&gt;.pcd\" description=\"pointcloud map file name\"/&gt;\n</code></pre> <p>Now we are ready to launch the planning simulator:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=&lt;YOUR-MAP-FOLDER-DIR&gt; vehicle_model:=&lt;YOUR-VEHICLE-MODEL&gt; sensor_model:=&lt;YOUR-SENSOR-KIT&gt;\n</code></pre> <p>Example for tutorial_vehicle:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/Files/autoware_map/tutorial_map/ vehicle_model:=tutorial_vehicle sensor_model:=tutorial_vehicle_sensor_kit vehicle_id:=tutorial_vehicle\n</code></pre> <ol> <li>Click <code>2D Pose Estimate</code> button on rviz or press <code>P</code> and give a pose for initialization.</li> <li>Click <code>2D Goal Pose</code> button on rviz or press <code>G</code> and give a pose for goal point.</li> <li>We need to add pedestrians to crosswalk, so activate interactive pedestrians from <code>Tool Properties</code> panel on rviz.</li> <li>After that, please press <code>Shift</code>, then click right click button for inserting pedestrians.</li> <li>You can control inserted pedestrian via dragging right click.</li> </ol> <p>Crosswalk markers on rviz:</p> <p> </p>      Crosswalk test on the created map.    <p>You can check your crosswalk elements in the planning simulator as this demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/detection-area/","title":"Detection area element","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/detection-area/#detection-area-element","title":"Detection area element","text":"<p>Behavior velocity planner's detection area plans velocity when if pointcloud is detected in a detection area defined on a map, the stop planning will be executed at the predetermined point. In order to operate that, we will add a detection area element to our lanelet2 map.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/detection-area/#creating-a-detection-area-element","title":"Creating a detection area element","text":"<p>In order to create a detection area on your map, please follow these steps:</p> <ol> <li>Click <code>Lanelet2Maps</code> button on top panel.</li> <li>Select <code>Detection Area</code> from the panel.</li> <li>Please select lanelet which stop line to be added.</li> <li>Click and insert <code>Detection Area</code> on your pointcloud map.</li> <li>You can change the dimensions of the detection area with clicking points on the corners of the detection area. For more information, you can check the demonstration video.</li> </ol> <p>You can see these steps in the detection area creating demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/detection-area/#testing-created-detection-area-with-planning-simulator","title":"Testing created detection area with planning simulator","text":"<p>After the completing of creating the map, we need to save it. To that please click <code>File</code> --&gt; <code>Export Lanelet2Maps</code> then download.</p> <p>After the download is finished, we need to put lanelet2 map and pointcloud map on the same location. The directory structure should be like this:</p> <pre><code>+ &lt;YOUR-MAP-DIRECTORY&gt;/\n+  \u251c\u2500 pointcloud_map.pcd\n+  \u2514\u2500 lanelet2_map.osm\n</code></pre> <p>If your .osm or .pcd map file's name is different from these names, you need to update autoware.launch.xml:</p> <pre><code>  &lt;!-- Map --&gt;\n-  &lt;arg name=\"lanelet2_map_file\" default=\"lanelet2_map.osm\" description=\"lanelet2 map file name\"/&gt;\n+  &lt;arg name=\"lanelet2_map_file\" default=\"&lt;YOUR-LANELET-MAP-NAME&gt;.osm\" description=\"lanelet2 map file name\"/&gt;\n-  &lt;arg name=\"pointcloud_map_file\" default=\"pointcloud_map.pcd\" description=\"pointcloud map file name\"/&gt;\n+  &lt;arg name=\"pointcloud_map_file\" default=\"&lt;YOUR-POINTCLOUD-MAP-NAME&gt;.pcd\" description=\"pointcloud map file name\"/&gt;\n</code></pre> <p>Now we are ready to launch the planning simulator:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=&lt;YOUR-MAP-FOLDER-DIR&gt; vehicle_model:=&lt;YOUR-VEHICLE-MODEL&gt; sensor_model:=&lt;YOUR-SENSOR-KIT&gt;\n</code></pre> <p>Example for tutorial_vehicle:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/Files/autoware_map/tutorial_map/ vehicle_model:=tutorial_vehicle sensor_model:=tutorial_vehicle_sensor_kit vehicle_id:=tutorial_vehicle\n</code></pre> <ol> <li>Click <code>2D Pose Estimate</code> button on rviz or press <code>P</code> and give a pose for initialization.</li> <li>Click <code>2D Goal Pose</code> button on rviz or press <code>G</code> and give a pose for goal point.</li> <li>We need to add pedestrians to detection area, so activate interactive pedestrians from <code>Tool Properties</code> panel on rviz.</li> <li>After that, please press <code>Shift</code>, then click right click button for inserting pedestrians.</li> <li>You can control inserted pedestrian via dragging right click. So, you should put pedestrian on the detection area for testing.</li> </ol> <p>Stop detection area on rviz:</p> <p> </p>      Detection area test on the created map.    <p>You can check your detection area elements in the planning simulator as this demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/lanelet2/","title":"Creating a Lanelet","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/lanelet2/#creating-a-lanelet","title":"Creating a Lanelet","text":"<p>At this page, we will explain how to create a simple lanelet on your point cloud map. If you didn't have a point cloud map before, please check and follow the steps on the LIO-SAM mapping page for how to create a point cloud map for Autoware.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/lanelet2/#creating-a-lanelet2","title":"Creating a Lanelet2","text":"<p>Firstly, we need to import our pointcloud map to Vector Map Builder tool:</p> <ol> <li>Please click <code>File</code>.</li> <li>Then, click <code>Import PCD</code>.</li> <li>Click <code>Browse</code> and select your .pcd file.</li> </ol> <p>You will display the point cloud on your Vector Map Builder tool after the upload is complete:</p> <p> </p>      Uploaded pointcloud map file on Vector Map Builder    <p>Now, we are ready to create lanelet2 map on our pointcloud map:</p> <ol> <li>Please click <code>Create</code>.</li> <li>Then, click <code>Create Lanelet2Maps</code>.</li> <li>Please fill your map name</li> <li>Please fill your MGRS zone. (At tutorial_vehicle, MGRS grid zone: 35T - MGRS 100,000-meter square: PF)</li> <li>Click <code>Create</code>.</li> </ol>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/lanelet2/#creating-a-simple-lanelet","title":"Creating a simple lanelet","text":"<p>In order to create a simple lanelet on your map, please follow these steps:</p> <ol> <li>CLick <code>Lanelet2Maps</code> on the bar</li> <li>Enable Lanelet mode via selecting <code>Lanelet</code>.</li> <li>Then, you can click the pointcloud map to create lanelet.</li> <li>If your lanelet is finished, you can disable <code>Lanelet</code>.</li> <li>If you want to change your lanelet width, click <code>lanelet</code> --&gt; <code>Change Lanelet Width</code>, then you can enter the lanelet width.</li> </ol> <p>Video Demonstration:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/lanelet2/#join-two-lanelets","title":"Join two lanelets","text":"<p>In order to join two lanelets, please follow these steps:</p> <ol> <li>Please create two distinct lanelet.</li> <li>Select a Lanelet, then press <code>Shift</code> and select other lanelet.</li> <li>Now, you can see <code>Join Lanelets</code> button, just press it.</li> <li>These lanelets will be joined.</li> </ol> <p>Video Demonstration:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/lanelet2/#join-multiple-lanelets","title":"Join Multiple lanelets","text":"<p>In order to add (join) two or more lanelets to another lanelet, please follow these steps:</p> <ol> <li>Create multiple lanelets.</li> <li>You can join the first two lanelets like the steps before.</li> <li>Please check end points ids of first lanelet.</li> <li>Then you need to change these ids with third lanelet's start point. (Please change with selecting linestring of lanelet)</li> <li>You will see two next lanes of the first lanelet will be appeared.</li> </ol> <p>Video Demonstration:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/lanelet2/#change-speed-limit-of-lanelet","title":"Change Speed Limit Of Lanelet","text":"<p>In order to change the speed limit of lanelet, please follow these steps:</p> <ol> <li>Select the lanelet where the speed limit will be changed</li> <li>Set <code>speed limit</code> on the right panel.</li> </ol>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/lanelet2/#test-lanelets-with-planning-simulator","title":"Test lanelets with planning simulator","text":"<p>After the completing of creating lanelets, we need to save it. To that please click <code>File</code> --&gt; <code>Export Lanelet2Maps</code> then download.</p> <p>After the download is finished, we need to put lanelet2 map and pointcloud map on the same location. The directory structure should be like this:</p> <pre><code>&lt;YOUR-MAP-DIRECTORY&gt;/\n \u251c\u2500 pointcloud_map.pcd\n \u2514\u2500 lanelet2_map.osm\n</code></pre> <p>If your .osm or .pcd map file's name is different from these names, you need to update autoware.launch.xml:</p> <pre><code>  &lt;!-- Map --&gt;\n-  &lt;arg name=\"lanelet2_map_file\" default=\"lanelet2_map.osm\" description=\"lanelet2 map file name\"/&gt;\n+  &lt;arg name=\"lanelet2_map_file\" default=\"&lt;YOUR-LANELET-MAP-NAME&gt;.osm\" description=\"lanelet2 map file name\"/&gt;\n-  &lt;arg name=\"pointcloud_map_file\" default=\"pointcloud_map.pcd\" description=\"pointcloud map file name\"/&gt;\n+  &lt;arg name=\"pointcloud_map_file\" default=\"&lt;YOUR-POINTCLOUD-MAP-NAME&gt;.pcd\" description=\"pointcloud map file name\"/&gt;\n</code></pre> <p>Now we are ready to launch the planning simulator:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=&lt;YOUR-MAP-FOLDER-DIR&gt; vehicle_model:=&lt;YOUR-VEHICLE-MODEL&gt; sensor_model:=&lt;YOUR-SENSOR-KIT&gt;\n</code></pre> <p>Example for tutorial_vehicle:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/Files/autoware_map/tutorial_map/ vehicle_model:=tutorial_vehicle sensor_model:=tutorial_vehicle_sensor_kit vehicle_id:=tutorial_vehicle\n</code></pre> <ol> <li>Click <code>2D Pose Estimate</code> button on rviz or press <code>P</code> and give a pose for initialization.</li> <li>Click <code>2D Goal Pose</code> button on rviz or press <code>G</code> and give a pose for goal point.</li> </ol> <p> </p>      Testing our created vector map with planning simulator"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/speed-bump/","title":"Speed bump","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/speed-bump/#speed-bump","title":"Speed bump","text":"<p>Behavior velocity planner's speed bump module plans velocity to slow down before speed bump for comfortable and safety driving. In order to operate that, we will add speed bumps to our lanelet2 map.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/speed-bump/#creating-a-speed-bump-element","title":"Creating a speed bump element","text":"<p>In order to create a speed bump on your pointcloud map, please follow these steps:</p> <ol> <li>Select <code>Linestring</code> from Lanelet2Maps section.</li> <li>Click and draw polygon for speed bump.</li> <li>Then please disable <code>Linestring</code> from Lanelet2Maps section.</li> <li>CLick <code>Change to Polygon</code> from the <code>Action</code> panel.</li> <li>Please select this Polygon and enter <code>speed_bump</code> as the type.</li> <li>Then, please click lanelet which speed bump to be added.</li> <li>Select <code>Create General Regulatory ELement</code>.</li> <li>Go to this element, and please enter <code>speed_bump</code> as subtype.</li> <li>Click <code>Add refers</code> and type your created speed bump polygon ID.</li> </ol> <p>You can see these steps in the speed bump creating demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/speed-bump/#testing-created-the-speed-bump-element-with-planning-simulator","title":"Testing created the speed bump element with planning simulator","text":"<p>After the completing of creating the map, we need to save it. To that please click <code>File</code> --&gt; <code>Export Lanelet2Maps</code> then download.</p> <p>After the download is finished, we need to put lanelet2 map and pointcloud map on the same location. The directory structure should be like this:</p> <pre><code>+ &lt;YOUR-MAP-DIRECTORY&gt;/\n+  \u251c\u2500 pointcloud_map.pcd\n+  \u2514\u2500 lanelet2_map.osm\n</code></pre> <p>If your .osm or .pcd map file's name is different from these names, you need to update autoware.launch.xml:</p> <pre><code>  &lt;!-- Map --&gt;\n-  &lt;arg name=\"lanelet2_map_file\" default=\"lanelet2_map.osm\" description=\"lanelet2 map file name\"/&gt;\n+  &lt;arg name=\"lanelet2_map_file\" default=\"&lt;YOUR-LANELET-MAP-NAME&gt;.osm\" description=\"lanelet2 map file name\"/&gt;\n-  &lt;arg name=\"pointcloud_map_file\" default=\"pointcloud_map.pcd\" description=\"pointcloud map file name\"/&gt;\n+  &lt;arg name=\"pointcloud_map_file\" default=\"&lt;YOUR-POINTCLOUD-MAP-NAME&gt;.pcd\" description=\"pointcloud map file name\"/&gt;\n</code></pre> <p>Note</p> <p>The speed bump module not enabled default. To enable that, please uncomment it your behavior_velocity_planner.param.yaml.</p> <p>Now we are ready to launch the planning simulator:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=&lt;YOUR-MAP-FOLDER-DIR&gt; vehicle_model:=&lt;YOUR-VEHICLE-MODEL&gt; sensor_model:=&lt;YOUR-SENSOR-KIT&gt;\n</code></pre> <p>Example for tutorial_vehicle:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/Files/autoware_map/tutorial_map/ vehicle_model:=tutorial_vehicle sensor_model:=tutorial_vehicle_sensor_kit vehicle_id:=tutorial_vehicle\n</code></pre> <ol> <li>Click <code>2D Pose Estimate</code> button on rviz or press <code>P</code> and give a pose for initialization.</li> <li>Click <code>2D Goal Pose</code> button on rviz or press <code>G</code> and give a pose for goal point.</li> <li>You can see the speed bump marker on the rviz screen.</li> </ol> <p>Speed bump markers on rviz:</p> <p> </p>      Speed bump test on the created map.    <p>You can check your speed bump elements in the planning simulator as this demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/stop-line/","title":"Stop Line","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/stop-line/#stop-line","title":"Stop Line","text":"<p>Behavior velocity planner's stop line module plans velocity to stop right before stop lines and restart driving after stopped. In order to operate that, we will add stop line attribute to our lanelet2 map.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/stop-line/#creating-a-stop-line-regulatory-element","title":"Creating a stop line regulatory element","text":"<p>In order to create a stop line on your pointcloud map, please follow these steps:</p> <ol> <li>Please select lanelet which stop line to be added.</li> <li>Click <code>Abstraction</code> button on top panel.</li> <li>Select <code>Stop Line</code> from the panel.</li> <li>Click on the desired area for inserting stop line.</li> </ol> <p>You can see these steps in the stop line creating demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/stop-line/#testing-created-the-stop-line-element-with-planning-simulator","title":"Testing created the stop line element with planning simulator","text":"<p>After the completing of creating the map, we need to save it. To that please click <code>File</code> --&gt; <code>Export Lanelet2Maps</code> then download.</p> <p>After the download is finished, we need to put lanelet2 map and pointcloud map on the same location. The directory structure should be like this:</p> <pre><code>+ &lt;YOUR-MAP-DIRECTORY&gt;/\n+  \u251c\u2500 pointcloud_map.pcd\n+  \u2514\u2500 lanelet2_map.osm\n</code></pre> <p>If your .osm or .pcd map file's name is different from these names, you need to update autoware.launch.xml:</p> <pre><code>  &lt;!-- Map --&gt;\n-  &lt;arg name=\"lanelet2_map_file\" default=\"lanelet2_map.osm\" description=\"lanelet2 map file name\"/&gt;\n+  &lt;arg name=\"lanelet2_map_file\" default=\"&lt;YOUR-LANELET-MAP-NAME&gt;.osm\" description=\"lanelet2 map file name\"/&gt;\n-  &lt;arg name=\"pointcloud_map_file\" default=\"pointcloud_map.pcd\" description=\"pointcloud map file name\"/&gt;\n+  &lt;arg name=\"pointcloud_map_file\" default=\"&lt;YOUR-POINTCLOUD-MAP-NAME&gt;.pcd\" description=\"pointcloud map file name\"/&gt;\n</code></pre> <p>Now we are ready to launch the planning simulator:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=&lt;YOUR-MAP-FOLDER-DIR&gt; vehicle_model:=&lt;YOUR-VEHICLE-MODEL&gt; sensor_model:=&lt;YOUR-SENSOR-KIT&gt;\n</code></pre> <p>Example for tutorial_vehicle:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/Files/autoware_map/tutorial_map/ vehicle_model:=tutorial_vehicle sensor_model:=tutorial_vehicle_sensor_kit vehicle_id:=tutorial_vehicle\n</code></pre> <ol> <li>Click <code>2D Pose Estimate</code> button on rviz or press <code>P</code> and give a pose for initialization.</li> <li>Click <code>2D Goal Pose</code> button on rviz or press <code>G</code> and give a pose for goal point.</li> <li>You can see the stop line marker on the rviz screen.</li> </ol> <p>Stop line markers on rviz:</p> <p> </p>      Stop line test on the created map.    <p>You can check your stop line elements in the planning simulator as this demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/traffic-light/","title":"Traffic light","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/traffic-light/#traffic-light","title":"Traffic light","text":"<p>Behavior velocity planner's traffic light module plans velocity according to the traffic light status. In order to operate that, we will add traffic light attribute to our lanelet2 map.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/traffic-light/#creating-a-traffic-light-regulatory-element","title":"Creating a traffic light regulatory element","text":"<p>In order to create a traffic light on your pointcloud map, please follow these steps:</p> <ol> <li>Please select lanelet which traffic light to be added.</li> <li>Click <code>Abstraction</code> button on top panel.</li> <li>Select <code>Traffic Light</code> from the panel.</li> <li>Click on the desired area for inserting traffic light.</li> </ol> <p>You can see these steps in the traffic-light creating demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/creating-vector-map/traffic-light/#testing-created-the-traffic-light-element-with-planning-simulator","title":"Testing created the traffic light element with planning simulator","text":"<p>After the completing of creating the map, we need to save it. To that please click <code>File</code> --&gt; <code>Export Lanelet2Maps</code> then download.</p> <p>After the download is finished, we need to put lanelet2 map and pointcloud map on the same location. The directory structure should be like this:</p> <pre><code>+ &lt;YOUR-MAP-DIRECTORY&gt;/\n+  \u251c\u2500 pointcloud_map.pcd\n+  \u2514\u2500 lanelet2_map.osm\n</code></pre> <p>If your .osm or .pcd map file's name is different from these names, you need to update autoware.launch.xml:</p> <pre><code>  &lt;!-- Map --&gt;\n-  &lt;arg name=\"lanelet2_map_file\" default=\"lanelet2_map.osm\" description=\"lanelet2 map file name\"/&gt;\n+  &lt;arg name=\"lanelet2_map_file\" default=\"&lt;YOUR-LANELET-MAP-NAME&gt;.osm\" description=\"lanelet2 map file name\"/&gt;\n-  &lt;arg name=\"pointcloud_map_file\" default=\"pointcloud_map.pcd\" description=\"pointcloud map file name\"/&gt;\n+  &lt;arg name=\"pointcloud_map_file\" default=\"&lt;YOUR-POINTCLOUD-MAP-NAME&gt;.pcd\" description=\"pointcloud map file name\"/&gt;\n</code></pre> <p>Now we are ready to launch the planning simulator:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=&lt;YOUR-MAP-FOLDER-DIR&gt; vehicle_model:=&lt;YOUR-VEHICLE-MODEL&gt; sensor_model:=&lt;YOUR-SENSOR-KIT&gt;\n</code></pre> <p>Example for tutorial_vehicle:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/Files/autoware_map/tutorial_map/ vehicle_model:=tutorial_vehicle sensor_model:=tutorial_vehicle_sensor_kit vehicle_id:=tutorial_vehicle\n</code></pre> <ol> <li>Click <code>2D Pose Estimate</code> button on rviz or press <code>P</code> and give a pose for initialization.</li> <li>Click <code>Panels</code> -&gt; <code>Add new panel</code>, select <code>TrafficLightPublishPanel</code>, and then press <code>OK</code>.</li> <li>In TrafficLightPublishPanel, set the ID and color of the traffic light.</li> <li>Then, Click <code>SET</code> and <code>PUBLISH</code> button.</li> <li>Click <code>2D Goal Pose</code> button on rviz or press <code>G</code> and give a pose for goal point.</li> <li>You can see the traffic light marker on the rviz screen if you set the traffic light color as <code>RED</code>.</li> </ol> <p>Traffic Light markers on rviz:</p> <p> </p>      Traffic light test on the created map.    <p>You can check your traffic light elements in the planning simulator as this demonstration video:</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/","title":"Available Open Source SLAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/#available-open-source-slam","title":"Available Open Source SLAM","text":"<p>This page provides the list of available open source Simultaneous Localization And Mapping (SLAM) implementation that can be used to generate a point cloud (.pcd) map file.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/#selecting-which-implementation-to-use","title":"Selecting which implementation to use","text":"<p>Lidar odometry drifts accumulatively as time goes by and there is solutions to solve that problem such as graph optimization, loop closure and using gps sensor to decrease accumulative drift error. Because of that, a SLAM algorithm should have loop closure feature, graph optimization and should use gps sensor. Additionally, some of the algorithms are using IMU sensor to add another factor to graph for decreasing drift error. While some of the algorithms requires 9-axis IMU sensor strictly, some of them requires only 6-axis IMU sensor or not even using the IMU sensor. Before choosing an algorithm to create maps for Autoware please consider these factors depends on your sensor setup or expected quality of generated map.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/#tips","title":"Tips","text":"<p>Commonly used open-source SLAM implementations are lidarslam-ros2 (LiDAR, IMU*) and LIO-SAM (LiDAR, IMU, GNSS). The required sensor data for each algorithm is specified in the parentheses, where an asterisk (*) indicates that such sensor data is optional. For supported LiDAR models, please check the GitHub repository of each algorithm. While these ROS 2-based SLAM implementations can be easily installed and used directly on the same machine that runs Autoware, it is important to note that they may not be as well-tested or as mature as ROS 1-based alternatives.</p> <p>The notable open-source SLAM implementations that are based on ROS 1 include hdl-graph-slam (LiDAR, IMU*, GNSS*), LeGO-LOAM (LiDAR, IMU*), LeGO-LOAM-BOR (LiDAR), and LIO-SAM (LiDAR, IMU, GNSS).</p> <p>Most of these algorithms already have a built-in loop-closure and pose graph optimization. However, if the built-in, automatic loop-closure fails or does not work correctly, you can use Interactive SLAM to adjust and optimize a pose graph manually.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/#list-of-third-party-slam-implementations","title":"List of Third Party SLAM Implementations","text":"Package Name Explanation Repository Link Loop Closure Sensors ROS Version Dependencies FAST-LIO-LC A computationally efficient and robust LiDAR-inertial odometry package with loop closure module and graph optimization https://github.com/yanliang-wang/FAST_LIO_LC &amp;check; LidarIMUGPS [Optional] ROS 1 ROS MelodicPCL &gt;= 1.8Eigen &gt;= 3.3.4GTSAM &gt;= 4.0.0 FAST_LIO_SLAM FAST_LIO_SLAM is the integration of FAST_LIO and SC-PGO which is scan context based loop detection and GTSAM based pose-graph optimization https://github.com/gisbi-kim/FAST_LIO_SLAM &amp;check; LidarIMUGPS [Optional] ROS 1 PCL &gt;= 1.8Eigen &gt;= 3.3.4 FD-SLAM FD_SLAM is Feature&amp;Distribution-based 3D LiDAR SLAM method based on Surface Representation Refinement. In this algorithm novel feature-based Lidar odometry used for fast scan-matching, and used a proposed UGICP method for keyframe matching https://github.com/SLAMWang/FD-SLAM &amp;check; LidarIMU [Optional]GPS ROS 1 PCLg2oSuitesparse hdl_graph_slam An open source ROS package for real-time 6DOF SLAM using a 3D LIDAR. It is based on 3D Graph SLAM with NDT scan matching-based odometry estimation and loop detection. It also supports several graph constraints, such as GPS, IMU acceleration (gravity vector), IMU orientation (magnetic sensor), and floor plane (detected in a point cloud) https://github.com/koide3/hdl_graph_slam &amp;check; LidarIMU [Optional]GPS [Optional] ROS 1 PCLg2oOpenMP IA-LIO-SAM IA_LIO_SLAM is created for data acquisition in unstructured environment and it is a framework for Intensity and Ambient Enhanced Lidar Inertial Odometry via Smoothing and Mapping that achieves highly accurate robot trajectories and mapping https://github.com/minwoo0611/IA_LIO_SAM &amp;check; LidarIMUGPS ROS 1 GTSAM ISCLOAM ISCLOAM presents a robust loop closure detection approach by integrating both geometry and intensity information https://github.com/wh200720041/iscloam &amp;check; Lidar ROS 1 Ubuntu 18.04ROS MelodicCeresPCLGTSAMOpenCV LeGO-LOAM-BOR LeGO-LOAM-BOR is improved version of the LeGO-LOAM by improving quality of the code, making it more readable and consistent. Also, performance is improved by converting processes to multi-threaded approach https://github.com/facontidavide/LeGO-LOAM-BOR &amp;check; LidarIMU ROS 1 ROS MelodicPCLGTSAM LIO_SAM A framework that achieves highly accurate, real-time mobile robot trajectory estimation and map-building. It formulates lidar-inertial odometry atop a factor graph, allowing a multitude of relative and absolute measurements, including loop closures, to be incorporated from different sources as factors into the system https://github.com/TixiaoShan/LIO-SAM &amp;check; LidarIMUGPS [Optional] ROS 1ROS 2 PCLGTSAM Optimized-SC-F-LOAM An improved version of F-LOAM and uses an adaptive threshold to further judge the loop closure detection results and reducing false loop closure detections. Also it uses feature point-based matching to calculate the constraints between a pair of loop closure frame point clouds and decreases time consumption of constructing loop frame constraints https://github.com/SlamCabbage/Optimized-SC-F-LOAM &amp;check; Lidar ROS 1 PCLGTSAMCeres SC-A-LOAM A real-time LiDAR SLAM package that integrates A-LOAM and ScanContext. https://github.com/gisbi-kim/SC-A-LOAM &amp;check; Lidar ROS 1 GTSAM &gt;= 4.0 SC-LeGO-LOAM SC-LeGO-LOAM integrated LeGO-LOAM for lidar odometry and 2 different loop closure methods: ScanContext and Radius search based loop closure. While ScanContext is correcting large drifts, radius search based method is good for fine-stitching https://github.com/irapkaist/SC-LeGO-LOAM &amp;check; LidarIMU ROS 1 PCLGTSAM"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/","title":"FAST_LIO_LC","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#fast_lio_lc","title":"FAST_LIO_LC","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#what-is-fast_lio_lc","title":"What is FAST_LIO_LC?","text":"<ul> <li>A computationally efficient and robust LiDAR-inertial odometry package with loop closure module and graph optimization.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/yanliang-wang/FAST_LIO_LC</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [Velodyne, Ouster, Livox]</li> <li>IMU [6-AXIS, 9-AXIS]</li> <li>GPS [Optional]</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#dependencies","title":"Dependencies","text":"<ul> <li>Ubuntu 18.04</li> <li>ROS Melodic</li> <li>PCL &gt;= 1.8, Follow PCL Installation.</li> <li>Eigen &gt;= 3.3.4, Follow Eigen Installation.</li> <li>GTSAM &gt;= 4.0.0, Follow GTSAM Installation.</li> </ul> <pre><code>  wget -O ~/Downloads/gtsam.zip https://github.com/borglab/gtsam/archive/4.0.0-alpha2.zip\n  cd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/\n  cd ~/Downloads/gtsam-4.0.0-alpha2/\n  mkdir build &amp;&amp; cd build\n  cmake ..\n  sudo make install\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#1-build","title":"1) Build","text":"<pre><code>    mkdir -p ~/ws_fastlio_lc/src\n    cd ~/ws_fastlio_lc/src\n    git clone https://github.com/gisbi-kim/FAST_LIO_SLAM.git\n    git clone https://github.com/Livox-SDK/livox_ros_driver\n    cd ..\n    catkin_make\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#2-set-parameters","title":"2) Set parameters","text":"<ul> <li>After downloading the repository, change topic and sensor settings on the config file (<code>workspace/src/FAST_LIO_LC/FAST_LIO/config/ouster64_mulran.yaml</code>) with the lidar topic name in your bag file.</li> </ul> <ul> <li>For imu-lidar compatibility, extrinsic matrices from calibration must be changed.</li> </ul> <ul> <li>To enable auto-save, <code>pcd_save_enable</code> must be <code>1</code> from the launch file (<code>workspace/src/FAST_LIO_LC/FAST_LIO/launch/mapping_ouster64_mulran.launch</code>).</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#3-run","title":"3) Run","text":"<ul> <li>For Ouster OS1-64<pre><code># open new terminal: run FAST-LIO\nroslaunch fast_lio mapping_ouster64.launch\n\n# open the other terminal tab: run SC-PGO\nroslaunch aloam_velodyne fastlio_ouster64.launch\n\n# play bag file in the other terminal\nrosbag play RECORDED_BAG.bag --clock\n</code></pre> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#example-result","title":"Example Result","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#other-examples","title":"Other Examples","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#example-dataset","title":"Example dataset","text":"<p>Check original repository link for example dataset.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#contact","title":"Contact","text":"<ul> <li>Maintainer: Yanliang Wang (<code>wyl410922@qq.com</code>)</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-lc/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Thanks for FAST_LIO authors.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/","title":"FAST_LIO_SLAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#fast_lio_slam","title":"FAST_LIO_SLAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#what-is-fast_lio_slam","title":"What is FAST_LIO_SLAM?","text":"<ul> <li>FAST_LIO_SLAM is the integration of FAST_LIO and SC-PGO which is scan context based loop detection and GTSAM based pose-graph optimization.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/gisbi-kim/FAST_LIO_SLAM</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [Livox, Velodyne, Ouster]</li> <li>IMU [6-AXIS, 9-AXIS]</li> <li>GPS [OPTIONAL]</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#dependencies","title":"Dependencies","text":"<ul> <li>ROS</li> <li>PCL</li> <li>GTSAM</li> </ul> <pre><code>wget -O ~/Downloads/gtsam.zip https://github.com/borglab/gtsam/archive/4.0.0-alpha2.zip\ncd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/\ncd ~/Downloads/gtsam-4.0.0-alpha2/\nmkdir build &amp;&amp; cd build\ncmake ..\nsudo make install\n</code></pre> <ul> <li>PCL &gt;= 1.8, Follow PCL Installation.</li> <li>Eigen &gt;= 3.3.4, Follow Eigen Installation.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#1-build","title":"1) Build","text":"<pre><code>    mkdir -p ~/catkin_fastlio_slam/src\n    cd ~/catkin_fastlio_slam/src\n    git clone https://github.com/gisbi-kim/FAST_LIO_SLAM.git\n    git clone https://github.com/Livox-SDK/livox_ros_driver\n    cd ..\n    catkin_make\n    source devel/setup.bash\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#2-set-parameters","title":"2) Set parameters","text":"<ul> <li>Set imu and lidar topic on <code>Fast_LIO/config/ouster64.yaml</code></li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#3-run","title":"3) Run","text":"<pre><code>    # terminal 1: run FAST-LIO2\nroslaunch fast_lio mapping_ouster64.launch\n\n    # open the other terminal tab: run SC-PGO\ncd ~/catkin_fastlio_slam\n    source devel/setup.bash\n    roslaunch aloam_velodyne fastlio_ouster64.launch\n\n    # play bag file in the other terminal\nrosbag play xxx.bag -- clock --pause\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#example-result","title":"Example Result","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#other-examples","title":"Other Examples","text":"<ul> <li> <p>Tutorial video 1 (using KAIST 03 sequence of MulRan dataset)</p> <ul> <li>Example result captures   <p></p></li> <li>download the KAIST 03 pcd map made by FAST-LIO-SLAM, 500MB</li> </ul> </li> </ul> <ul> <li>Example Video 2 (Riverside 02 sequence of MulRan dataset)<ul> <li>Example result captures   <p></p></li> <li>download the Riverside 02 pcd map made by FAST-LIO-SLAM, 400MB</li> </ul> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fast-lio-slam/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Thanks for FAST_LIO authors.</li> <li>You may have an interest in this version of FAST-LIO + Loop closure, implemented by yanliang-wang</li> <li>Maintainer: Giseop Kim (<code>paulgkim@kaist.ac.kr</code>)</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/","title":"FD-SLAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#fd-slam","title":"FD-SLAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#what-is-fd-slam","title":"What is FD-SLAM?","text":"<ul> <li>FD_SLAM is Feature&amp;Distribution-based 3D LiDAR SLAM method based on Surface Representation Refinement. In this algorithm novel feature-based Lidar odometry used for fast scan-matching, and used a proposed UGICP method for keyframe matching.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#repository-information","title":"Repository Information","text":"<p>This is an open source ROS package for real-time 6DOF SLAM using a 3D LIDAR.</p> <p>It is based on hdl_graph_slam and the steps to run our system are same with hdl-graph-slam.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/SLAMWang/FD-SLAM</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR[VLP-16, HDL-32, HDL-64, OS1-64]</li> <li>GPS</li> <li>IMU [Optional]</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#dependencies","title":"Dependencies","text":"<ul> <li>ROS</li> <li>PCL</li> <li>g2o</li> <li>Suitesparse</li> </ul> <p>The following ROS packages are required:</p> <ul> <li>geodesy</li> <li>nmea_msgs</li> <li>pcl_ros</li> <li>ndt_omp</li> <li>U_gicp This is modified based on fast_gicp by us. We use UGICP for keyframe matching.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#1-build","title":"1) Build","text":"<pre><code>cd ~/catkin_ws/src\ngit clone https://github.com/SLAMWang/FD-SLAM.git\ncd ..\ncatkin_make\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#2-services","title":"2) Services","text":"<pre><code>/hdl_graph_slam/dump  (hdl_graph_slam/DumpGraph)\n- save all the internal data (point clouds, floor coeffs, odoms, and pose graph) to a directory.\n\n/hdl_graph_slam/save_map (hdl_graph_slam/SaveMap)\n- save the generated map as a PCD file.\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#3-set-parameters","title":"3) Set parameters","text":"<ul> <li>All the configurable parameters are listed in launch/****.launch as ros params.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/fd-slam/#4-run","title":"4) Run","text":"<pre><code>source devel/setup.bash\nroslaunch hdl_graph_slam hdl_graph_slam_400_ours.launch\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/","title":"hdl_graph_slam","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#hdl_graph_slam","title":"hdl_graph_slam","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#what-is-hdl_graph_slam","title":"What is hdl_graph_slam?","text":"<ul> <li>An open source ROS package for real-time 6DOF SLAM using a 3D LIDAR. It is based on 3D Graph SLAM with NDT scan matching-based odometry estimation and loop detection. It also supports several graph constraints, such as GPS, IMU acceleration (gravity vector), IMU orientation (magnetic sensor), and floor plane (detected in a point cloud).</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/koide3/hdl_graph_slam</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [Velodyne, Ouster, RoboSense]</li> <li>IMU [6-AXIS, 9-AXIS] [OPTIONAL]</li> <li>GPS [OPTIONAL]</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#dependencies","title":"Dependencies","text":"<ul> <li>ROS</li> <li>PCL</li> <li>g2o</li> <li>OpenMP</li> </ul> <p>The following ROS packages are required:</p> <ul> <li>geodesy</li> <li>nmea_msgs</li> <li>pcl_ros</li> <li>ndt_omp</li> <li>fast_gicp</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#1-build","title":"1) Build","text":"<pre><code># for melodic\nsudo apt-get install ros-melodic-geodesy ros-melodic-pcl-ros ros-melodic-nmea-msgs ros-melodic-libg2o\ncd catkin_ws/src\ngit clone https://github.com/koide3/ndt_omp.git -b melodic\ngit clone https://github.com/SMRT-AIST/fast_gicp.git --recursive\ngit clone https://github.com/koide3/hdl_graph_slam\n\ncd .. &amp;&amp; catkin_make -DCMAKE_BUILD_TYPE=Release\n\n# for noetic\nsudo apt-get install ros-noetic-geodesy ros-noetic-pcl-ros ros-noetic-nmea-msgs ros-noetic-libg2o\n\ncd catkin_ws/src\ngit clone https://github.com/koide3/ndt_omp.git\ngit clone https://github.com/SMRT-AIST/fast_gicp.git --recursive\ngit clone https://github.com/koide3/hdl_graph_slam\n\ncd .. &amp;&amp; catkin_make -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#2-set-parameter","title":"2) Set parameter","text":"<ul> <li>Set lidar topic on <code>launch/hdl_graph_slam_400.launch</code></li> </ul> <ul> <li>Set registration settings on <code>launch/hdl_graph_slam_400.launch</code></li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#3-run","title":"3) Run","text":"<pre><code>rosparam set use_sim_time true\nroslaunch hdl_graph_slam hdl_graph_slam_400.launch\n</code></pre> <pre><code>roscd hdl_graph_slam/rviz\nrviz -d hdl_graph_slam.rviz\n</code></pre> <pre><code>rosbag play --clock hdl_400.bag\n</code></pre> <p>Save the generated map by:</p> <pre><code>rosservice call /hdl_graph_slam/save_map \"resolution: 0.05\ndestination: '/full_path_directory/map.pcd'\"\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#example-result","title":"Example Result","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#example2-outdoor","title":"Example2 (Outdoor)","text":"<p>Bag file (recorded in an outdoor environment):</p> <ul> <li>hdl_400.bag.tar.gz (raw data, about 900MB)</li> </ul> <pre><code>rosparam set use_sim_time true\nroslaunch hdl_graph_slam hdl_graph_slam_400.launch\n</code></pre> <pre><code>roscd hdl_graph_slam/rviz\nrviz -d hdl_graph_slam.rviz\n</code></pre> <pre><code>rosbag play --clock dataset.bag\n</code></pre> <p> </p> <p> </p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#papers","title":"Papers","text":"<p>Kenji Koide, Jun Miura, and Emanuele Menegatti, A Portable 3D LIDAR-based System for Long-term and Wide-area People Behavior Measurement, Advanced Robotic Systems, 2019 [link].</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/hdl-graph-slam/#contact","title":"Contact","text":"<p>Kenji Koide, k.koide@aist.go.jp, https://staff.aist.go.jp/k.koide</p> <p>[Active Intelligent Systems Laboratory, Toyohashi University of Technology, Japan] [Mobile Robotics Research Team, National Institute of Advanced Industrial Science and Technology (AIST), Japan]</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/","title":"IA-LIO-SAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#ia-lio-sam","title":"IA-LIO-SAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#what-is-ia-lio-sam","title":"What is IA-LIO-SAM?","text":"<ul> <li>IA_LIO_SLAM is created for data acquisition in unstructured environment and it is a framework for Intensity and Ambient Enhanced Lidar Inertial Odometry via Smoothing and Mapping that achieves highly accurate robot trajectories and mapping.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/minwoo0611/IA_LIO_SAM</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [Velodyne, Ouster]</li> <li>IMU [9-AXIS]</li> <li>GNSS</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#dependencies","title":"Dependencies","text":"<ul> <li> <p>ROS (tested with Kinetic and Melodic)</p> <ul> <li> <p><code>for ROS melodic:</code></p> <pre><code>sudo apt-get install -y ros-melodic-navigation\nsudo apt-get install -y ros-melodic-robot-localization\nsudo apt-get install -y ros-melodic-robot-state-publisher\n</code></pre> </li> </ul> <ul> <li> <p><code>for ROS kinetic:</code></p> <pre><code>sudo apt-get install -y ros-kinetic-navigation\nsudo apt-get install -y ros-kinetic-robot-localization\nsudo apt-get install -y ros-kinetic-robot-state-publisher\n</code></pre> </li> </ul> </li> </ul> <ul> <li> <p>GTSAM (Georgia Tech Smoothing and Mapping library)   </p> <pre><code>wget -O ~/Downloads/gtsam.zip https://github.com/borglab/gtsam/archive/4.0.2.zip\ncd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/\ncd ~/Downloads/gtsam-4.0.2/\nmkdir build &amp;&amp; cd build\ncmake -DGTSAM_BUILD_WITH_MARCH_NATIVE=OFF ..\nsudo make install -j8\n</code></pre> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#1-build","title":"1) Build","text":"<pre><code>    mkdir -p ~/catkin_ia_lio/src\n    cd ~/catkin_ia_lio/src\n    git clone https://github.com/minwoo0611/IA_LIO_SAM\n    cd ..\n    catkin_make\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#2-set-parameters","title":"2) Set parameters","text":"<ul> <li>After downloading the repository, change topic and sensor settings on the config file (<code>workspace/src/IA_LIO_SAM/config/params.yaml</code>)</li> </ul> <ul> <li>For imu-lidar compatibility, extrinsic matrices from calibration must be changed.</li> </ul> <ul> <li>To enable autosave, <code>savePCD</code> must be <code>true</code> on the <code>params.yaml</code> file (<code>workspace/src/IA_LIO_SAM/config/params.yaml</code>).</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#3-run","title":"3) Run","text":"<pre><code>  # open new terminal: run IA_LIO\n  source devel/setup.bash\n  roslaunch lio_sam mapping_ouster64.launch\n\n  # play bag file in the other terminal\n  rosbag play RECORDED_BAG.bag --clock\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#sample-dataset-images","title":"Sample dataset images","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#example-dataset","title":"Example dataset","text":"<p>Check original repo link for example dataset.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#contact","title":"Contact","text":"<ul> <li>Maintainer: Kevin Jung (<code>GitHub: minwoo0611</code>)</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#paper","title":"Paper","text":"<p>Thank you for citing IA-LIO-SAM(./config/doc/KRS-2021-17.pdf) if you use any of this code.</p> <p>Part of the code is adapted from LIO-SAM (IROS-2020).</p> <pre><code>@inproceedings{legoloam2018shan,\n  title={LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain},\n  author={Shan, Tixiao and Englot, Brendan},\n  booktitle={IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)},\n  pages={4758-4765},\n  year={2018},\n  organization={IEEE}\n}\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/ia-lio-slam/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>IA-LIO-SAM is based on LIO-SAM (T. Shan, B. Englot, D. Meyers, W. Wang, C. Ratti, and D. Rus. LIO-SAM: Tightly-coupled Lidar Inertial Odometry via Smoothing and Mapping).</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/","title":"ISCLOAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#iscloam","title":"ISCLOAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#what-is-iscloam","title":"What is ISCLOAM?","text":"<ul> <li>ISCLOAM presents a robust loop closure detection approach by integrating both geometry and intensity information.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/wh200720041/iscloam</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [Velodyne]</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#dependencies","title":"Dependencies","text":"<ul> <li>Ubuntu 64-bit 18.04</li> <li>ROS Melodic ROS Installation</li> <li>Ceres Solver Ceres Installation</li> <li>PCL PCL Installation</li> <li>Gtsam GTSAM Installation</li> <li>OpenCV OPENCV Installation</li> <li>Trajectory visualization</li> </ul> <p>For visualization purpose, this package uses hector trajectory sever, you may install the package by</p> <pre><code>sudo apt-get install ros-melodic-hector-trajectory-server\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#build-and-run","title":"Build and Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#1-clone-repository","title":"1. Clone repository","text":"<pre><code>cd ~/catkin_ws/src\ngit clone https://github.com/wh200720041/iscloam.git\ncd ..\ncatkin_make -j1\nsource ~/catkin_ws/devel/setup.bash\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#2-set-parameter","title":"2. Set Parameter","text":"<p>Change the bag location and sensor parameters on launch files.</p> <p></p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#3-launch","title":"3. Launch","text":"<pre><code>roslaunch iscloam iscloam.launch\n</code></pre> <p>if you would like to generate the map of environment at the same time, you can run</p> <pre><code>roslaunch iscloam iscloam_mapping.launch\n</code></pre> <p>Note that the global map can be very large, so it may takes a while to perform global optimization, some lag is expected between trajectory and map since they are running in separate thread. More CPU usage will happen when loop closure is identified.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#example-result","title":"Example Result","text":"<p>Watch demo video at Video Link</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#ground-truth-comparison","title":"Ground Truth Comparison","text":"<p>Green: ISCLOAM Red: Ground Truth</p> <p> </p> <pre><code>                  KITTI sequence 00                                  KITTI sequence 05\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#citation","title":"Citation","text":"<p>If you use this work for your research, you may want to cite the paper below, your citation will be appreciated</p> <pre><code>@inproceedings{wang2020intensity,\n  author={H. {Wang} and C. {Wang} and L. {Xie}},\n  booktitle={2020 IEEE International Conference on Robotics and Automation (ICRA)},\n  title={Intensity Scan Context: Coding Intensity and Geometry Relations for Loop Closure Detection},\n  year={2020},\n  volume={},\n  number={},\n  pages={2095-2101},\n  doi={10.1109/ICRA40945.2020.9196764}\n}\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/iscloam/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks for A-LOAM and LOAM(J. Zhang and S. Singh. LOAM: Lidar Odometry and Mapping in Real-time) and LOAM_NOTED.</p> <p>Author: Wang Han, Nanyang Technological University, Singapore</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/","title":"LeGO-LOAM-BOR","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#lego-loam-bor","title":"LeGO-LOAM-BOR","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#what-is-lego-loam-bor","title":"What is LeGO-LOAM-BOR?","text":"<ul> <li>LeGO-LOAM-BOR is improved version of the LeGO-LOAM by improving quality of the code, making it more readable and consistent. Also, performance is improved by converting processes to multi-threaded approach.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/facontidavide/LeGO-LOAM-BOR</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [VLP-16]</li> <li>IMU [9-AXIS]</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#dependencies","title":"Dependencies","text":"<ul> <li>ROS Melodic ROS Installation</li> <li>PCL PCL Installation</li> <li>Gtsam GTSAM Installation</li> </ul> <pre><code>wget -O ~/Downloads/gtsam.zip https://github.com/borglab/gtsam/archive/4.0.0-alpha2.zip\ncd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/\ncd ~/Downloads/gtsam-4.0.0-alpha2/\nmkdir build &amp;&amp; cd build\ncmake ..\nsudo make install\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#1-build","title":"1) Build","text":"<pre><code>cd ~/catkin_ws/src\ngit clone https://github.com/facontidavide/LeGO-LOAM-BOR.git\ncd ..\ncatkin_make\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#2-set-parameters","title":"2) Set parameters","text":"<ul> <li>Set parameters on <code>LeGo-LOAM/loam_config.yaml</code></li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#3-run","title":"3) Run","text":"<pre><code>source devel/setup.bash\nroslaunch lego_loam_bor run.launch rosbag:=/path/to/your/rosbag lidar_topic:=/velodyne_points\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#example-result","title":"Example Result","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lego-loam-bor/#cite-lego-loam","title":"Cite LeGO-LOAM","text":"<p>Thank you for citing our LeGO-LOAM paper if you use any of this code:</p> <pre><code>@inproceedings{legoloam2018,\n  title={LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain},\n  author={Tixiao Shan and Brendan Englot},\n  booktitle={IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)},\n  pages={4758-4765},\n  year={2018},\n  organization={IEEE}\n}\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/","title":"LIO-SAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#lio-sam","title":"LIO-SAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#what-is-lio-sam","title":"What is LIO-SAM?","text":"<ul> <li>A framework that achieves highly accurate, real-time mobile robot trajectory estimation and map-building. It formulates lidar-inertial odometry atop a factor graph, allowing a multitude of relative and absolute measurements, including loop closures, to be incorporated from different sources as factors into the system.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/TixiaoShan/LIO-SAM</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [Livox, Velodyne, Ouster, Robosense*]</li> <li>IMU [9-AXIS]</li> <li>GPS [OPTIONAL]</li> </ul> <p>*Robosense lidars aren't supported officially, but their Helios series can be used as Velodyne lidars.</p> <p>The system architecture of LIO-SAM method described in the following diagram, please look at the official repository for getting more information.</p> <p> </p>      System Architecture of LIO-SAM    <p>We are using Robosense Helios 5515 and CLAP B7 sensor on tutorial_vehicle, so we will use these sensors for running LIO-SAM.</p> <p>Additionally, LIO-SAM tested with Applanix POS LVX and Hesai Pandar XT32 sensor setup. Some additional information according to the sensors will be provided in this page.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#ros-compatibility","title":"ROS Compatibility","text":"<p>Since Autoware uses ROS 2 Humble currently, we will continue with ROS 2 version of LIO-SAM.</p> <ul> <li>ROS</li> <li>ROS 2 (Also, it is compatible with Humble distro)</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#dependencies","title":"Dependencies","text":"<p>ROS 2 dependencies:</p> <ul> <li>perception-pcl</li> <li>pcl-msgs</li> <li>vision-opencv</li> <li>xacro</li> </ul> <p>To install these dependencies, you can use this bash command in your terminal:</p> <pre><code>sudo apt install ros-humble-perception-pcl \\\nros-humble-pcl-msgs \\\nros-humble-vision-opencv \\\nros-humble-xacro\n</code></pre> <p>Other dependencies:</p> <ul> <li>gtsam (Georgia Tech Smoothing and Mapping library)</li> </ul> <p>To install the gtsam, you can use this bash command in your terminal:</p> <pre><code>  # Add GTSAM-PPA\nsudo add-apt-repository ppa:borglab/gtsam-release-4.1\n  sudo apt install libgtsam-dev libgtsam-unstable-dev\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#1-installation","title":"1) Installation","text":"<p>In order to use and build LIO-SAM, we will create workspace for LIO-SAM:</p> <pre><code>    mkdir -p ~/lio-sam-ws/src\n    cd ~/lio-sam-ws/src\n    git clone -b ros2 https://github.com/TixiaoShan/LIO-SAM.git\n    cd ..\n    colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#2-settings","title":"2) Settings","text":"<p>After the building of LIO-SAM, we need to record ROS 2 Bag file with including necessary topics for LIO-SAM. The necessary topics are described in the config file on LIO-SAM.</p> ROS 2 Bag example for LIO-SAM with Robosense Helios and CLAP B7 <pre><code>Files:             map_bag_13_09_0.db3\nBag size:          38.4 GiB\nStorage id:        sqlite3\nDuration:          3295.326s\nStart:             Sep 13 2023 16:40:23.165 (1694612423.165)\nEnd:               Sep 13 2023 17:35:18.492 (1694615718.492)\nMessages:          1627025\nTopic information: Topic: /sensing/gnss/clap/ros/imu | Type: sensor_msgs/msg/Imu | Count: 329535 | Serialization Format: cdr\nTopic: /sensing/gnss/clap/ros/odometry | Type: nav_msgs/msg/Odometry | Count: 329533 | Serialization Format: cdr\nTopic: /sensing/lidar/top/pointcloud_raw | Type: sensor_msgs/msg/PointCloud2 | Count: 32953 | Serialization Format: cdr\n</code></pre> <p>Note: We use <code>use_odometry</code> as true at clap_b7_driver for publishing GPS odometry topic from navsatfix.</p> <p>Please set topics and sensor settings on <code>lio_sam/config/params.yaml</code>. Here are some example modifications for out tutorial_vehicle.</p> <ul> <li>Topic names:</li> </ul> <pre><code>-   pointCloudTopic: \"/points\"\n+   pointCloudTopic: \"/sensing/lidar/top/pointcloud_raw\"\n-   imuTopic: \"/imu/data\"\n+   imuTopic: \"/sensing/gnss/clap/ros/imu\"\n   odomTopic: \"odometry/imu\"\n-   gpsTopic: \"odometry/gpsz\"\n+   gpsTopic: \"/sensing/gnss/clap/ros/odometry\"\n</code></pre> <p>Since we will use GPS information with Autoware, so we need to enable <code>useImuHeadingInitialization</code> parameter.</p> <ul> <li>GPS settings:</li> </ul> <pre><code>-   useImuHeadingInitialization: false\n+   useImuHeadingInitialization: true\n-   useGpsElevation: false\n+   useGpsElevation: true\n</code></pre> <p>We will update sensor settings also. Since Robosense Lidars aren't officially supported, we will set our 32-channel Robosense Helios 5515 lidar as Velodyne:</p> <ul> <li>Sensor settings:</li> </ul> <pre><code>-   sensor: ouster\n+   sensor: velodyne\n-   N_SCAN: 64\n+   N_SCAN: 32\n-   Horizon_SCAN: 512\n+   Horizon_SCAN: 1800\n</code></pre> <p>After that, we will update extrinsic transformations between Robosense Lidar and CLAP B7 GNSS/INS (IMU) system.</p> <ul> <li>Extrinsic transformation:</li> </ul> <pre><code>-   extrinsicTrans:  [ 0.0,  0.0,  0.0 ]\n+   extrinsicTrans:  [-0.91, 0.0, -1.71]\n-   extrinsicRot:    [-1.0,  0.0,  0.0,\n-                      0.0,  1.0,  0.0,\n-                      0.0,  0.0, -1.0 ]\n+   extrinsicRot:    [1.0,  0.0,  0.0,\n+                     0.0,  1.0,  0.0,\n+                     0.0,  0.0, 1.0 ]\n-   extrinsicRPY: [ 0.0,  1.0,  0.0,\n-                  -1.0,  0.0,  0.0,\n-                   0.0,  0.0,  1.0 ]\n+   extrinsicRPY: [ 1.0,  0.0,  0.0,\n+                   0.0,  1.0,  0.0,\n+                   0.0,  0.0,  1.0 ]\n</code></pre> <p>Warning</p> <p>The mapping direction is towards to the going direction in the real world. If LiDAR sensor is backwards, according to the direction you are moving, then you need to change the extrinsicRot too. Unless the IMU tries to go in the wrong direction, and it may occur problems.</p> <p>For example, in our Applanix POS LVX and Hesai Pandar XT32 setup, IMU direction was towards to the going direction and LiDAR direction has 180 degree difference in Z-axis according to the IMU direction. In other words, they were facing back to each other. The tool may need a transformation for IMU for that.</p> <ul> <li>In that situation, the calibration parameters changed as this:</li> </ul> <pre><code>-   extrinsicRot:    [-1.0,  0.0,  0.0,\n-                      0.0,  1.0,  0.0,\n-                      0.0,  0.0, -1.0 ]\n+   extrinsicRot:    [-1.0,  0.0,  0.0,\n+                     0.0,  -1.0,  0.0,\n+                     0.0,   0.0,  1.0 ]\n-   extrinsicRPY: [ 0.0,  1.0,  0.0,\n-                  -1.0,  0.0,  0.0,\n-                   0.0,  0.0,  1.0 ]\n+   extrinsicRPY: [ -1.0,  0.0,  0.0,\n+                    0.0, -1.0,  0.0,\n+                    0.0,  0.0,  1.0 ]\n</code></pre> <ul> <li>In the end, we got this transform visualization in RViz:</li> </ul> <p> </p>      Transform Visualization of Applanix POS LVX and Hesai Pandar XT32 in RViz    <p>Now, we are ready to create a map for Autoware.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#3-usage","title":"3) Usage","text":"<p>If you are set configurations and create bag file for LIO-SAM, you can launch LIO-SAM with:</p> <pre><code>ros2 launch lio_sam run.launch.py\n</code></pre> <p>The rviz2 screen will be open, then you can play your bag file:</p> <pre><code>ros2 bag play &lt;YOUR-BAG-FILE&gt;\n</code></pre> <p>If the mapping process is finished, you can save map with calling this service:</p> <pre><code>ros2 service call /lio_sam/save_map lio_sam/srv/SaveMap \"{resolution: 0.2, destination: &lt;YOUR-MAP-DIRECTORY&gt;}\"\n</code></pre> <p>Here is the video for demonstration of LIO-SAM mapping in our campus environment:</p> <p></p> <p>The output map format is local UTM, we will change local UTM map to MGRS format for tutorial_vehicle. Also, if you want change UTM to MGRS for autoware, please follow convert-utm-to-mgrs-map page.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#example-result","title":"Example Result","text":"Sample Map Output for our Campus Environment"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#paper","title":"Paper","text":"<p>Thank you for citing LIO-SAM (IROS-2020) if you use any of this code.</p> <pre><code>@inproceedings{liosam2020shan,\n  title={LIO-SAM: Tightly-coupled Lidar Inertial Odometry via Smoothing and Mapping},\n  author={Shan, Tixiao and Englot, Brendan and Meyers, Drew and Wang, Wei and Ratti, Carlo and Rus Daniela},\n  booktitle={IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)},\n  pages={5135-5142},\n  year={2020},\n  organization={IEEE}\n}\n</code></pre> <p>Part of the code is adapted from LeGO-LOAM.</p> <pre><code>@inproceedings{legoloam2018shan,\n  title={LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain},\n  author={Shan, Tixiao and Englot, Brendan},\n  booktitle={IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)},\n  pages={4758-4765},\n  year={2018},\n  organization={IEEE}\n}\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/lio-sam/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>LIO-SAM is based on LOAM (J. Zhang and S. Singh. LOAM: Lidar Odometry and Mapping in Real-time).</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/","title":"Optimized-SC-F-LOAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#optimized-sc-f-loam","title":"Optimized-SC-F-LOAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#what-is-optimized-sc-f-loam","title":"What is Optimized-SC-F-LOAM?","text":"<ul> <li>An improved version of F-LOAM and uses an adaptive threshold to further judge the loop closure detection results and reducing false loop closure detections. Also it uses feature point-based matching to calculate the constraints between a pair of loop closure frame point clouds and decreases time consumption of constructing loop frame constraints.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/SlamCabbage/Optimized-SC-F-LOAM</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [VLP-16, HDL-32, HDL-64]</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#dependencies","title":"Dependencies","text":"<ul> <li>ROS</li> <li>PCL</li> <li>GTSAM</li> <li>Ceres Solver</li> <li>For visualization purpose, this package uses hector trajectory sever, you may install the package by</li> </ul> <pre><code>sudo apt-get install ros-noetic-hector-trajectory-server\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#1-build","title":"1) Build","text":"<pre><code>cd ~/catkin_ws/src\ngit clone https://github.com/SlamCabbage/Optimized-SC-F-LOAM.git\ncd ..\ncatkin_make\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#2-create-message-file","title":"2) Create message file","text":"<p>In this folder, Ground Truth information, optimized pose information, F-LOAM pose information and time information are stored</p> <pre><code>mkdir -p ~/message/Scans\n\nChange line 383 in the laserLoopOptimizationNode.cpp to your own \"message\" folder path\n</code></pre> <p>(Do not forget to rebuild your package)</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#3-set-parameters","title":"3) Set parameters","text":"<ul> <li>Set LIDAR topic and LIDAR properties on 'sc_f_loam_mapping.launch'</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#4-run","title":"4) Run","text":"<pre><code>source devel/setup.bash\nroslaunch optimized_sc_f_loam optimized_sc_f_loam_mapping.launch\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#example-result","title":"Example Result","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#results-on-kitti-sequence-00-and-sequence-05","title":"Results on KITTI Sequence 00 and Sequence 05","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#comparison-of-trajectories-on-kitti-dataset","title":"Comparison of trajectories on KITTI dataset","text":"<p>Test on KITTI sequence You can download the sequence 00 and 05 datasets from the KITTI official website and convert them into bag files using the kitti2bag open source method.</p> <p>00: 2011_10_03_drive_0027 000000 004540</p> <p>05: 2011_09_30_drive_0018 000000 002760</p> <p>See the link: https://github.com/ethz-asl/kitti_to_rosbag</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks for SC-A-LOAM(Scan context: Egocentric spatial descriptor for place recognition within 3d point cloud map) and F-LOAM(F-LOAM : Fast LiDAR Odometry and Mapping).</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/optimized-sc-f-loam/#citation","title":"Citation","text":"<pre><code>@misc{https://doi.org/10.48550/arxiv.2204.04932,\n  doi = {10.48550/ARXIV.2204.04932},\n\n  url = {https://arxiv.org/abs/2204.04932},\n\n  author = {Liao, Lizhou and Fu, Chunyun and Feng, Binbin and Su, Tian},\n\n  keywords = {Robotics (cs.RO), FOS: Computer and information sciences, FOS: Computer and information sciences},\n\n  title = {Optimized SC-F-LOAM: Optimized Fast LiDAR Odometry and Mapping Using Scan Context},\n\n  publisher = {arXiv},\n\n  year = {2022},\n\n  copyright = {arXiv.org perpetual, non-exclusive license}\n}\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/","title":"SC-A-LOAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#sc-a-loam","title":"SC-A-LOAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#what-is-sc-a-loam","title":"What is SC-A-LOAM?","text":"<ul> <li>A real-time LiDAR SLAM package that integrates A-LOAM and ScanContext.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/gisbi-kim/SC-A-LOAM</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [VLP-16, HDL-32, HDL-64, Ouster OS1-64]</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#prerequisites-dependencies","title":"Prerequisites (dependencies)","text":"<ul> <li>ROS</li> <li>GTSAM version 4.x.</li> </ul> <ul> <li> <p>If GTSAM is not installed, follow the steps below.   </p> <pre><code>  wget -O ~/Downloads/gtsam.zip https://github.com/borglab/gtsam/archive/4.0.2.zip\n  cd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/\n  cd ~/Downloads/gtsam-4.0.2/\n  mkdir build &amp;&amp; cd build\n  cmake -DGTSAM_BUILD_WITH_MARCH_NATIVE=OFF ..\n  sudo make install -j8\n</code></pre> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#1-build","title":"1) Build","text":"<ul> <li> <p>First, install the above mentioned dependencies and follow below lines.    </p> <pre><code> mkdir -p ~/catkin_scaloam_ws/src\n cd ~/catkin_scaloam_ws/src\n git clone https://github.com/gisbi-kim/SC-A-LOAM.git\n cd ../\n catkin_make\n source ~/catkin_scaloam_ws/devel/setup.bash\n</code></pre> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#2-set-parameters","title":"2) Set parameters","text":"<ul> <li>After downloading the repository, change topic and sensor settings on the launch files.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#scan-context-parameters","title":"Scan Context parameters","text":"<ul> <li>If encountering ghosting error or loop is not closed, change the scan context parameters.</li> <li>Adjust the scan context settings with the parameters in the marked area.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#3-run","title":"3) Run","text":"<pre><code>roslaunch aloam_velodyne aloam_mulran.launch\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#4-saving-as-pcd-file","title":"4) Saving as PCD file","text":"<pre><code>  rosrun pcl_ros pointcloud_to_pcd input:=/aft_pgo_map\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#example-results","title":"Example Results","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#riverside-01-mulran-dataset","title":"Riverside 01, MulRan dataset","text":"<ul> <li>The MulRan dataset provides lidar scans (Ouster OS1-64, horizontally mounted, 10Hz) and consumer level gps (u-blox EVK-7P, 4Hz) data.</li> <li>About how to use (publishing data) data: see here https://github.com/irapkaist/file_player_mulran</li> <li> <p>example videos on Riverside 01 sequence.</p> <pre><code>1. with consumer level GPS-based altitude stabilization: https://youtu.be/FwAVX5TVm04\n2. without the z stabilization: https://youtu.be/okML_zNadhY\n</code></pre> </li> </ul> <ul> <li> <p>example result:</p> <p></p> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#kitti-05","title":"KITTI 05","text":"<ul> <li> <p>For KITTI (HDL-64 sensor), run using the command    </p> <pre><code>roslaunch aloam_velodyne aloam_velodyne_HDL_64.launch # for KITTI dataset setting\n</code></pre> </li> </ul> <ul> <li>To publish KITTI scans, you can use mini-kitti publisher, a simple python script: https://github.com/gisbi-kim/mini-kitti-publisher</li> <li>example video (no GPS used here): https://youtu.be/hk3Xx8SKkv4</li> <li> <p>example result:</p> <p></p> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-a-loam/#contact","title":"Contact","text":"<ul> <li>Maintainer: paulgkim@kaist.ac.kr</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/","title":"SC-LeGO-LOAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#sc-lego-loam","title":"SC-LeGO-LOAM","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#what-is-sc-lego-loam","title":"What is SC-LeGO-LOAM?","text":"<ul> <li>SC-LeGO-LOAM integrated LeGO-LOAM for lidar odometry and 2 different loop closure methods: ScanContext and Radius search based loop closure. While ScanContext is correcting large drifts, radius search based method is good for fine-stitching.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#repository-information","title":"Repository Information","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#original-repository-link","title":"Original Repository link","text":"<p>https://github.com/irapkaist/SC-LeGO-LOAM</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#required-sensors","title":"Required Sensors","text":"<ul> <li>LIDAR [VLP-16, HDL-32E, VLS-128, Ouster OS1-16, Ouster OS1-64]</li> <li>IMU [9-AXIS]</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#ros-compatibility","title":"ROS Compatibility","text":"<ul> <li>ROS 1</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#dependencies","title":"Dependencies","text":"<ul> <li>ROS</li> <li>PCL</li> <li>GTSAM</li> </ul> <pre><code>wget -O ~/Downloads/gtsam.zip https://github.com/borglab/gtsam/archive/4.0.0-alpha2.zip\ncd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/\ncd ~/Downloads/gtsam-4.0.0-alpha2/\nmkdir build &amp;&amp; cd build\ncmake ..\nsudo make install\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#build-run","title":"Build &amp; Run","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#1-build","title":"1) Build","text":"<pre><code>cd ~/catkin_ws/src\ngit clone https://github.com/irapkaist/SC-LeGO-LOAM.git\ncd ..\ncatkin_make\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#2-set-parameters","title":"2) Set parameters","text":"<ul> <li>Set imu and lidar topic on <code>include/utility.h</code></li> <li>Set lidar properties on <code>include/utility.h</code></li> <li>Set scan context settings on <code>include/Scancontext.h</code></li> </ul> <p>(Do not forget to rebuild after setting parameters.)</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#3-run","title":"3) Run","text":"<pre><code>source devel/setup.bash\nroslaunch lego_loam run.launch\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#example-result","title":"Example Result","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#other-examples","title":"Other Examples","text":"<ul> <li> Video 1: DCC (MulRan dataset)</li> <li> Video 2: Riverside (MulRan dataset) </li> <li> <p> Video 3: KAIST (MulRan dataset)  </p> <p></p> <p></p> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#mulran-dataset","title":"MulRan dataset","text":"<ul> <li>If you want to reproduce the results as the above video, you can download the  MulRan dataset  and use the  ROS topic publishing tool .</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#cite-sc-lego-loam","title":"Cite SC-LeGO-LOAM","text":"<pre><code>@INPROCEEDINGS { gkim-2018-iros,\n  author = {Kim, Giseop and Kim, Ayoung},\n  title = { Scan Context: Egocentric Spatial Descriptor for Place Recognition within {3D} Point Cloud Map },\n  booktitle = { Proceedings of the IEEE/RSJ International Conference on Intelligent Robots and Systems },\n  year = { 2018 },\n  month = { Oct. },\n  address = { Madrid }\n}\n</code></pre> <p>and</p> <pre><code>@inproceedings{legoloam2018,\n  title={LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain},\n  author={Shan, Tixiao and Englot, Brendan},\n  booktitle={IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)},\n  pages={4758-4765},\n  year={2018},\n  organization={IEEE}\n}\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-maps/open-source-slam/sc-lego-loam/#contact","title":"Contact","text":"<ul> <li>Maintainer: Giseop Kim (<code>paulgkim@kaist.ac.kr</code>)</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-maps/pointcloud-map-downsampling/","title":"Pointcloud map downsampling","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/pointcloud-map-downsampling/#pointcloud-map-downsampling","title":"Pointcloud map downsampling","text":""},{"location":"how-to-guides/integrating-autoware/creating-maps/pointcloud-map-downsampling/#overview","title":"Overview","text":"<p>When your created point cloud map is either too dense or too large (i.e., exceeding 300 MB), you may want to downsample it for improved computational and memory efficiency. Also, you can consider using dynamic map loading with partial loading, please check map_loader package for more information.</p> <p>At tutorial_vehicle implementation we will use the whole map, so we will downsample it with using CloudCompare.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/pointcloud-map-downsampling/#installing-cloudcompare","title":"Installing CloudCompare","text":"<p>You can install it by snap:</p> <pre><code>sudo snap install cloudcompare\n</code></pre> <p>Please check the official page for installing options.</p>"},{"location":"how-to-guides/integrating-autoware/creating-maps/pointcloud-map-downsampling/#downsampling-a-pointcloud-map","title":"Downsampling a pointcloud map","text":"<p>There are three subsampling methods on CloudCompare, we are using <code>Space</code> method for subsampling, but you can use other methods if you want.</p> <ol> <li>Please open CloudCompare and drag your pointcloud to here, then you can select your pointcloud map by just clicking on the map at the DB tree panel.</li> <li>Then you can click <code>subsample</code> button on the top panel.</li> </ol> <p> </p>      CloudCompare    <ol> <li>Please select on your subsample method, we will use space for tutorial_vehicle.</li> <li>Then you can select options. For example, we need to determine minimum space between points. (Please be careful in this section, subsampling is depending on your map size, computer performance, etc.) We will set this value 0.2 for tutorial_vehicle's map.</li> </ol> <p> </p>      Pointcloud subsampling    <ul> <li>After the subsampling process is finished,   you should select pointcloud on the DB Tree panel as well.</li> </ul> <p> </p>      Select your downsampled pointcloud    <p>Now, you can save your downsampled pointcloud with <code>ctrl + s</code> or you can click save button from <code>File</code> bar. Then, this pointcloud can be used by autoware.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/","title":"Creating vehicle and sensor models","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/#creating-vehicle-and-sensor-models","title":"Creating vehicle and sensor models","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/#overview","title":"Overview","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/#sensor-model","title":"Sensor Model","text":"<ul> <li>Purpose: The sensor model includes the calibration (transformation) and launch files of the   sensors used in the autonomous vehicle.   This includes various sensors like LiDARs, cameras,   radars, IMUs (Inertial Measurement Units), GPS units, etc.</li> </ul> <ul> <li>Importance: Accurate sensor modeling is essential for perception tasks.   Precise calibration values help understand the environment by processing sensor data,   such as detecting objects, estimating distances,   and creating a 3D representation of the surroundings.</li> </ul> <ul> <li>Usage: The sensor model is utilized in Autoware for launching sensors,   configuring their pipeline, and describing calibration values.</li> </ul> <ul> <li>The sensor model (sensor kit) consists of the following three packages:<ul> <li><code>common_sensor_launch</code></li> <li><code>&lt;YOUR_VEHICLE_NAME&gt;_sensor_kit_description</code></li> <li><code>&lt;YOUR_VEHICLE_NAME&gt;_sensor_kit_launch</code></li> </ul> </li> </ul> <p>Please refer to the creating sensor model page for creating your individual sensor model.</p> <p>For reference, here is the folder structure for the sample_sensor_kit_launch package in Autoware:</p> <pre><code>sample_sensor_kit_launch/\n\u251c\u2500 common_sensor_launch/\n\u251c\u2500 sample_sensor_kit_description/\n\u2514\u2500 sample_sensor_kit_launch/\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/#vehicle-model","title":"Vehicle Model","text":"<ul> <li>Purpose: The vehicle model includes individual vehicle specifications with dimensions,   a 3D model of the vehicle (in .fbx or .dae format), etc.</li> </ul> <ul> <li>Importance: An accurate vehicle model is crucial for motion planning and control.</li> </ul> <ul> <li>Usage: The vehicle model is employed in Autoware to provide vehicle information for Autoware,   including the 3D model of the vehicle.</li> </ul> <ul> <li>The vehicle model comprises the following two packages:<ul> <li><code>&lt;YOUR_VEHICLE_NAME&gt;_vehicle_description</code></li> <li><code>&lt;YOUR_VEHICLE_NAME&gt;_vehicle_launch</code></li> </ul> </li> </ul> <p>Please consult the creating vehicle model page for creating your individual vehicle model.</p> <p>As a reference, here is the folder structure for the sample_vehicle_launch package in Autoware:</p> <pre><code>sample_vehicle_launch/\n\u251c\u2500 sample_vehicle_description/\n\u2514\u2500 sample_vehicle_launch/\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/","title":"Calibrating your sensors","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/#calibrating-your-sensors","title":"Calibrating your sensors","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/#overview","title":"Overview","text":"<p>Autoware expects to have multiple sensors attached to the vehicle as input to perception, localization, and planning stack. Autoware uses fusion techniques to combine information from multiple sensors. For this to work effectively, all sensors must be calibrated properly to align their coordinate systems, and their positions must be defined using either urdf files (as in sample_sensor_kit) or as tf launch files. In this documentation, we will explain TIER IV's CalibrationTools repository for the calibration process. Please look at Starting with TIER IV's CalibrationTools page for installation and usage of this tool.</p> <p>If you want to look at other calibration packages and methods, you can check out the following packages.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/#other-packages-you-can-check-out","title":"Other packages you can check out","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/#camera-calibration","title":"Camera calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/#intrinsic-calibration","title":"Intrinsic Calibration","text":"<ul> <li>Navigation2 provides a good tutorial for camera internal calibration.</li> <li>AutoCore provides a light-weight tool.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/#lidar-lidar-calibration","title":"Lidar-lidar calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/#lidar-lidar-calibration-tool-from-autocore","title":"Lidar-Lidar Calibration tool from Autocore","text":"<p>LL-Calib on GitHub, provided by AutoCore, is a lightweight toolkit for online/offline 3D LiDAR to LiDAR calibration. It's based on local mapping and \"GICP\" method to derive the relation between main and sub lidar. Information on how to use the tool, troubleshooting tips and example rosbags can be found at the above link.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/#lidar-camera-calibration","title":"Lidar-camera calibration","text":"<p>Developed by MathWorks, The Lidar Camera Calibrator app enables you to interactively estimate the rigid transformation between a lidar sensor and a camera.</p> <p>https://ww2.mathworks.cn/help/lidar/ug/get-started-lidar-camera-calibrator.html</p> <p>SensorsCalibration toolbox v0.1: One more open source method for Lidar-camera calibration. This is a project for LiDAR to camera calibration,including automatic calibration and manual calibration</p> <p>https://github.com/PJLab-ADG/SensorsCalibration/blob/master/lidar2camera/README.md</p> <p>Developed by AutoCore, an easy-to-use lightweight toolkit for Lidar-camera-calibration is proposed. Only in three steps, a fully automatic calibration will be done.</p> <p>https://github.com/autocore-ai/calibration_tools/tree/main/lidar-cam-calib-related</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/#lidar-imu-calibration","title":"Lidar-IMU calibration","text":"<p>Developed by APRIL Lab at Zhejiang University in China, the LI-Calib calibration tool is a toolkit for calibrating the 6DoF rigid transformation and the time offset between a 3D LiDAR and an IMU, based on continuous-time batch optimization. IMU-based cost and LiDAR point-to-surfel (surfel = surface element) distance are minimized jointly, which renders the calibration problem well-constrained in general scenarios.</p> <p>AutoCore has forked the original LI-Calib tool and overwritten the Lidar input for more general usage. Information on how to use the tool, troubleshooting tips and example rosbags can be found at the LI-Calib fork on GitHub.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/calibration-tools/","title":"Starting with TIER IV's CalibrationTools","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/calibration-tools/#starting-with-tier-ivs-calibrationtools","title":"Starting with TIER IV's CalibrationTools","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/calibration-tools/#overview","title":"Overview","text":"<p>Autoware expects to have multiple sensors attached to the vehicle as input to perception, localization, and planning stack. These sensors must be calibrated correctly, and their positions must be defined at <code>sensor_kit_description</code> and <code>individual_params</code> packages. In this tutorial, we will use TIER IV's CalibrationTools repository for the calibration.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/calibration-tools/#setting-of-sensor_kit_base_link-position-with-respect-to-the-base_link","title":"Setting of sensor_kit_base_link position with respect to the base_link","text":"<p>In previous section (creating the vehicle and sensor model), we mentioned about <code>sensors_calibration.yaml</code>. This file stores <code>sensor_kit_base_link</code> (child frame) position and orientation with respect to the <code>base_link</code> (parent frame). We need to update this relative position (all values were initially set equal to zero when file is created) with using CAD data of our vehicle.</p> <p> </p>    Our tutorial_vehicle base_link to sensor_kit_base_link transformation.    <p>So, our <code>sensors_calibration.yaml</code> file for our tutorial_vehicle should be like this:</p> <pre><code>base_link:\nsensor_kit_base_link:\nx: 1.600000 # meter\ny: 0.0\nz: 1.421595 # 1.151595m + 0.270m\nroll: 0.0\npitch: 0.0\nyaw: 0.0\n</code></pre> <p>You need to update this transformation value with respect to the <code>sensor_kit_base_link</code> frame. You can also use CAD values for GNSS/INS and IMU position in <code>sensor_kit_calibration.yaml</code> file. (Please don't forget to update the sensor_kit_calibration.yaml file in both the sensor_kit_launch and individual_params packages)</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/calibration-tools/#installing-tier-ivs-calibrationtools-repositories-on-autoware","title":"Installing TIER IV's CalibrationTools repositories on autoware","text":"<p>After completing previous steps (creating your own autoware, creating a vehicle and sensor model etc.) we are ready to calibrate sensors which prepared their pipeline in creating the sensor model section.</p> <p>Firstly, we will clone CalibrationTools repositories in own autoware.</p> <pre><code>cd &lt;YOUR-OWN-AUTOWARE-DIRECTORY&gt; # for example: cd autoware.tutorial_vehicle\nwget https://raw.githubusercontent.com/tier4/CalibrationTools/tier4/universe/calibration_tools.repos\nvcs import src &lt; calibration_tools.repos\nrosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO\n</code></pre> <p>Then build the all packages after the all necessary changes are made on sensor model and vehicle model.</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/calibration-tools/#usage-of-calibrationtools","title":"Usage of CalibrationTools","text":"<p>The CalibrationTools repository has several packages for calibrating different sensor pairs such as lidar-lidar, camera-lidar, ground-lidar etc. In order to calibrate our sensors, we will modify <code>extrinsic_calibration_package</code> for our sensor kit.</p> <p>For tutorial_vehicle, completed launch files when created following tutorial sections can be found here.</p> <ul> <li>Manual Calibration</li> <li>Lidar-Lidar Calibration<ul> <li>Ground Plane-Lidar Calibration</li> </ul> </li> <li>Intrinsic Camera Calibration</li> <li>Lidar-Camera Calibration</li> <li>Lidar-Imu Calibration</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/extrinsic-manual-calibration/","title":"Manual calibration for all sensors","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/extrinsic-manual-calibration/#manual-calibration-for-all-sensors","title":"Manual calibration for all sensors","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/extrinsic-manual-calibration/#overview","title":"Overview","text":"<p>In this section, we will use Extrinsic Manual Calibration for extrinsic calibration of our sensors. After this process, we won't get accurate calibration results for final use, but we will have an initial calibration for other tools. For example, in the lidar-lidar or camera-lidar calibration phase, we will need initial calibration for getting accurate and successful calibration results.</p> <p>We need a sample bag file for the calibration process which includes raw lidar topics and camera topics. The following shows an example of a bag file used for calibration:</p> ROS 2 Bag example of our calibration process <pre><code>Files:             rosbag2_2023_09_06-13_43_54_0.db3\nBag size:          18.3 GiB\nStorage id:        sqlite3\nDuration:          169.12s\nStart:             Sep  6 2023 13:43:54.902 (1693997034.902)\nEnd:               Sep  6 2023 13:46:43.914 (1693997203.914)\nMessages:          8504\nTopic information: Topic: /sensing/lidar/top/pointcloud_raw | Type: sensor_msgs/msg/PointCloud2 | Count: 1691 | Serialization Format: cdr\n                   Topic: /sensing/lidar/front/pointcloud_raw | Type: sensor_msgs/msg/PointCloud2 | Count: 1691 | Serialization Format: cdr\n                   Topic: /sensing/camera/camera0/image_rect | Type: sensor_msgs/msg/Image | Count: 2561 | Serialization Format: cdr\n                   Topic: /sensing/camera/camera0/camera_info | Type: sensor_msgs/msg/CameraInfo | Count: 2561 | Serialization Format: cdr\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/extrinsic-manual-calibration/#extrinsic-manual-based-calibration","title":"Extrinsic Manual-Based Calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/extrinsic-manual-calibration/#creating-launch-files","title":"Creating launch files","text":"<p>First of all, we will start with creating launch file for <code>extrinsic_calibration_manager</code> package:</p> <pre><code>cd &lt;YOUR-OWN-AUTOWARE-DIRECTORY&gt;/src/autoware/calibration_tools/sensor\ncd extrinsic_calibration_manager/launch\nmkdir &lt;YOUR-OWN-SENSOR-KIT-NAME&gt; # i.e. for our guide, it will ve mkdir tutorial_vehicle_sensor_kit\ncd &lt;YOUR-OWN-SENSOR-KIT-NAME&gt; # i.e. for our guide, it will ve cd tutorial_vehicle_sensor_kit\ntouch manual.launch.xml manual_sensor_kit.launch.xml manual_sensors.launch.xml\n</code></pre> <p>We will be modifying these <code>manual.launch.xml</code>, <code>manual_sensors.launch.xml</code> and <code>manual_sensor_kit.launch.xml</code> by using TIER IV's sample sensor kit aip_x1. So, you should copy the contents of these three files from aip_x1 to your created files.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/extrinsic-manual-calibration/#modifying-launch-files-according-to-your-sensor-kit","title":"Modifying launch files according to your sensor kit","text":"<p>So, we can start modifying <code>manual.launch.xml</code>, please open this file on a text editor which will you prefer (code, gedit etc.).</p> <p>(Optionally) Let's start with adding vehicle_id and sensor model names: (Values are not important. These parameters will be overridden by launch arguments)</p> <pre><code>  &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n\n  &lt;let name=\"sensor_model\" value=\"aip_x1\"/&gt;\n+ &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n+ &lt;launch&gt;\n-   &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n+   &lt;arg name=\"vehicle_id\" default=\"&lt;YOUR_VEHICLE_ID&gt;\"/&gt;\n+\n-   &lt;arg name=\"sensor_model\" default=\"aip_x1\"/&gt;\n+   &lt;let name=\"sensor_model\" value=\"&lt;YOUR_SENSOR_KIT_NAME&gt;\"/&gt;\n</code></pre> <p>The final version of the file (manual.launch.xml) for tutorial_vehicle should be like this:</p> Sample manual.launch.xml file for tutorial vehicle <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n&lt;arg name=\"vehicle_id\" default=\"tutorial_vehicle\"/&gt;\n\n&lt;let name=\"sensor_model\" value=\"tutorial_vehicle_sensor_kit\"/&gt;\n\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"sensor_kit\"/&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_calibration_manager)/launch/$(var sensor_model)/manual_sensor_kit.launch.xml\"&gt;\n&lt;arg name=\"vehicle_id\" value=\"$(var vehicle_id)\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"sensors\"/&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_calibration_manager)/launch/$(var sensor_model)/manual_sensors.launch.xml\"&gt;\n&lt;arg name=\"vehicle_id\" value=\"$(var vehicle_id)\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n\n&lt;/launch&gt;\n</code></pre> <p>After the completing of manual.launch.xml file, we will be ready to implement manual_sensor_kit.launch.xml for the own sensor model's sensor_kit_calibration.yaml:</p> <p>Optionally, you can modify sensor_model and vehicle_id over this xml snippet as well:</p> <pre><code>...\n  &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n\n  &lt;let name=\"sensor_model\" value=\"aip_x1\"/&gt;\n+ &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n+ &lt;launch&gt;\n-   &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n+   &lt;arg name=\"vehicle_id\" default=\"&lt;YOUR_VEHICLE_ID&gt;\"/&gt;\n+\n-   &lt;arg name=\"sensor_model\" default=\"aip_x1\"/&gt;\n+   &lt;let name=\"sensor_model\" value=\"&lt;YOUR_SENSOR_KIT_NAME&gt;\"/&gt;\n...\n</code></pre> <p>Then, we will add all our sensor frames on extrinsic_calibration_manager as child frames:</p> <pre><code>   &lt;!-- extrinsic_calibration_manager --&gt;\n-  &lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\"&gt;\n-    &lt;param name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n-    &lt;param name=\"child_frames\" value=\"\n-    [velodyne_top_base_link,\n-    livox_front_left_base_link,\n-    livox_front_center_base_link,\n-    livox_front_right_base_link]\"/&gt;\n-  &lt;/node&gt;\n+   &lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\"&gt;\n+     &lt;param name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+     &lt;!-- add your sensor frames here --&gt;\n+     &lt;param name=\"child_frames\" value=\"\n+     [&lt;YOUE_SENSOR_BASE_LINK&gt;,\n+     YOUE_SENSOR_BASE_LINK,\n+     YOUE_SENSOR_BASE_LINK,\n+     YOUE_SENSOR_BASE_LINK\n+     ...]\"/&gt;\n+   &lt;/node&gt;\n</code></pre> <p>For tutorial_vehicle there are four sensors (two lidar, one camera, one gnss/ins), so it will be like this:</p> i.e extrinsic_calibration_manager child_frames for tutorial_vehicle <pre><code>+   &lt;!-- extrinsic_calibration_manager --&gt;\n+   &lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\"&gt;\n+     &lt;param name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+     &lt;!-- add your sensor frames here --&gt;\n+     &lt;param name=\"child_frames\" value=\"\n+     [rs_helios_top_base_link,\n+     rs_bpearl_front_base_link,\n+     camera0/camera_link,\n+     gnss_link]\"/&gt;\n+   &lt;/node&gt;\n</code></pre> <p>Lastly, we will launch a manual calibrator each frame for our sensors, please update namespace (ns) and child_frame argument on calibrator.launch.xml launch file argument:</p> <pre><code>-  &lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n-    &lt;arg name=\"ns\" value=\"$(var parent_frame)/velodyne_top_base_link\"/&gt;\n-    &lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n-    &lt;arg name=\"child_frame\" value=\"velodyne_top_base_link\"/&gt;\n-  &lt;/include&gt;\n+  &lt;!-- extrinsic_manual_calibrator --&gt;\n+  &lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n+    &lt;arg name=\"ns\" value=\"$(var parent_frame)/&lt;YOUR_SENSOR_BASE_LINK&gt;\"/&gt;\n+    &lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+    &lt;arg name=\"child_frame\" value=\"&lt;YOUR_SENSOR_BASE_LINK&gt;\"\"/&gt;\n+  &lt;/include&gt;\n+\n+  ...\n+  ...\n+  ...\n+  ...\n+  ...\n+\n</code></pre> i.e., calibrator.launch.xml for each tutorial_vehicle's sensor kit <pre><code>+  &lt;!-- extrinsic_manual_calibrator --&gt;\n+  &lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n+    &lt;arg name=\"ns\" value=\"$(var parent_frame)/rs_helios_top_base_link\"/&gt;\n+    &lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+    &lt;arg name=\"child_frame\" value=\"rs_helios_top_base_link\"/&gt;\n+  &lt;/include&gt;\n+\n+  &lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n+    &lt;arg name=\"ns\" value=\"$(var parent_frame)/rs_bpearl_front_base_link\"/&gt;\n+    &lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+    &lt;arg name=\"child_frame\" value=\"rs_bpearl_front_base_link\"/&gt;\n+  &lt;/include&gt;\n+\n+  &lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n+    &lt;arg name=\"ns\" value=\"$(var parent_frame)/camera0/camera_link\"/&gt;\n+    &lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+    &lt;arg name=\"child_frame\" value=\"camera0/camera_link\"/&gt;\n+  &lt;/include&gt;\n+\n+  &lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n+    &lt;arg name=\"ns\" value=\"$(var parent_frame)/gnss_link\"/&gt;\n+    &lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+    &lt;arg name=\"child_frame\" value=\"gnss_link\"/&gt;\n+  &lt;/include&gt;\n+ &lt;/launch&gt;\n</code></pre> <p>The final version of the manual_sensor_kit.launch.xml for tutorial_vehicle should be like this:</p> Sample <code>manual_sensor_kit.launch.xml</code> for tutorial_vehicle <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n&lt;arg name=\"vehicle_id\" default=\"tutorial_vehicle\"/&gt; &lt;!-- You can update with your own vehicle_id --&gt;\n\n&lt;let name=\"sensor_model\" value=\"tutorial_vehicle_sensor_kit\"/&gt; &lt;!-- You can update with your own sensor model --&gt;\n&lt;let name=\"parent_frame\" value=\"sensor_kit_base_link\"/&gt;\n\n&lt;!-- extrinsic_calibration_client --&gt;\n&lt;arg name=\"src_yaml\" default=\"$(find-pkg-share individual_params)/config/$(var vehicle_id)/$(var sensor_model)/sensor_kit_calibration.yaml\"/&gt;\n&lt;arg name=\"dst_yaml\" default=\"$(env HOME)/sensor_kit_calibration.yaml\"/&gt;\n\n&lt;node pkg=\"extrinsic_calibration_client\" exec=\"extrinsic_calibration_client\" name=\"extrinsic_calibration_client\" output=\"screen\"&gt;\n&lt;param name=\"src_path\" value=\"$(var src_yaml)\"/&gt;\n&lt;param name=\"dst_path\" value=\"$(var dst_yaml)\"/&gt;\n&lt;/node&gt;\n\n&lt;!-- extrinsic_calibration_manager --&gt;\n&lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\"&gt;\n&lt;param name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;!-- Please Update with your own sensor frames --&gt;\n&lt;param name=\"child_frames\" value=\"\n    [rs_helios_top_base_link,\n    rs_bpearl_front_base_link,\n    camera0/camera_link,\n    gnss_link]\"/&gt;\n&lt;/node&gt;\n\n&lt;!-- extrinsic_manual_calibrator --&gt;\n&lt;!-- Please create a launch for all sensors that you used. --&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n&lt;arg name=\"ns\" value=\"$(var parent_frame)/rs_helios_top_base_link\"/&gt;\n&lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;arg name=\"child_frame\" value=\"rs_helios_top_base_link\"/&gt;\n&lt;/include&gt;\n\n&lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n&lt;arg name=\"ns\" value=\"$(var parent_frame)/rs_bpearl_front_base_link\"/&gt;\n&lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;arg name=\"child_frame\" value=\"rs_bpearl_front_base_link\"/&gt;\n&lt;/include&gt;\n\n&lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n&lt;arg name=\"ns\" value=\"$(var parent_frame)/camera0/camera_link\"/&gt;\n&lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;arg name=\"child_frame\" value=\"camera0/camera_link\"/&gt;\n&lt;/include&gt;\n\n&lt;include file=\"$(find-pkg-share extrinsic_manual_calibrator)/launch/calibrator.launch.xml\"&gt;\n&lt;arg name=\"ns\" value=\"$(var parent_frame)/gnss_link\"/&gt;\n&lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;arg name=\"child_frame\" value=\"gnss_link\"/&gt;\n&lt;/include&gt;\n&lt;/launch&gt;\n</code></pre> <p>You can update <code>manual_sensors.launch.xml</code> file according to your modified sensors_calibration.yaml file. Since we will not be calibrating the sensor directly with respect to the base_link in tutorial_vehicle, we will not change this file.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/extrinsic-manual-calibration/#calibrating-sensors-with-extrinsic-manual-calibrator","title":"Calibrating sensors with extrinsic manual calibrator","text":"<p>After the completion of manual.launch.xml and manual_sensor_kit.launch xml file for extrinsic_calibration_manager package, we need to build package:</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-select extrinsic_calibration_manager\n</code></pre> <p>So, we are ready to launch and use manual calibrator:</p> <pre><code>ros2 launch extrinsic_calibration_manager calibration.launch.xml mode:=manual sensor_model:=&lt;OWN-SENSOR-KIT&gt; vehicle_model:=&lt;OWN-VEHICLE-MODEL&gt; vehicle_id:=&lt;VEHICLE-ID&gt;\n</code></pre> <p>For tutorial vehicle:</p> <pre><code>ros2 launch extrinsic_calibration_manager calibration.launch.xml mode:=manual sensor_model:=tutorial_vehicle_sensor_kit vehicle_model:=tutorial_vehicle vehicle_id:=tutorial_vehicle\n</code></pre> <p>Then play ROS 2 bag file:</p> <pre><code>ros2 bag play &lt;rosbag_path&gt; --clock -l -r 0.2 \\\n--remap /tf:=/null/tf /tf_static:=/null/tf_static # if tf is recorded\n</code></pre> <p>You will show to a manual rqt_reconfigure window, we will update calibrations by hand according to the rviz2 results of sensors.</p> <ul> <li>Press <code>Refresh</code> button then press <code>Expand All</code> button. The frames on tutorial_vehicle should like this:</li> </ul> <p></p> <ul> <li>Please write the target frame name in Filter area (i.e., front, helios etc.) and select tunable_static_tf_broadcaster_node, then you can adjust <code>tf_x, tf_y, tf_z, tf_roll, tf_pitch and tf_yaw</code> values over RQT panel.</li> <li>If manual adjusting is finished, you can save your calibration results via this command:</li> </ul> <pre><code>ros2 topic pub /done std_msgs/Bool \"data: true\"\n</code></pre> <ul> <li>Then you can check the output file in $HOME/*.yaml.</li> </ul> <p>Warning</p> <p>The initial calibration process can be important before the using other calibrations. We will look into the lidar-lidar calibration and camera-lidar calibration. At this point, there is hard to calibrate two sensors with exactly same frame, so you should find approximately (it not must be perfect) calibration pairs between sensors.</p> <p>Here is the video for demonstrating a manual calibration process on tutorial_vehicle: </p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/ground-lidar-calibration/","title":"Ground-Lidar calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/ground-lidar-calibration/#ground-lidar-calibration","title":"Ground-Lidar calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/ground-lidar-calibration/#overview","title":"Overview","text":"<p>Ground-Lidar Calibration method operates under the assumption that the area surrounding the vehicle can be represented as a flat surface. So, you must find as wide and flat a surface as possible for ROS 2 bag recording. The method then modifies the calibration transformation in a way that aligns the points corresponding to the ground within the point cloud with the XY plane of the base_link. This means that only the z, roll, and pitch values of the tf undergo calibration, while the remaining x, y, and yaw values must be calibrated using other methods, such as manual adjustment or mapping-based lidar-lidar calibration.</p> <p>You need to apply this calibration method to each lidar separately, so our bag should contain all lidars to be calibrated.</p> <p>We need a sample bag file for the ground-lidar calibration process which includes raw lidar topics.</p> ROS 2 Bag example of our ground-based calibration process for tutorial_vehicle <pre><code>Files:             rosbag2_2023_09_05-11_23_50_0.db3\nBag size:          3.8 GiB\nStorage id:        sqlite3\nDuration:          112.702s\nStart:             Sep  5 2023 11:23:51.105 (1693902231.105)\nEnd:               Sep  5 2023 11:25:43.808 (1693902343.808)\nMessages:          2256\nTopic information: Topic: /sensing/lidar/front/pointcloud_raw | Type: sensor_msgs/msg/PointCloud2 | Count: 1128 | Serialization Format: cdr\n                   Topic: /sensing/lidar/top/pointcloud_raw | Type: sensor_msgs/msg/PointCloud2 | Count: 1128 | Serialization Format: cdr\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/ground-lidar-calibration/#ground-lidar-calibration_1","title":"Ground-lidar calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/ground-lidar-calibration/#creating-launch-files","title":"Creating launch files","text":"<p>We will start with creating launch file four our own vehicle like the previous sections process:</p> <pre><code>cd &lt;YOUR-OWN-AUTOWARE-DIRECTORY&gt;/src/autoware/calibration_tools/sensor\ncd extrinsic_calibration_manager/launch\ncd &lt;YOUR-OWN-SENSOR-KIT-NAME&gt; # i.e. for our guide, it will ve cd tutorial_vehicle_sensor_kit which is created in manual calibration\ntouch ground_plane.launch.xml ground_plane_sensor_kit.launch.xml\n</code></pre> <p>We will be modifying these <code>ground_plane.launch.xml</code> and <code>ground_plane_sensor_kit.launch.xml</code> by using TIER IV's sample sensor kit aip_x1. So, you should copy the contents of these two files from aip_x1 to your created files.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/ground-lidar-calibration/#modifying-launch-files-according-to-your-sensor-kit","title":"Modifying launch files according to your sensor kit","text":"<p>(Optionally) Let's start with adding vehicle_id and sensor model names: (Values are not important. These parameters will be overridden by launch arguments)</p> <pre><code>  &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n\n  &lt;let name=\"sensor_model\" value=\"aip_x1\"/&gt;\n+ &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n+ &lt;launch&gt;\n-   &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n+   &lt;arg name=\"vehicle_id\" default=\"&lt;YOUR_VEHICLE_ID&gt;\"/&gt;\n+\n-   &lt;arg name=\"sensor_model\" default=\"aip_x1\"/&gt;\n+   &lt;let name=\"sensor_model\" value=\"&lt;YOUR_SENSOR_KIT_NAME&gt;\"/&gt;\n</code></pre> <p>The final version of the file (ground_plane.launch.xml) for tutorial_vehicle should be like this:</p> Sample ground_plane.launch.xml file for tutorial vehicle <pre><code>&lt;launch&gt;\n&lt;arg name=\"vehicle_id\" default=\"tutorial_vehicle\"/&gt;\n&lt;let name=\"sensor_model\" value=\"tutorial_vehicle_sensor_kit\"/&gt;\n\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"sensor_kit\"/&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_calibration_manager)/launch/$(var sensor_model)/ground_plane_sensor_kit.launch.xml\"&gt;\n&lt;arg name=\"vehicle_id\" value=\"$(var vehicle_id)\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n&lt;/launch&gt;\n</code></pre> <p>After the completing of ground_plane.launch.xml file, we will be ready to implement ground_plane_sensor_kit.launch.xml for the own sensor model.</p> <p>Optionally, (don't forget, these parameters will be overridden by launch arguments.) you can modify sensor_kit and vehicle_id as <code>ground_plane.launch.xml</code>over this xml snippet: (You can change rviz_profile path after the saving rviz config as video which included at the end of the page)</p> <pre><code>+ &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n+ &lt;launch&gt;\n-   &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n+   &lt;arg name=\"vehicle_id\" default=\"&lt;YOUR_VEHICLE_ID&gt;\"/&gt;\n-   &lt;arg name=\"sensor_model\" default=\"aip_x1\"/&gt;\n+   &lt;let name=\"sensor_model\" value=\"&lt;YOUR_SENSOR_KIT_NAME&gt;\"/&gt;\n   &lt;let name=\"base_frame\" value=\"base_link\"/&gt;\n    &lt;let name=\"parent_frame\" value=\"sensor_kit_base_link\"/&gt;\n</code></pre> <p>If you save rviz config file before for the ground-lidar calibration process:</p> <pre><code>- &lt;let name=\"rviz_profile\" value=\"$(find-pkg-share extrinsic_ground_plane_calibrator)/rviz/velodyne_top.rviz\"/&gt;\n+ &lt;let name=\"rviz_profile\" value=\"$(find-pkg-share extrinsic_ground_plane_calibrator)/rviz/&lt;YOUR-RVIZ-CONFIG&gt;.rviz\"/&gt;\n</code></pre> <p>Then, we will add all our sensor frames on extrinsic_calibration_manager as child frames:</p> <pre><code>    &lt;!-- extrinsic_calibration_manager --&gt;\n-   &lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\"&gt;\n-     &lt;param name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n-     &lt;param name=\"child_frames\" value=\"\n-     [velodyne_top_base_link,\n-     livox_front_left_base_link,\n-     livox_front_center_base_link,\n-     livox_front_right_base_link]\"/&gt;\n-   &lt;/node&gt;\n+   &lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\"&gt;\n+     &lt;param name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+     &lt;!-- add your sensor frames here --&gt;\n+     &lt;param name=\"child_frames\" value=\"\n+     [&lt;YOUE_SENSOR_BASE_LINK&gt;,\n+     YOUE_SENSOR_BASE_LINK,\n+     YOUE_SENSOR_BASE_LINK,\n+     YOUE_SENSOR_BASE_LINK\n+     ...]\"/&gt;\n+   &lt;/node&gt;\n</code></pre> <p>For tutorial_vehicle there are two lidar sensors (rs_helios_top and rs_bpearl_front), so it will be like this:</p> i.e extrinsic_calibration_manager child_frames for tutorial_vehicle <pre><code>+   &lt;!-- extrinsic_calibration_manager --&gt;\n+   &lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\"&gt;\n+     &lt;param name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+     &lt;!-- add your sensor frames here --&gt;\n+     &lt;param name=\"child_frames\" value=\"\n+     [rs_helios_top_base_link,\n+     rs_bpearl_front_base_link]\"/&gt;\n+   &lt;/node&gt;\n</code></pre> <p>After that we will add our lidar sensor configurations on ground-based calibrator, to do that we will add these lines our <code>ground_plane_sensor_kit.launch.xml</code> file:</p> <pre><code>-  &lt;group&gt;\n-    &lt;include file=\"$(find-pkg-share extrinsic_ground_plane_calibrator)/launch/calibrator.launch.xml\"&gt;\n-      &lt;arg name=\"ns\" value=\"$(var parent_frame)/velodyne_top_base_link\"/&gt;\n-      &lt;arg name=\"base_frame\" value=\"$(var base_frame)\"/&gt;\n-      &lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n-      &lt;arg name=\"child_frame\" value=\"velodyne_top_base_link\"/&gt;\n-      &lt;arg name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\"/&gt;\n-    &lt;/include&gt;\n-  &lt;/group&gt;\n+  &lt;group&gt;\n+   &lt;include file=\"$(find-pkg-share extrinsic_ground_plane_calibrator)/launch/calibrator.launch.xml\"&gt;\n+     &lt;arg name=\"ns\" value=\"$(var parent_frame)/YOUR_SENSOR_BASE_LINK\"/&gt;\n+     &lt;arg name=\"base_frame\" value=\"$(var base_frame)\"/&gt;\n+     &lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n+     &lt;arg name=\"child_frame\" value=\"YOUR_SENSOR_BASE_LINK\"/&gt;\n+     &lt;arg name=\"pointcloud_topic\" value=\"&lt;YOUR_SENSOR_TOPIC_NAME&gt;\"/&gt;\n+   &lt;/include&gt;\n+ &lt;/group&gt;\n+  ...\n+  ...\n+  ...\n+  ...\n+  ...\n+\n</code></pre> i.e., launch calibrator.launch.xml for each tutorial_vehicle's lidar <pre><code>  &lt;!-- rs_helios_top_base_link: extrinsic_ground_plane_calibrator --&gt;\n&lt;group&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_ground_plane_calibrator)/launch/calibrator.launch.xml\"&gt;\n&lt;arg name=\"ns\" value=\"$(var parent_frame)/rs_helios_top_base_link\"/&gt;\n&lt;arg name=\"base_frame\" value=\"$(var base_frame)\"/&gt;\n&lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;arg name=\"child_frame\" value=\"rs_helios_top_base_link\"/&gt;\n&lt;arg name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n\n&lt;!-- rs_bpearl_front_base_link: extrinsic_ground_plane_calibrator --&gt;\n&lt;group&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_ground_plane_calibrator)/launch/calibrator.launch.xml\"&gt;\n&lt;arg name=\"ns\" value=\"$(var parent_frame)/rs_bpearl_front_base_link\"/&gt;\n&lt;arg name=\"base_frame\" value=\"$(var base_frame)\"/&gt;\n&lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;arg name=\"child_frame\" value=\"rs_bpearl_front_base_link\"/&gt;\n&lt;arg name=\"pointcloud_topic\" value=\"/sensing/lidar/front/pointcloud_raw\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n\n&lt;node pkg=\"rviz2\" exec=\"rviz2\" name=\"rviz2\" output=\"screen\" args=\"-d $(var rviz_profile)\" if=\"$(var calibration_rviz)\"/&gt;\n&lt;/launch&gt;\n</code></pre> <p>The ground_plane_sensor_kit.launch.xml launch file for tutorial_vehicle should be this:</p> Sample <code>ground_plane_sensor_kit.launch.xml</code> for tutorial_vehicle <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n&lt;arg name=\"vehicle_id\" default=\"tutorial_vehicle\"/&gt;\n&lt;let name=\"sensor_model\" value=\"tutorial_vehicle_sensor_kit\"/&gt;\n&lt;let name=\"base_frame\" value=\"base_link\"/&gt;\n&lt;let name=\"parent_frame\" value=\"sensor_kit_base_link\"/&gt;\n&lt;let name=\"rviz_profile\" value=\"$(find-pkg-share extrinsic_ground_plane_calibrator)/rviz/velodyne_top.rviz\"/&gt;\n&lt;arg name=\"calibration_rviz\" default=\"true\"/&gt;\n\n&lt;!-- extrinsic_calibration_client --&gt;\n&lt;arg name=\"src_yaml\" default=\"$(find-pkg-share individual_params)/config/$(var vehicle_id)/$(var sensor_model)/sensor_kit_calibration.yaml\"/&gt;\n&lt;arg name=\"dst_yaml\" default=\"$(env HOME)/sensor_kit_calibration.yaml\"/&gt;\n\n&lt;node pkg=\"extrinsic_calibration_client\" exec=\"extrinsic_calibration_client\" name=\"extrinsic_calibration_client\" output=\"screen\"&gt;\n&lt;param name=\"src_path\" value=\"$(var src_yaml)\"/&gt;\n&lt;param name=\"dst_path\" value=\"$(var dst_yaml)\"/&gt;\n&lt;/node&gt;\n\n&lt;!-- extrinsic_calibration_manager --&gt;\n&lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\"&gt;\n&lt;param name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;param name=\"child_frames\" value=\"\n    [rs_helios_top_base_link,\n    rs_bpearl_front_base_link]\"/&gt;\n&lt;/node&gt;\n\n&lt;!-- rs_helios_top_base_link: extrinsic_ground_plane_calibrator --&gt;\n&lt;group&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_ground_plane_calibrator)/launch/calibrator.launch.xml\"&gt;\n&lt;arg name=\"ns\" value=\"$(var parent_frame)/rs_helios_top_base_link\"/&gt;\n&lt;arg name=\"base_frame\" value=\"$(var base_frame)\"/&gt;\n&lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;arg name=\"child_frame\" value=\"rs_helios_top_base_link\"/&gt;\n&lt;arg name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n\n&lt;!-- rs_bpearl_front_base_link: extrinsic_ground_plane_calibrator --&gt;\n&lt;group&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_ground_plane_calibrator)/launch/calibrator.launch.xml\"&gt;\n&lt;arg name=\"ns\" value=\"$(var parent_frame)/rs_bpearl_front_base_link\"/&gt;\n&lt;arg name=\"base_frame\" value=\"$(var base_frame)\"/&gt;\n&lt;arg name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;arg name=\"child_frame\" value=\"rs_bpearl_front_base_link\"/&gt;\n&lt;arg name=\"pointcloud_topic\" value=\"/sensing/lidar/front/pointcloud_raw\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n\n&lt;node pkg=\"rviz2\" exec=\"rviz2\" name=\"rviz2\" output=\"screen\" args=\"-d $(var rviz_profile)\" if=\"$(var calibration_rviz)\"/&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/ground-lidar-calibration/#ground-plane-lidar-calibration-process-with-extrinsic-ground-plane-calibrator","title":"Ground plane-lidar calibration process with extrinsic ground-plane calibrator","text":"<p>After completing mapping_based.launch.xml and mapping_based_sensor_kit.launch.xml launch files for own sensor kit; now we are ready to calibrate our lidars. First of all, we need to build extrinsic_calibration_manager package:</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-select extrinsic_calibration_manager\n</code></pre> <p>So, we are ready to launch and use ground-based lidar-ground calibrator.</p> <pre><code>ros2 launch extrinsic_calibration_manager calibration.launch.xml mode:=ground_plane sensor_model:=&lt;OWN-SENSOR-KIT&gt; vehicle_model:=&lt;OWN-VEHICLE-MODEL&gt; vehicle_id:=&lt;VEHICLE-ID&gt;\n</code></pre> <p>For tutorial vehicle:</p> <pre><code>ros2 launch extrinsic_calibration_manager calibration.launch.xml mode:=ground_plane sensor_model:=tutorial_vehicle_sensor_kit vehicle_model:=tutorial_vehicle vehicle_id:=tutorial_vehicle\n</code></pre> <p>You will show the rviz2 screen with several configurations, you need to update it with your sensor information topics, sensor_frames and pointcloud_inlier_topics like the video, which included an end of the document. Also, you can save the rviz2 config on rviz directory, so you can use it later with modifying <code>mapping_based_sensor_kit.launch.xml</code>.</p> <pre><code>extrinsic_mapping_based_calibrator/\n   \u2514\u2500 rviz/\n+        \u2514\u2500 tutorial_vehicle_sensor_kit.rviz\n</code></pre> <p>Then play ROS 2 bag file, the calibration process will be started:</p> <pre><code>ros2 bag play &lt;rosbag_path&gt; --clock -l -r 0.2 \\\n--remap /tf:=/null/tf /tf_static:=/null/tf_static # if tf is recorded\n</code></pre> <p>Since the calibration process is done automatically, you can see the sensor_kit_calibration.yaml in your $HOME directory after the calibration process is complete.</p> Before Ground Plane - Lidar Calibration After Ground Plane - Lidar Calibration <p>Here is the video for demonstrating the ground plane - lidar calibration process on tutorial_vehicle: </p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/intrinsic-camera-calibration/","title":"Intrinsic camera calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/intrinsic-camera-calibration/#intrinsic-camera-calibration","title":"Intrinsic camera calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/intrinsic-camera-calibration/#overview","title":"Overview","text":"<p>Intrinsic camera calibration is the process of determining the internal parameters of a camera which will be used when projecting 3D information into images. These parameters include focal length, optical center, and lens distortion coefficients. In order to perform camera Intrinsic calibration, we will use TIER IV's Intrinsic Camera Calibrator tool. First of all, we need a calibration board which can be dot, chess or apriltag grid board. In this tutorial, we will use this 7x7 chess board consisting of 7 cm squares:</p> <p> </p>      Our 7x7 calibration chess board for this tutorial section.    <p>Here are some calibration board samples from Intrinsic Camera Calibrator page:</p> <ul> <li>Chess boards (6x8 example)</li> <li>Circle dot boards (6x8 example)</li> <li>Apriltag grid board (3x4 example)</li> </ul> <p>If you want to use bag file for a calibration process, the bag file must include <code>image_raw</code> topic of your camera sensor, but you can perform calibration with real time. (recommended)</p> ROS 2 Bag example for intrinsic camera calibration process <pre><code>Files:             rosbag2_2023_09_18-16_19_08_0.db3\nBag size:          12.0 GiB\nStorage id:        sqlite3\nDuration:          135.968s\nStart:             Sep 18 2023 16:19:08.966 (1695043148.966)\nEnd:               Sep 18 2023 16:21:24.934 (1695043284.934)\nMessages:          4122\nTopic information: Topic: /sensing/camera/camera0/image_raw | Type: sensor_msgs/msg/Image | Count: 2061 | Serialization Format: cdr\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/intrinsic-camera-calibration/#intrinsic-camera-calibration_1","title":"Intrinsic camera calibration","text":"<p>Unlike other calibration packages in our tutorials, this package does not need to create an initialization file. So we can start with launching intrinsic calibrator package.</p> <pre><code>cd &lt;YOUR-OWN-AUTOWARE-DIRECTORY&gt;\nsource install/setup.bash\n</code></pre> <p>After that, we will launch intrinsic calibrator:</p> <pre><code>ros2 launch intrinsic_camera_calibrator calibrator.launch.xml\n</code></pre> <p>Then, initial configuration and camera intrinsic calibration panels will show up. We set initial configurations for our calibration.</p> <p> </p>      Initial configuration panel    <p>We set our image source (it can be \"ROS topic\", \"ROS bag\" or \"Image files\") from the source options section. We will calibrate our camera with \"ROS topic\" source. After selecting an image source from this panel, we need to configure \"Board options\" as well. The calibration board can be <code>Chess board, Dot board or Apriltag</code>. Also, we need to select board parameters, to do that, click the \"Board parameters\" button and set <code>row, column, and cell</code> size.</p> <p>After the setting of image source and board parameters, we are ready for the calibration process. Please click the start button, you will see <code>Topic configuration</code> panel. Please select the appropriate camera raw topic for the calibration process.</p> <p> </p>      Topic configuration panel    <p>Then you are ready to calibration. Please collect data with different X-Y axis, sizes and skews. You can see your collected data statistics with the clicking view data collection statistics. For more information, please refer to Intrinsic Camera Calibrator page.</p> <p> </p>      Intrinsic calibrator interface    <p>After the data collection is completed, you can click the \"Calibrate\" button to perform the calibration process. After the calibration is completed, you will see data visualization for the calibration result statistics. You can observe your calibration results with changing \"Image view type \"Source unrectified\" to \"Source rectified\". If your calibration is successful (there should be no distortion in the rectified image), you can save your calibration results with \"Save\" button. The output will be named as <code>&lt;YOUR-CAMERA-NAME&gt;_info.yaml</code>. So, you use this file with your camera driver directly.</p> <p>Here is the video for demonstrating the intrinsic camera calibration process on tutorial_vehicle: </p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-camera-calibration/","title":"Lidar-Camera calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-camera-calibration/#lidar-camera-calibration","title":"Lidar-Camera calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-camera-calibration/#overview","title":"Overview","text":"<p>Lidar-camera calibration is a crucial process in the field of autonomous driving and robotics, where both lidar sensors and cameras are used for perception. The goal of calibration is to accurately align the data from these different sensors in order to create a comprehensive and coherent representation of the environment by projecting lidar point onto camera image. At this tutorial, we will explain TIER IV's interactive camera calibrator. Also, If you have aruco marker boards for calibration, another Lidar-Camera calibration method is included in TIER IV's CalibrationTools repository.</p> <p>Warning</p> <p>You need to apply intrinsic calibration before starting lidar-camera extrinsic calibration process. Also, please obtain the initial calibration results from the Manual Calibration section. This is crucial for obtaining accurate results from this tool. We will utilize the initial calibration parameters that were calculated in the previous step of this tutorial. To apply these initial values in the calibration tools, please update your sensor calibration files within the individual parameter package.</p> <p>Your bag file must include calibration lidar topic and camera topics. Camera topics can be compressed or raw topics, but remember we will update interactive calibrator launch argument <code>use_compressed</code> according to the topic type.</p> ROS 2 Bag example of our calibration process (there is only one camera mounted) If you have multiple cameras, please add camera_info and image topics as well. <pre><code>Files:             rosbag2_2023_09_12-13_57_03_0.db3\nBag size:          5.8 GiB\nStorage id:        sqlite3\nDuration:          51.419s\nStart:             Sep 12 2023 13:57:03.691 (1694516223.691)\nEnd:               Sep 12 2023 13:57:55.110 (1694516275.110)\nMessages:          2590\nTopic information: Topic: /sensing/lidar/top/pointcloud_raw | Type: sensor_msgs/msg/PointCloud2 | Count: 515 | Serialization Format: cdr\nTopic: /sensing/camera/camera0/image_raw | Type: sensor_msgs/msg/Image | Count: 780 | Serialization Format: cdr\nTopic: /sensing/camera/camera0/camera_info | Type: sensor_msgs/msg/CameraInfo | Count: 780 | Serialization Format: cdr\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-camera-calibration/#lidar-camera-calibration_1","title":"Lidar-Camera calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-camera-calibration/#creating-launch-files","title":"Creating launch files","text":"<p>We start with creating launch file four our vehicle like \"Extrinsic Manual Calibration\" process:</p> <pre><code>cd &lt;YOUR-OWN-AUTOWARE-DIRECTORY&gt;/src/autoware/calibration_tools/sensor\ncd extrinsic_calibration_manager/launch\ncd &lt;YOUR-OWN-SENSOR-KIT-NAME&gt; # i.e. for our guide, it will ve cd tutorial_vehicle_sensor_kit which is created in manual calibration\ntouch interactive.launch.xml interactive_sensor_kit.launch.xml\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-camera-calibration/#modifying-launch-files-according-to-your-sensor-kit","title":"Modifying launch files according to your sensor kit","text":"<p>We will be modifying these <code>interactive.launch.xml</code> and <code>interactive_sensor_kit.launch.xml</code> by using TIER IV's sample sensor kit aip_xx1. So, you should copy the contents of these two files from aip_xx1 to your created files.</p> <p>Then we will continue with adding vehicle_id and sensor model names to the <code>interactive.launch.xml</code>. (Optionally, values are not important. These parameters will be overridden by launch arguments)</p> <pre><code>  &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n\n  &lt;let name=\"sensor_model\" value=\"aip_x1\"/&gt;\n  &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n  &lt;launch&gt;\n-   &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n+   &lt;arg name=\"vehicle_id\" default=\"&lt;YOUR_VEHICLE_ID&gt;\"/&gt;\n+\n-   &lt;arg name=\"sensor_model\" default=\"aip_x1\"/&gt;\n+   &lt;let name=\"sensor_model\" value=\"&lt;YOUR_SENSOR_KIT_NAME&gt;\"/&gt;\n</code></pre> <p>If you want to use concatenated pointcloud as an input cloud (the calibration process will initiate the logging simulator, resulting in the construction of the lidar pipeline and the appearance of the concatenated point cloud), you must set <code>use_concatenated_pointcloud</code> value as <code>true</code>.</p> <pre><code>-   &lt;arg name=\"use_concatenated_pointcloud\" default=\"false\"/&gt;\n+   &lt;arg name=\"use_concatenated_pointcloud\" default=\"true\"/&gt;\n</code></pre> <p>The final version of the file (interactive.launch.xml) for tutorial_vehicle should be like this:</p> Sample interactive.launch.xml file for tutorial vehicle <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n&lt;arg name=\"vehicle_id\" default=\"tutorial_vehicle\"/&gt;\n&lt;let name=\"sensor_model\" value=\"tutorial_vehicle_sensor_kit\"/&gt;\n&lt;arg name=\"camera_name\"/&gt;\n&lt;arg name=\"rviz\" default=\"false\"/&gt;\n&lt;arg name=\"use_concatenated_pointcloud\" default=\"true\"/&gt;\n\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"sensor_kit\"/&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_calibration_manager)/launch/$(var sensor_model)/interactive_sensor_kit.launch.xml\" if=\"$(var rviz)\"&gt;\n&lt;arg name=\"vehicle_id\" value=\"$(var vehicle_id)\"/&gt;\n&lt;arg name=\"camera_name\" value=\"$(var camera_name)\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n\n&lt;!-- You can change the config file path --&gt;\n&lt;node pkg=\"rviz2\" exec=\"rviz2\" name=\"rviz2\" output=\"screen\" args=\"\n-d $(find-pkg-share extrinsic_calibration_manager)/config/x2/extrinsic_interactive_calibrator.rviz\" if=\"$(var rviz)\"/&gt;\n&lt;/launch&gt;\n</code></pre> <p>After the completing of interactive.launch.xml file, we will be ready to implement interactive_sensor_kit.launch.xml for the own sensor model.</p> <p>Optionally, (don't forget, these parameters will be overridden by launch arguments) you can modify sensor_kit and vehicle_id as <code>interactive.launch.xml</code>over this xml snippet. We will set parent_frame for calibration as `sensor_kit_base_link``:</p> <p>The default camera input topic of interactive calibrator is compressed image. If you want to use raw image instead of compressed image, you need to update image_topic variable for your camera sensor topic.</p> <pre><code>    ...\n-   &lt;let name=\"image_topic\" value=\"/sensing/camera/$(var camera_name)/image_raw\"/&gt;\n+   &lt;let name=\"image_topic\" value=\"/sensing/camera/$(var camera_name)/image_compressed\"/&gt;\n   ...\n</code></pre> <p>After updating your topic name, you need to add the use_compressed parameter (default value is <code>true</code>) to the interactive_calibrator node with a value of <code>false</code>.</p> <pre><code>   ...\n   &lt;node pkg=\"extrinsic_interactive_calibrator\" exec=\"interactive_calibrator\" name=\"interactive_calibrator\" output=\"screen\"&gt;\n     &lt;remap from=\"pointcloud\" to=\"$(var pointcloud_topic)\"/&gt;\n     &lt;remap from=\"image\" to=\"$(var image_compressed_topic)\"/&gt;\n     &lt;remap from=\"camera_info\" to=\"$(var camera_info_topic)\"/&gt;\n     &lt;remap from=\"calibration_points_input\" to=\"calibration_points\"/&gt;\n+    &lt;param name=\"use_compressed\" value=\"false\"/&gt;\n  ...\n</code></pre> <p>Then you can customize pointcloud topic for each camera. For example, if you want to calibrate camera_1 with left lidar, then you should change launch file like this:</p> <pre><code>    &lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera0' &amp;quot;)\"/&gt;\n-   &lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera1' &amp;quot;)\"/&gt;\n+   &lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/left/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera1' &amp;quot;)\"/&gt;\n   &lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera2' &amp;quot;)\"/&gt;\n    &lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera3' &amp;quot;)\"/&gt;\n    &lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera4' &amp;quot;)\"/&gt;\n    &lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera5' &amp;quot;)\"/&gt;\n    ...\n</code></pre> <p>The interactive_sensor_kit.launch.xml launch file for tutorial_vehicle should be this:</p> i.e. <code>interactive_sensor_kit.launch.xml</code> for tutorial_vehicle <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n&lt;arg name=\"vehicle_id\" default=\"tutorial_vehicle\"/&gt;\n&lt;let name=\"sensor_model\" value=\"tutorial_vehicle_sensor_kit\"/&gt;\n&lt;let name=\"parent_frame\" value=\"sensor_kit_base_link\"/&gt;\n\n&lt;!-- extrinsic_calibration_client --&gt;\n&lt;arg name=\"src_yaml\" default=\"$(find-pkg-share individual_params)/config/$(var vehicle_id)/$(var sensor_model)/sensor_kit_calibration.yaml\"/&gt;\n&lt;arg name=\"dst_yaml\" default=\"$(env HOME)/sensor_kit_calibration.yaml\"/&gt;\n\n\n&lt;arg name=\"camera_name\"/&gt;\n\n&lt;let name=\"image_topic\" value=\"/sensing/camera/$(var camera_name)/image_raw\"/&gt;\n&lt;let name=\"image_topic\" value=\"/sensing/camera/traffic_light/image_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'traffic_light_left_camera' &amp;quot;)\"/&gt;\n\n&lt;let name=\"use_compressed\" value=\"false\"/&gt;\n\n&lt;let name=\"image_compressed_topic\" value=\"/sensing/camera/$(var camera_name)/image_raw/compressed\"/&gt;\n&lt;let name=\"image_compressed_topic\" value=\"/sensing/camera/traffic_light/image_raw/compressed\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'traffic_light_left_camera' &amp;quot;)\"/&gt;\n\n&lt;let name=\"camera_info_topic\" value=\"/sensing/camera/$(var camera_name)/camera_info\"/&gt;\n&lt;let name=\"camera_info_topic\" value=\"/sensing/camera/traffic_light/camera_info\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'traffic_light_left_camera' &amp;quot;)\"/&gt;\n\n&lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera0' &amp;quot;)\"/&gt;\n&lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera1' &amp;quot;)\"/&gt;\n&lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera2' &amp;quot;)\"/&gt;\n&lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera3' &amp;quot;)\"/&gt;\n&lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera4' &amp;quot;)\"/&gt;\n&lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera5' &amp;quot;)\"/&gt;\n&lt;let name=\"pointcloud_topic\" value=\"/sensing/lidar/top/pointcloud_raw\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'traffic_light_left_camera' &amp;quot;)\"/&gt;\n\n&lt;let name=\"calibrate_sensor\" value=\"false\"/&gt;\n&lt;let name=\"calibrate_sensor\" value=\"true\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera0' &amp;quot;)\"/&gt;\n&lt;let name=\"calibrate_sensor\" value=\"true\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera1' &amp;quot;)\"/&gt;\n&lt;let name=\"calibrate_sensor\" value=\"true\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera2' &amp;quot;)\"/&gt;\n&lt;let name=\"calibrate_sensor\" value=\"true\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera3' &amp;quot;)\"/&gt;\n&lt;let name=\"calibrate_sensor\" value=\"true\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera4' &amp;quot;)\"/&gt;\n&lt;let name=\"calibrate_sensor\" value=\"true\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera5' &amp;quot;)\"/&gt;\n&lt;let name=\"calibrate_sensor\" value=\"true\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'traffic_light_left_camera' &amp;quot;)\"/&gt;\n\n&lt;let name=\"camera_frame\" value=\"\"/&gt;\n&lt;let name=\"camera_frame\" value=\"camera0/camera_link\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera0' &amp;quot;)\"/&gt;\n&lt;let name=\"camera_frame\" value=\"camera1/camera_link\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera1' &amp;quot;)\"/&gt;\n&lt;let name=\"camera_frame\" value=\"camera2/camera_link\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera2' &amp;quot;)\"/&gt;\n&lt;let name=\"camera_frame\" value=\"camera3/camera_link\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera3' &amp;quot;)\"/&gt;\n&lt;let name=\"camera_frame\" value=\"camera4/camera_link\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera4' &amp;quot;)\"/&gt;\n&lt;let name=\"camera_frame\" value=\"camera5/camera_link\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'camera5' &amp;quot;)\"/&gt;\n&lt;let name=\"camera_frame\" value=\"traffic_light_left_camera/camera_link\" if=\"$(eval &amp;quot;'$(var camera_name)' == 'traffic_light_left_camera' &amp;quot;)\"/&gt;\n\n&lt;node pkg=\"extrinsic_calibration_client\" exec=\"extrinsic_calibration_client\" name=\"extrinsic_calibration_client\" output=\"screen\" if=\"$(var calibrate_sensor)\"&gt;\n&lt;param name=\"src_path\" value=\"$(var src_yaml)\"/&gt;\n&lt;param name=\"dst_path\" value=\"$(var dst_yaml)\"/&gt;\n&lt;/node&gt;\n\n&lt;!-- extrinsic_calibration_manager --&gt;\n&lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\" if=\"$(var calibrate_sensor)\"&gt;\n&lt;param name=\"parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;param name=\"child_frames\" value=\"\n    [$(var camera_frame)]\"/&gt;\n&lt;/node&gt;\n\n&lt;!-- interactive calibrator --&gt;\n&lt;group if=\"$(var calibrate_sensor)\"&gt;\n&lt;push-ros-namespace namespace=\"$(var parent_frame)/$(var camera_frame)\"/&gt;\n\n&lt;node pkg=\"extrinsic_interactive_calibrator\" exec=\"interactive_calibrator\" name=\"interactive_calibrator\" output=\"screen\"&gt;\n&lt;remap from=\"pointcloud\" to=\"$(var pointcloud_topic)\"/&gt;\n&lt;remap from=\"image\" to=\"$(var image_topic)\"/&gt;\n&lt;remap from=\"camera_info\" to=\"$(var camera_info_topic)\"/&gt;\n&lt;remap from=\"calibration_points_input\" to=\"calibration_points\"/&gt;\n\n&lt;param name=\"camera_parent_frame\" value=\"$(var parent_frame)\"/&gt;\n&lt;param name=\"camera_frame\" value=\"$(var camera_frame)\"/&gt;\n&lt;param name=\"use_compressed\" value=\"$(var use_compressed)\"/&gt;\n&lt;/node&gt;\n\n&lt;include file=\"$(find-pkg-share intrinsic_camera_calibration)/launch/optimizer.launch.xml\"/&gt;\n&lt;/group&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-camera-calibration/#lidar-camera-calibration-process-with-interactive-camera-lidar-calibrator","title":"Lidar-camera calibration process with interactive camera-lidar calibrator","text":"<p>After completing interactive.launch.xml and interactive_sensor_kit.launch.xml launch files for own sensor kit; now we are ready to calibrate our lidars. First of all, we need to build extrinsic_calibration_manager package:</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-select extrinsic_calibration_manager\n</code></pre> <p>So, we are ready to launch and use interactive lidar-camera calibrator.</p> <pre><code>ros2 launch extrinsic_calibration_manager calibration.launch.xml mode:=interactive sensor_model:=&lt;OWN-SENSOR-KIT&gt; vehicle_model:=&lt;OWN-VEHICLE-MODEL&gt; vehicle_id:=&lt;VEHICLE-ID&gt; camera_name:=&lt;CALIBRATION-CAMERA&gt;\n</code></pre> <p>For tutorial vehicle:</p> <pre><code>ros2 launch extrinsic_calibration_manager calibration.launch.xml mode:=interactive sensor_model:=tutorial_vehicle_sensor_kit vehicle_model:=tutorial_vehicle vehicle_id:=tutorial_vehicle\n</code></pre> <p>Then, we need to play our bag file.</p> <pre><code>ros2 bag play &lt;rosbag_path&gt; --clock -l -r 0.2 \\\n--remap /tf:=/null/tf /tf_static:=/null/tf_static # if tf is recorded\n</code></pre> <p>You will be shown a manual interactive calibrator rqt window and Rviz2. You must add your lidar sensor point cloud to Rviz2, then we can publish points for the calibrator.</p> <p></p> <ul> <li>After that, Let's start by pressing the <code>Publish Point</code>   button and selecting points on the point cloud that are also included in the projected image.   Then,   you need to click on the image point that corresponds to the projected lidar point on the image.   You will see matched calibration points.</li> </ul> <p></p> <ul> <li>The red points indicate selected lidar points and green ones indicate selected image points.   You must match the minimum 6 points to perform calibration.   If you have a wrong match, you can remove this match by just clicking on them.   After selecting points on image and lidar, you are ready to calibrate.   If selected point match size is greater than 6, \"Calibrate extrinsic\" button will be enabled.   Click this button and change tf source <code>Initial /tf</code> to <code>Calibrator</code> to see calibration results.</li> </ul> <p></p> <p>After the completion of the calibration, you need to save your calibration results via \"Save calibration\" button. The saved format is json, so you need to update calibration params at <code>sensor_kit_calibration.yaml</code> on <code>individual_params</code> and <code>sensor_kit_description</code> packages.</p> Sample calibration output <pre><code>{\n\"header\": {\n\"stamp\": {\n\"sec\": 1694776487,\n\"nanosec\": 423288443\n},\n\"frame_id\": \"sensor_kit_base_link\"\n},\n\"child_frame_id\": \"camera0/camera_link\",\n\"transform\": {\n\"translation\": {\n\"x\": 0.054564283153017916,\n\"y\": 0.040947512210503106,\n\"z\": -0.071735410952332\n},\n\"rotation\": {\n\"x\": -0.49984112274024817,\n\"y\": 0.4905405357176159,\n\"z\": -0.5086269994990131,\n\"w\": 0.5008267267391722\n}\n},\n\"roll\": -1.5517347113946862,\n\"pitch\": -0.01711459479043047,\n\"yaw\": -1.5694590141484235\n}\n</code></pre> <p>Here is the video for demonstrating the lidar-camera calibration process on tutorial_vehicle: </p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-imu-calibration/","title":"Lidar-Imu Calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-imu-calibration/#lidar-imu-calibration","title":"Lidar-Imu Calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-imu-calibration/#overview","title":"Overview","text":"<p>Lidar-Imu calibration is important for localization and mapping algorithms which used in autonomous driving. In this tutorial, we will calibrate the lidar and imu sensors with using OA-LICalib tool which is developed by APRIL Lab at Zhejiang University in China.</p> <p>OA-LICalib is calibration method for the LiDAR-Inertial systems within a continuous-time batch optimization, where intrinsic of both sensors, the time offset between sensors and the spatial-temporal extrinsic between sensors are calibrated comprehensively without explicit hand-crafted targets.</p> <p>Warning</p> <p>This calibration tool is developed with ROS 1, and it is not compatible with ROS 2. So, we are providing a docker image which has ROS 1 and all necessary packages. In the calibration instructions, we will ask you to install docker on your system.</p> ROS 2 Bag example of our calibration process for tutorial_vehicle <pre><code>Files:             rosbag2_2023_08_18-14_42_12_0.db3\nBag size:          12.4 GiB\nStorage id:        sqlite3\nDuration:          202.140s\nStart:             Aug 18 2023 14:42:12.586 (1692358932.586)\nEnd:               Aug 18 2023 14:45:34.727 (1692359134.727)\nMessages:          22237\nTopic information: Topic: /sensing/gnss/sbg/ros/imu/data | Type: sensor_msgs/msg/Imu | Count: 20215 | Serialization Format: cdr\n                   Topic: /sensing/lidar/top/pointcloud_raw | Type: sensor_msgs/msg/PointCloud2 | Count: 2022 | Serialization Format: cdr\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-imu-calibration/#data-collection-and-preparation","title":"Data Collection and Preparation","text":"<p>For Lidar-Imu calibration, there is a need for a ROS 1 bag file which contains <code>sensor_msgs/PointCloud2</code> and <code>sensor_msgs/Imu</code> messages. To obtain good results as a result of the calibration process, you need to move the sensors in all 6 axes (x, y, z, roll, pitch, yaw) while collecting data. Therefore, holding the sensors in your hand while data collection will get better results, but you can also collect data on the vehicle. If you are collecting data on the vehicle, you should draw figures of eights and grids.</p> <p> </p>      Lidar - IMU Calibration Data Collection    <p>Moreover, the calibration accuracy is affected by the data collection environment. You should collect your data in a place that contains a lot of flat surfaces, and indoor spaces are the best locations under these conditions. However, you can also achieve good results outdoors. When collecting data, make sure to draw figures of eights and grids, capturing data from every angle.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-imu-calibration/#converting-ros-2-bag-to-ros-1-bag","title":"Converting ROS 2 Bag to ROS 1 Bag","text":"<p>If you collected your calibration data in ROS 2, you can convert it to ROS 1 bag file with the following instructions:</p> <ul> <li>Split your ROS 2 bag file if it contains non-standard message topics   (you can only select <code>sensor_msgs/PointCloud2</code> and <code>sensor_msgs/Imu</code> messages),   and convert your split ROS 2 bag file to ROS 1 bag.</li> </ul> <p>Create a yaml file with name <code>out.yaml</code> which contains your lidar and imu topics:</p> <pre><code>output_bags:\n- uri: splitted_bag\ntopics: [/your/imu/topic, /your/pointcloud/topic]\n</code></pre> <p>Split your ROS 2 bag file:</p> <pre><code>ros2 bag convert -i &lt;YOUR-ROS2-BAG-FOLDER&gt; -o out.yaml\n</code></pre> <p>Convert your split ROS 2 bag file to ROS 1 bag file:</p> <pre><code># install bag converter tool (https://gitlab.com/ternaris/rosbags)\npip3 install rosbags\n\n# convert bag\nrosbags-convert &lt;YOUR-SPLITTED-ROS2-BAG-FOLDER&gt; --dst &lt;OUTPUT-BAG-FILE&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-imu-calibration/#lidar-imu-calibration_1","title":"Lidar-Imu Calibration","text":"<p>As a first step, we need to install docker on our system. You can install docker using this link, or you can use the following commands to install docker using the Apt repository.</p> <p>Set up Docker's Apt repository:</p> <pre><code># Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl gnupg\nsudo install -m 0755 -d /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\n\n# Add the repository to Apt sources:\necho \\\n\"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n  \"$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\")\" stable\" | \\\nsudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre> <p>Install the Docker packages:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>To check if docker is installed correctly, you can run the following command:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Before finishing the installation, we need to add our user to the docker group. This will allow us to run docker commands without sudo:</p> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\n</code></pre> <p>Warning</p> <p>After running the above command, you need to logout and login again to be able to run docker commands without sudo.</p> <p>After installing docker, we are ready to run the calibration tool. As a first step, you should clone the calibration repository:</p> <pre><code>git clone https://github.com/leo-drive/OA-LICalib.git\n</code></pre> <p>Then, you need to build the docker image:</p> <pre><code>cd OA-LICalib/docker\nsudo docker build -t oalicalib .\n</code></pre> <p>After building the docker image, you need to create a container from the image:</p> <p>Warning</p> <p>You need to update REPO_PATH with the path to the cloned repository on your system.</p> <pre><code>export REPO_PATH=\"/path/to/OA-LICalib\"\ndocker run -it --env=\"DISPLAY\" --volume=\"$HOME/.Xauthority:/root/.Xauthority:rw\" --volume=\"/tmp/.X11-unix:/tmp/.X11-unix:rw\" --volume=\"$REPO_PATH:/root/catkin_oa_calib/src/OA-LICalib\" oalicalib bash\n</code></pre> <p>Before running the calibration tool, you should change some parameters from the configuration file. You can find the configuration file in the <code>OA-LICalib/config</code></p> <p>Change the following parameters in the configuration file as your topics and sensors:</p> <ul> <li>These are the lidar model options: VLP_16_packet, VLP_16_points, VLP_32E_points,   VLS_128_points, Ouster_16_points, Ouster_32_points, Ouster_64_points,   Ouster_128_points, RS_16</li> </ul> <ul> <li><code>start_time</code> and <code>end_time</code> are the interval of the rosbag that you want to use</li> </ul> <ul> <li><code>path_bag</code> is the path to the rosbag file, but you need to give the path inside   the container, not your local system. For example,   if you have a rosbag file in the <code>OA-LICalib/data</code> directory,   you need to give the path as <code>/root/calib_ws/src/OA-LICalib/data/rosbag2_2023_08_18-14_42_12_0.bag</code></li> </ul> <pre><code>topic_lidar: /sensing/lidar/top/pointcloud_raw\ntopic_imu: /sensing/gnss/sbg/ros/imu/data\n\nLidarModel: VLP_16_SIMU\n\nselected_segment:\n- {\n      start_time: 0,\n      end_time: 40,\n      path_bag: /root/calib_ws/src/OA-LICalib/data/rosbag2_2023_08_18-14_42_12_0.bag,\n}\n</code></pre> <p>After creating the container and changing parameters, you can build and run the calibration tool:</p> <pre><code>cd /root/catkin_oa_calib\ncatkin_make -DCATKIN_WHITELIST_PACKAGES=\"\"\n\nsource devel/setup.bash\nroslaunch oalicalib li_calib.launch\n</code></pre> <p>After running the calibration tool, you can track the calibration process with connecting to the container on other terminal. To connect to the container, you can run the following command:</p> <pre><code>xhost +local:docker\ndocker exec -it &lt;container_name&gt; bash\n</code></pre> <p>Warning</p> <p>You need to replace  with the name of your container. To see your container name, you can run <code>docker ps</code> command. This command's output should be something like this and you can find your container name in the last column: <pre><code>CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS         PORTS     NAMES\nadb8b559c06e   calib:v1   \"/ros_entrypoint.sh \u2026\"   6 seconds ago   Up 5 seconds             your_awesome_container_name\n</code></pre></p> <p>After connecting to the container, you can see the calibration process with running the Rviz. After running the Rviz, you need to add the following topics to the Rviz:</p> <ul> <li>/ndt_odometry/global_map</li> <li>/ndt_odometry/cur_cloud</li> </ul> <pre><code>rviz\n</code></pre> <p>If <code>/ndt_odometry/global_map</code> looks distorted, you should tune ndt parameters in the <code>OA-LICalib/config/simu.yaml</code> file.</p> <p> </p>      Lidar - IMU Calibration RViz Screen    <p>To achieve better results, you can tune the parameters in the <code>config/simu.yaml</code> file. The parameters are explained below:</p> Parameter Value ndtResolution Resolution of NDT grid structure (VoxelGridCovariance)0,5 for indoor case and 1.0 for outdoor case ndt_key_frame_downsample Resolution parameter for voxel grid downsample function map_downsample_size Resolution parameter for voxel grid downsample function knot_distance time interval plane_motion set true if you collect data from vehicle gyro_weight gyrometer sensor output\u2019s weight for trajectory estimation accel_weight accelerometer sensor output\u2019s weight for trajectory estimation lidar_weight lidar sensor output\u2019s weight for trajectory estimation"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-lidar-calibration/","title":"Lidar-Lidar calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-lidar-calibration/#lidar-lidar-calibration","title":"Lidar-Lidar calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-lidar-calibration/#overview","title":"Overview","text":"<p>In this tutorial, we will explain lidar-lidar calibration over mapping-based lidar-lidar calibration tool of TIER IV's CalibrationTools.</p> <p>Warning</p> <p>Please obtain the initial calibration results from the Manual Calibration section. This is crucial for obtaining accurate results from this tool. We will utilize the initial calibration parameters that were calculated in the previous step of this tutorial. To apply these initial values in the calibration tools, please update your sensor calibration files within the individual parameter package.</p> <p>We need a sample bag file for the lidar-lidar calibration process which includes raw lidar topics. Also, we recommend using an outlier-filtered point cloud for mapping because this point cloud includes a cropped vehicle point cloud. Therefore, vehicle points are not included in the map. When you start the bag recording, you should not move the vehicle for the first 5 seconds for better mapping performace. The following shows an example of a bag file used for this calibration:</p> ROS 2 Bag example of our calibration process for tutorial_vehicle <pre><code>Files:             rosbag2_2023_09_05-11_23_50_0.db3\nBag size:          3.8 GiB\nStorage id:        sqlite3\nDuration:          112.702s\nStart:             Sep  5 2023 11:23:51.105 (1693902231.105)\nEnd:               Sep  5 2023 11:25:43.808 (1693902343.808)\nMessages:          2256\nTopic information: Topic: /sensing/lidar/front/pointcloud_raw | Type: sensor_msgs/msg/PointCloud2 | Count: 1128 | Serialization Format: cdr\n                   Topic: /sensing/lidar/top/pointcloud | Type: sensor_msgs/msg/PointCloud2 | Count: 1128 | Serialization Format: cdr\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-lidar-calibration/#mapping-based-lidar-lidar-calibration","title":"Mapping-based lidar-lidar calibration","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-lidar-calibration/#creating-launch-files","title":"Creating launch files","text":"<p>We start with creating launch file four our vehicle like <code>Extrinsic Manual Calibration</code> process:</p> <pre><code>cd &lt;YOUR-OWN-AUTOWARE-DIRECTORY&gt;/src/autoware/calibration_tools/sensor\ncd extrinsic_calibration_manager/launch\ncd &lt;YOUR-OWN-SENSOR-KIT-NAME&gt; # i.e. for our guide, it will ve cd tutorial_vehicle_sensor_kit which is created in manual calibration\ntouch mapping_based.launch.xml mapping_based_sensor_kit.launch.xml\n</code></pre> <p>We will be modifying these <code>mapping_based.launch.xml</code> and <code>mapping_based_sensor_kit.launch.xml</code> by using TIER IV's sample sensor kit aip_x1. So, you should copy the contents of these two files from aip_x1 to your created files.</p> <p>Then we will continue with adding vehicle_id and sensor model names to the <code>mapping_based.launch.xml</code>: (Optionally, values are not important. These parameters will be overridden by launch arguments)</p> <pre><code>  &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n\n  &lt;let name=\"sensor_model\" value=\"aip_x1\"/&gt;\n+ &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n+ &lt;launch&gt;\n-   &lt;arg name=\"vehicle_id\" default=\"default\"/&gt;\n+   &lt;arg name=\"vehicle_id\" default=\"&lt;YOUR_VEHICLE_ID&gt;\"/&gt;\n+\n-   &lt;arg name=\"sensor_model\" default=\"aip_x1\"/&gt;\n+   &lt;let name=\"sensor_model\" value=\"&lt;YOUR_SENSOR_KIT_NAME&gt;\"/&gt;\n</code></pre> <p>The final version of the file (mapping_based.launch.xml) for tutorial_vehicle should be like this:</p> Sample mapping_based.launch.xml file for tutorial vehicle <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n&lt;arg name=\"vehicle_id\" default=\"tutorial_vehicle\"/&gt;\n&lt;let name=\"sensor_model\" value=\"tutorial_vehicle_sensor_kit\"/&gt;\n&lt;arg name=\"rviz\" default=\"true\"/&gt;\n\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"sensor_kit\"/&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_calibration_manager)/launch/$(var sensor_model)/mapping_based_sensor_kit.launch.xml\"&gt;\n&lt;arg name=\"vehicle_id\" value=\"$(var vehicle_id)\"/&gt;\n&lt;arg name=\"rviz\" value=\"$(var rviz)\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n&lt;/launch&gt;\n</code></pre> <p>After the completing of mapping_based.launch.xml file, we will be ready to implement mapping_based_sensor_kit.launch.xml for the own sensor model.</p> <p>Optionally, you can modify sensor_kit and vehicle_id as <code>mapping_based.launch.xml</code>over this xml snippet: (You can change rviz_profile path after the saving rviz config as video which included at the end of the page)</p> <p>We will add sensor kit frames for each lidar (except mapping lidar), we have one lidar for pairing to the main lidar sensor for tutorial vehicle, so it should be like:</p> <p>Note: The mapping lidar will be used for mapping purposes, but it will not be calibrated. We can consider this lidar as the main sensor for our hardware architecture. Therefore, other lidars will be calibrated with respect to the mapping lidar (main sensor).</p> <pre><code>+  &lt;let name=\"lidar_calibration_sensor_kit_frames\" value=\"[\n+  sensor_kit_base_link,\n+  sensor_kit_base_link,\n+  sensor_kit_base_link\n+  ...]\"/&gt;\n</code></pre> <p>If you save rviz config file before for the lidar-lidar calibration process:</p> <pre><code>- &lt;let name=\"rviz_profile\" value=\"$(find-pkg-share extrinsic_mapping_based_calibrator)/rviz/x1.rviz\"/&gt;\n+ &lt;let name=\"rviz_profile\" value=\"$(find-pkg-share extrinsic_mapping_based_calibrator)/rviz/&lt;YOUR-RVIZ-CONFIG&gt;.rviz\"/&gt;\n</code></pre> i.e., If you have one main lidar for mapping, three lidar for calibration <pre><code>+  &lt;let name=\"lidar_calibration_sensor_kit_frames\" value=\"[\n+  sensor_kit_base_link,\n+  sensor_kit_base_link,\n+  sensor_kit_base_link]\"/&gt;\n</code></pre> i.e., For tutorial_vehicle (one lidar main for mapping, one lidar for calibration) <pre><code>+  &lt;let name=\"lidar_calibration_sensor_kit_frames\" value=\"[sensor_kit_base_link]\"/&gt;\n</code></pre> <p>We will add lidar_calibration_service_names, calibration_lidar_base_frames and calibration_lidar_frames for calibrator:</p> <pre><code>-   &lt;let\n-       name=\"lidar_calibration_service_names\"\n-       value=\"[\n-       /sensor_kit/sensor_kit_base_link/livox_front_left_base_link,\n-       /sensor_kit/sensor_kit_base_link/livox_front_center_base_link,\n-       /sensor_kit/sensor_kit_base_link/livox_front_right_base_link]\"\n-     /&gt;\n-   &lt;let name=\"calibration_lidar_base_frames\" value=\"[\n-       livox_front_left_base_link,\n-       livox_front_center_base_link,\n-       livox_front_right_base_link]\"/&gt;\n-   &lt;let name=\"calibration_lidar_frames\" value=\"[\n-       livox_front_left,\n-       livox_front_center,\n-       livox_front_right]\"/&gt;\n+   &lt;let\n+           name=\"lidar_calibration_service_names\"\n+           value=\"[/sensor_kit/sensor_kit_base_link/&lt;YOUR_SENSOR_BASE_LINK&gt;,\n+                   /sensor_kit/sensor_kit_base_link/&lt;YOUR_SENSOR_BASE_LINK\n+                   ...]\"\n+   /&gt;\n+\n+   &lt;let name=\"calibration_lidar_base_frames\" value=\"[YOUR_SENSOR_BASE_LINK,\n+                                                     YOUR_SENSOR_BASE_LINK\n+                                                     ...]\"/&gt;\n+   &lt;let name=\"calibration_lidar_frames\" value=\"[YOUR_SENSOR_LINK,\n+                                                YOUR_SENSOR_LINK\n+                                                ...]\"/&gt;\n</code></pre> i.e., At the tutorial_vehicle it should be like this snippet <pre><code>+   &lt;let\n+           name=\"lidar_calibration_service_names\"\n+           value=\"[/sensor_kit/sensor_kit_base_link/rs_bpearl_front_base_link]\"\n+   /&gt;\n\n+   &lt;let name=\"calibration_lidar_base_frames\" value=\"[rs_bpearl_front_base_link]\"/&gt;\n+   &lt;let name=\"calibration_lidar_frames\" value=\"[rs_bpearl_front]\"/&gt;\n</code></pre> <p>After that, we will add the sensor topics and sensor frames in order to do that, we will continue filling the <code>mapping_based_sensor_kit.launch.xml</code> with (we recommend using the /sensing/lidar/top/pointcloud topic as the mapping pointcloud because the vehicle cloud is cropped at this topic by pointcloud preprocessing):</p> <pre><code>-     &lt;let name=\"mapping_lidar_frame\" value=\"velodyne_top\"/&gt;\n-     &lt;let name=\"mapping_pointcloud\" value=\"/sensing/lidar/top/pointcloud\"/&gt;\n+     &lt;let name=\"mapping_lidar_frame\" value=\"&lt;MAPPING_LIDAR_SENSOR_LINK&gt;\"/&gt;\n+     &lt;let name=\"mapping_pointcloud\" value=\"&lt;MAPPING_LIDAR_POINTCLOUD_TOPIC_NAME&gt;\"/&gt;\n\n\n-     &lt;let name=\"calibration_pointcloud_topics\" value=\"[\n-       /sensing/lidar/front_left/livox/lidar,\n-       /sensing/lidar/front_center/livox/lidar,\n-       /sensing/lidar/front_right/livox/lidar]\"/&gt;\n+     &lt;let name=\"calibration_pointcloud_topics\" value=\"[\n+       &lt;YOUR_LIDAR_TOPIC_FOR_CALIBRATION&gt;,\n+       &lt;YOUR_LIDAR_TOPIC_FOR_CALIBRATION&gt;,\n+       ...]\"/&gt;\n</code></pre> At the tutorial_vehicle it should be like this snippet. <pre><code>  &lt;let name=\"calibration_lidar_base_frames\" value=\"[rs_bpearl_front_base_link]\"/&gt;\n&lt;let name=\"calibration_lidar_frames\" value=\"[rs_bpearl_front]\"/&gt;\n\n&lt;let name=\"mapping_lidar_frame\" value=\"rs_helios_top\"/&gt;\n&lt;let name=\"mapping_pointcloud\" value=\"/sensing/lidar/top/pointcloud_raw\"/&gt;\n&lt;let name=\"detected_objects\" value=\"/perception/object_recognition/detection/objects\"/&gt;\n\n&lt;let name=\"calibration_pointcloud_topics\" value=\"[\n/sensing/lidar/right/pointcloud_raw]\"/&gt;\n</code></pre> <p>The mapping_based_sensor_kit.launch.xml launch file for tutorial_vehicle should be this:</p> i.e. <code>mapping_based_sensor_kit.launch.xml</code> for tutorial_vehicle <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n&lt;arg name=\"vehicle_id\" default=\"tutorial_vehicle\"/&gt;\n&lt;let name=\"sensor_model\" value=\"tutorial_vehicle_sensor_kit\"/&gt;\n\n&lt;arg name=\"rviz\"/&gt;\n&lt;let name=\"rviz_profile\" value=\"$(find-pkg-share extrinsic_mapping_based_calibrator)/rviz/x1.rviz\"/&gt;\n\n&lt;arg name=\"src_yaml\" default=\"$(find-pkg-share individual_params)/config/$(var vehicle_id)/$(var sensor_model)/sensor_kit_calibration.yaml\"/&gt;\n&lt;arg name=\"dst_yaml\" default=\"$(env HOME)/sensor_kit_calibration.yaml\"/&gt;\n\n&lt;let name=\"camera_calibration_service_names\" value=\"['']\"/&gt;\n\n&lt;let name=\"camera_calibration_sensor_kit_frames\" value=\"['']\"/&gt;\n&lt;let name=\"calibration_camera_frames\" value=\"['']\"/&gt;\n&lt;let name=\"calibration_camera_optical_link_frames\" value=\"['']\"/&gt;\n&lt;let name=\"calibration_camera_info_topics\" value=\"['']\"/&gt;\n\n&lt;let name=\"calibration_image_topics\" value=\"['']\"/&gt;\n\n&lt;let name=\"lidar_calibration_sensor_kit_frames\" value=\"[sensor_kit_base_link]\"/&gt;\n\n&lt;let\nname=\"lidar_calibration_service_names\"\nvalue=\"[/sensor_kit/sensor_kit_base_link/rs_bpearl_front_base_link]\"\n/&gt;\n\n&lt;let name=\"calibration_lidar_base_frames\" value=\"[rs_bpearl_front_base_link]\"/&gt;\n&lt;let name=\"calibration_lidar_frames\" value=\"[rs_bpearl_front]\"/&gt;\n\n&lt;let name=\"mapping_lidar_frame\" value=\"rs_helios_top\"/&gt;\n&lt;let name=\"mapping_pointcloud\" value=\"/sensing/lidar/top/pointcloud_raw\"/&gt;\n&lt;let name=\"detected_objects\" value=\"/perception/object_recognition/detection/objects\"/&gt;\n\n&lt;let name=\"calibration_pointcloud_topics\" value=\"[\n/sensing/lidar/right/pointcloud_raw]\"/&gt;\n\n&lt;group&gt;\n&lt;!-- extrinsic_calibration_client --&gt;\n&lt;node pkg=\"extrinsic_calibration_client\" exec=\"extrinsic_calibration_client\" name=\"extrinsic_calibration_client\" output=\"screen\"&gt;\n&lt;param name=\"src_path\" value=\"$(var src_yaml)\"/&gt;\n&lt;param name=\"dst_path\" value=\"$(var dst_yaml)\"/&gt;\n&lt;/node&gt;\n\n&lt;!-- extrinsic_calibration_manager --&gt;\n&lt;node pkg=\"extrinsic_calibration_manager\" exec=\"extrinsic_calibration_manager\" name=\"extrinsic_calibration_manager\" output=\"screen\"&gt;\n&lt;param name=\"parent_frame\" value=\"sensor_kit_base_link\"/&gt;\n&lt;param name=\"child_frames\" value=\"[rs_bpearl_front_base_link]\"/&gt;\n&lt;/node&gt;\n&lt;/group&gt;\n\n&lt;!-- mapping based calibrator --&gt;\n&lt;include file=\"$(find-pkg-share extrinsic_mapping_based_calibrator)/launch/calibrator.launch.xml\"&gt;\n&lt;arg name=\"ns\" value=\"\"/&gt;\n\n&lt;arg name=\"camera_calibration_service_names\" value=\"$(var camera_calibration_service_names)\"/&gt;\n&lt;arg name=\"lidar_calibration_service_names\" value=\"$(var lidar_calibration_service_names)\"/&gt;\n&lt;arg name=\"camera_calibration_sensor_kit_frames\" value=\"$(var camera_calibration_sensor_kit_frames)\"/&gt;\n&lt;arg name=\"lidar_calibration_sensor_kit_frames\" value=\"$(var lidar_calibration_sensor_kit_frames)\"/&gt;\n&lt;arg name=\"calibration_camera_frames\" value=\"$(var calibration_camera_frames)\"/&gt;\n&lt;arg name=\"calibration_camera_optical_link_frames\" value=\"$(var calibration_camera_optical_link_frames)\"/&gt;\n&lt;arg name=\"calibration_lidar_base_frames\" value=\"$(var calibration_lidar_base_frames)\"/&gt;\n&lt;arg name=\"calibration_lidar_frames\" value=\"$(var calibration_lidar_frames)\"/&gt;\n&lt;arg name=\"mapping_lidar_frame\" value=\"$(var mapping_lidar_frame)\"/&gt;\n\n&lt;arg name=\"mapping_pointcloud\" value=\"$(var mapping_pointcloud)\"/&gt;\n&lt;arg name=\"detected_objects\" value=\"$(var detected_objects)\"/&gt;\n\n&lt;arg name=\"calibration_camera_info_topics\" value=\"$(var calibration_camera_info_topics)\"/&gt;\n&lt;arg name=\"calibration_image_topics\" value=\"$(var calibration_image_topics)\"/&gt;\n&lt;arg name=\"calibration_pointcloud_topics\" value=\"$(var calibration_pointcloud_topics)\"/&gt;\n\n&lt;arg name=\"mapping_max_range\" value=\"150.0\"/&gt;\n&lt;arg name=\"local_map_num_keyframes\" value=\"30\"/&gt;\n&lt;arg name=\"dense_pointcloud_num_keyframes\" value=\"20\"/&gt;\n&lt;arg name=\"ndt_resolution\" value=\"0.5\"/&gt;\n&lt;arg name=\"ndt_max_iterations\" value=\"100\"/&gt;\n&lt;arg name=\"ndt_epsilon\" value=\"0.005\"/&gt;\n&lt;arg name=\"lost_frame_max_acceleration\" value=\"15.0\"/&gt;\n&lt;arg name=\"lidar_calibration_max_frames\" value=\"10\"/&gt;\n&lt;arg name=\"calibration_eval_max_corr_distance\" value=\"0.2\"/&gt;\n&lt;arg name=\"solver_iterations\" value=\"100\"/&gt;\n&lt;arg name=\"calibration_skip_keyframes\" value=\"15\"/&gt;\n&lt;/include&gt;\n\n&lt;node pkg=\"rviz2\" exec=\"rviz2\" name=\"rviz2\" output=\"screen\" args=\"-d $(var rviz_profile)\" if=\"$(var rviz)\"/&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/calibrating-sensors/lidar-lidar-calibration/#lidar-lidar-calibration-process-with-interactive-mapping-based-calibrator","title":"Lidar-Lidar calibration process with interactive mapping-based calibrator","text":"<p>After completing mapping_based.launch.xml and mapping_based_sensor_kit.launch.xml launch files for own sensor kit; now we are ready to calibrate our lidars. First of all, we need to build extrinsic_calibration_manager package:</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-select extrinsic_calibration_manager\n</code></pre> <p>So, we are ready to launch and use mapping-based lidar-lidar calibrator:</p> <pre><code>ros2 launch extrinsic_calibration_manager calibration.launch.xml mode:=mapping_based sensor_model:=&lt;OWN-SENSOR-KIT&gt; vehicle_model:=&lt;OWN-VEHICLE-MODEL&gt; vehicle_id:=&lt;VEHICLE-ID&gt;\n</code></pre> <p>For tutorial vehicle:</p> <pre><code>ros2 launch extrinsic_calibration_manager calibration.launch.xml mode:=mapping_based sensor_model:=tutorial_vehicle_sensor_kit vehicle_model:=tutorial_vehicle vehicle_id:=tutorial_vehicle\n</code></pre> <p>You will show the rviz2 screen with several configurations, you need to update it with your sensor information topics like the video, which included an end of the document. Also, you can save the rviz2 config on rviz directory, so you can use it later with modifying <code>mapping_based_sensor_kit.launch.xml</code>.</p> <pre><code>extrinsic_ground_plane_calibrator/\n   \u2514\u2500 rviz/\n+        \u2514\u2500 tutorial_vehicle_sensor_kit.rviz\n</code></pre> <p>Then play ROS 2 bag file:</p> <pre><code>ros2 bag play &lt;rosbag_path&gt; --clock -r 0.2 \\\n--remap /tf:=/null/tf /tf_static:=/null/tf_static # if tf is recorded\n</code></pre> <p>The calibration step consists of two phases: mapping and calibration. At the bag starts playing, then mapping starts as well as the rviz2 screenshot below.</p> <p></p> <p>So, red arrow markers indicate poses during mapping, green arrow markers are special poses taken uniformly, and white points indicate the constructed map.</p> <p>Mapping halts either upon reaching a predefined data threshold or can be prematurely concluded by invoking this service:</p> <pre><code>ros2 service call /NAMESPACE/stop_mapping std_srvs/srv/Empty {}\n</code></pre> <p>After the mapping phase of calibration is completed, then the calibration process will start. After the calibration is completed, then you should rviz2 screen like the image below:</p> <p></p> <p>The red points indicate pointcloud that initial calibration results of previous section. The green points indicate aligned point (calibration result). The calibration results will be saved automatically on your <code>dst_yaml</code> ($HOME/sensor_kit_calibration.yaml) at this tutorial.</p> <p>Here is the video for demonstrating the mapping-based lidar-lidar calibration process on tutorial_vehicle: </p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-individual-params/","title":"Creating individual params","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-individual-params/#creating-individual-params","title":"Creating individual params","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-individual-params/#introduction","title":"Introduction","text":"<p>The individual_params package is used to define customized sensor calibrations for different vehicles. It lets you define customized sensor calibrations for different vehicles while using the same launch files with the same sensor model.</p> <p>Warning</p> <p>The \"individual_params\" package contains the calibration results for your sensor kit and overrides the default calibration results found in VEHICLE-ID_sensor_kit_description/config/ directory.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-individual-params/#placing-your-individual_parameters-repository-inside-autoware","title":"Placing your <code>individual_parameters</code> repository inside Autoware","text":"<p>Previously on this guide, we forked the <code>autoware_individual_params</code> repository to create a tutorial_vehicle_individual_params repository which will be used as an example for this section of the guide. Your individual_parameters repository should be placed inside your Autoware folder following the same folder structure as the one shown below:</p> sample folder structure for <code>tutorial_vehicle_individual_params</code> <pre><code>  &lt;YOUR-OWN-AUTOWARE-DIR&gt;/\n  \u2514\u2500 src/\n  \u2514\u2500 param/\n  \u2514\u2500 tutorial_vehicle_individual_params/\n  \u2514\u2500 individual_params/\n  \u2514\u2500 config/\n  \u251c\u2500 default/\n+ \u2514\u2500 tutorial_vehicle/\n+     \u2514\u2500 tutorial_vehicle_sensor_kit_launch/\n+         \u251c\u2500 imu_corrector.param.yaml\n+         \u251c\u2500 sensor_kit_calibration.yaml\n+         \u2514\u2500 sensors_calibration.yaml\n</code></pre> <p>After that, we need to build our <code>individual_params</code> package:</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-up-to individual_params\n</code></pre> <p>Now you are ready to use Autoware with a vehicle_id as an argument. For example, if you are several, similar vehicles with different sensor calibration requirements, your autoware_individual_params structure should look like this:</p> <pre><code>individual_params/\n\u2514\u2500 config/\n     \u251c\u2500 default/\n     \u2502   \u2514\u2500 &lt;YOUR_SENSOR_KIT&gt;/                  # example1\n     \u2502        \u251c\u2500 imu_corrector.param.yaml\n     \u2502        \u251c\u2500 sensor_kit_calibration.yaml\n     \u2502        \u2514\u2500 sensors_calibration.yaml\n+    \u251c\u2500 VEHICLE_1/\n+    \u2502   \u2514\u2500 &lt;YOUR_SENSOR_KIT&gt;/                  # example2\n+    \u2502        \u251c\u2500 imu_corrector.param.yaml\n+    \u2502        \u251c\u2500 sensor_kit_calibration.yaml\n+    \u2502        \u2514\u2500 sensors_calibration.yaml\n+    \u2514\u2500 VEHICLE_2/\n+         \u2514\u2500 &lt;YOUR_SENSOR_KIT&gt;/                  # example3\n+              \u251c\u2500 imu_corrector.param.yaml\n+              \u251c\u2500 sensor_kit_calibration.yaml\n+              \u2514\u2500 sensors_calibration.yaml\n</code></pre> <p>Then, you can use autoware with vehicle_id arguments like this:</p> <p>Add a <code>&lt;vehicle_id&gt;</code> as an argument and switch parameters using options at startup.</p> <pre><code># example1 (do not set vehicle_id)\n$ ros2 launch autoware_launch autoware.launch.xml sensor_model:=&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit vehicle_model:=&lt;YOUR-VEHICLE-NAME&gt;_vehicle\n# example2 (set vehicle_id as VEHICLE_1)\n$ ros2 launch autoware_launch autoware.launch.xml sensor_model:=&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit vehicle_model:=&lt;YOUR-VEHICLE-NAME&gt;_vehicle vehicle_id:=VEHICLE_1\n# example3 (set vehicle_id as VEHICLE_2)\n$ ros2 launch autoware_launch autoware.launch.xml sensor_model:=&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit vehicle_model:=&lt;YOUR-VEHICLE-NAME&gt;_vehicle vehicle_id:=VEHICLE_2\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/","title":"Creating a sensor model for Autoware","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#creating-a-sensor-model-for-autoware","title":"Creating a sensor model for Autoware","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#introduction","title":"Introduction","text":"<p>This page introduces the following packages for the sensor model:</p> <ol> <li><code>common_sensor_launch</code></li> <li><code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_description</code></li> <li><code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch</code></li> </ol> <p>Previously, we forked our sensor model at the creating autoware repositories page step. For instance, we created tutorial_vehicle_sensor_kit_launch as an implementation example for the said step. Please ensure that the _sensor_kit_launch repository is included in Autoware, following the directory structure below:</p> <pre><code>&lt;YOUR-OWN-AUTOWARE-DIR&gt;/\n  \u2514\u2500 src/\n       \u2514\u2500 sensor_kit/\n            \u2514\u2500 &lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch/\n                 \u251c\u2500 common_sensor_launch/\n                 \u251c\u2500 &lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_description/\n                 \u2514\u2500 &lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch/\n</code></pre> <p>If your forked Autoware meta-repository doesn't include <code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch</code> with the correct folder structure as shown above, please add your forked <code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch</code> repository to the autoware.repos file and run the vcs import src &lt; autoware.repos command in your terminal to import the newly included repositories at autoware.repos file.</p> <p>Now, we are ready to modify the following sensor model packages for our vehicle. Firstly, we need to rename the description and launch packages:</p> <pre><code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch/\n  \u251c\u2500 common_sensor_launch/\n- \u251c\u2500 sample_sensor_kit_description/\n+ \u251c\u2500 &lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_description/\n- \u2514\u2500 sample_sensor_kit_launch/\n+ \u2514\u2500 &lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch/\n</code></pre> <p>After that, we will change our package names in the package.xml file and CMakeLists.txt file of the sample_sensor_kit_description and sample_sensor_kit_launch packages. So, open the package.xml file and CMakeLists.txt file with any text editor or IDE of your preference and perform the following changes:</p> <p>Change the <code>&lt;name&gt;</code> attribute at <code>package.xml</code> file:</p> <pre><code>&lt;package format=\"3\"&gt;\n- &lt;name&gt;sample_sensor_kit_description&lt;/name&gt;\n+ &lt;name&gt;&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_description&lt;/name&gt;\n &lt;version&gt;0.1.0&lt;/version&gt;\n  &lt;description&gt;The sensor_kit_description package&lt;/description&gt;\n  ...\n  ...\n</code></pre> <p>Change the <code>project()</code> method at <code>CmakeList.txt</code> file.</p> <pre><code>  cmake_minimum_required(VERSION 3.5)\n- project(sample_sensor_kit_description)\n+ project(&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_description)\n\n find_package(ament_cmake_auto REQUIRED)\n...\n...\n</code></pre> <p>Remember to apply the name changes and project method for BOTH <code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_description</code>and <code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch</code> ROS 2 packages. Once finished, we can proceed to build said packages:</p> <pre><code>cd &lt;YOUR-AUTOWARE-DIR&gt;\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-up-to &lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_description &lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#sensor-description","title":"Sensor description","text":"<p>The main purpose of this package is to describe the sensor frame IDs, calibration parameters of all sensors, and their links with urdf files.</p> <p>The folder structure of sensor_kit_description package is:</p> <pre><code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_description/\n   \u251c\u2500 config/\n   \u2502     \u251c\u2500 sensor_kit_calibration.yaml\n   \u2502     \u2514\u2500 sensors_calibration.yaml\n   \u2514\u2500 urdf/\n         \u251c\u2500 sensor_kit.xacro\n         \u2514\u2500 sensors.xacro\n</code></pre> <p>Now, we will modify these files according to our sensor design.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#sensor_kit_calibrationyaml","title":"sensor_kit_calibration.yaml","text":"<p>This file defines the mounting positions and orientations of sensors with <code>sensor_kit_base_link</code> as the parent frame. We can assume <code>sensor_kit_base_link</code> frame is bottom of your main Lidar sensor. We must create this file with euler format as [x, y, z, roll, pitch, yaw]. Also, we will set these values with \"0\" until the calibration steps.</p> <p>We will define new frames for this file, and we will connect them <code>.xacro</code> files. We recommend naming as if your lidar sensor frame as \"velodyne_top\", you can add \"_base_link\" to our calibration .yaml file.</p> <p>So, the sample file must be like:</p> <pre><code>sensor_kit_base_link:\nvelodyne_top_base_link:\nx: 0.000000\ny: 0.000000\nz: 0.000000\nroll: 0.000000\npitch: 0.000000\nyaw: 0.000000\ncamera0/camera_link:\nx: 0.000000\ny: 0.000000\nz: 0.000000\nroll: 0.000000\npitch: 0.000000\nyaw: 0.000000\n...\n...\n</code></pre> <p>This file for <code>tutorial_vehicle</code> was created for one camera, two lidars and one GNSS/INS sensors.</p> <code>sensor_kit_calibration.yaml</code> for tutorial_vehicle_sensor_kit_description <pre><code>sensor_kit_base_link:\ncamera0/camera_link: # Camera\nx: 0.0\ny: 0.0\nz: 0.0\nroll: 0.0\npitch: 0.0\nyaw: 0.0\nrs_helios_top_base_link: # Lidar\nx: 0.0\ny: 0.0\nz: 0.0\nroll: 0.0\npitch: 0.0\nyaw: 0.0\nrs_bpearl_front_base_link: # Lidar\nx: 0.0\ny: 0.0\nz: 0.0\nroll: 0.0\npitch: 0.0\nyaw: 0.0\nGNSS_INS/gnss_ins_link: # GNSS/INS\nx: 0.0\ny: 0.0\nz: 0.0\nroll: 0.0\npitch: 0.0\nyaw: 0.0\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#sensors_calibrationyaml","title":"sensors_calibration.yaml","text":"<p>This file defines the mounting positions and orientations of <code>sensor_kit_base_link</code> (child frame) with <code>base_link</code> as the parent frame. At Autoware, <code>base_link</code> is on projection of the rear-axle center onto the ground surface. For more information, you can check vehicle dimension page. You can use CAD values for this, but we will fill the values with <code>0</code> for now.</p> <pre><code>base_link:\nsensor_kit_base_link:\nx: 0.000000\ny: 0.000000\nz: 0.000000\nroll: 0.000000\npitch: 0.000000\nyaw: 0.000000\n</code></pre> <p>Now, we are ready to implement .xacro files. These files provide linking our sensor frames and adding sensor urdf files</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#sensor_kitxacro","title":"sensor_kit.xacro","text":"<p>We will add our sensors and remove unnecessary xacros from this file. For example, we want to add our lidar sensor with <code>velodyne_top</code> frame from the sensor driver, we will add the following xacro to our sensor_kit.xacro file. Please add your sensors to this file and remove unnecessary sensor's xacros.</p> <pre><code>    &lt;!-- lidar --&gt;\n&lt;xacro:VLS-128 parent=\"sensor_kit_base_link\" name=\"velodyne_top\" topic=\"/points_raw\" hz=\"10\" samples=\"220\" gpu=\"$(arg gpu)\"&gt;\n&lt;origin\nxyz=\"${calibration['sensor_kit_base_link']['velodyne_top_base_link']['x']}\n                 ${calibration['sensor_kit_base_link']['velodyne_top_base_link']['y']}\n                 ${calibration['sensor_kit_base_link']['velodyne_top_base_link']['z']}\"\nrpy=\"${calibration['sensor_kit_base_link']['velodyne_top_base_link']['roll']}\n                 ${calibration['sensor_kit_base_link']['velodyne_top_base_link']['pitch']}\n                 ${calibration['sensor_kit_base_link']['velodyne_top_base_link']['yaw']}\"\n/&gt;\n&lt;/xacro:VLS-128&gt;\n</code></pre> <p>Here is the sample xacro file for tutorial_vehicle with one camera, two lidars and one GNSS/INS sensors.</p> <code>sensor_kit.xacro</code> for tutorial_vehicle_sensor_kit_description <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot xmlns:xacro=\"http://ros.org/wiki/xacro\"&gt;\n&lt;xacro:macro name=\"sensor_kit_macro\" params=\"parent x y z roll pitch yaw\"&gt;\n&lt;xacro:include filename=\"$(find velodyne_description)/urdf/VLP-16.urdf.xacro\"/&gt;\n&lt;xacro:include filename=\"$(find vls_description)/urdf/VLS-128.urdf.xacro\"/&gt;\n&lt;xacro:include filename=\"$(find camera_description)/urdf/monocular_camera.xacro\"/&gt;\n&lt;xacro:include filename=\"$(find imu_description)/urdf/imu.xacro\"/&gt;\n\n&lt;xacro:arg name=\"gpu\" default=\"false\"/&gt;\n&lt;xacro:arg name=\"config_dir\" default=\"$(find tutorial_vehicle_sensor_kit_description)/config\"/&gt;\n\n&lt;xacro:property name=\"sensor_kit_base_link\" default=\"sensor_kit_base_link\"/&gt;\n\n&lt;joint name=\"${sensor_kit_base_link}_joint\" type=\"fixed\"&gt;\n&lt;origin rpy=\"${roll} ${pitch} ${yaw}\" xyz=\"${x} ${y} ${z}\"/&gt;\n&lt;parent link=\"${parent}\"/&gt;\n&lt;child link=\"${sensor_kit_base_link}\"/&gt;\n&lt;/joint&gt;\n&lt;link name=\"${sensor_kit_base_link}\"&gt;\n&lt;origin rpy=\"0 0 0\" xyz=\"0 0 0\"/&gt;\n&lt;/link&gt;\n\n&lt;!-- sensor --&gt;\n&lt;xacro:property name=\"calibration\" value=\"${xacro.load_yaml('$(arg config_dir)/sensor_kit_calibration.yaml')}\"/&gt;\n\n&lt;!-- lidar --&gt;\n&lt;xacro:VLS-128 parent=\"sensor_kit_base_link\" name=\"rs_helios_top\" topic=\"/points_raw\" hz=\"10\" samples=\"220\" gpu=\"$(arg gpu)\"&gt;\n&lt;origin\nxyz=\"${calibration['sensor_kit_base_link']['rs_helios_top_base_link']['x']}\n             ${calibration['sensor_kit_base_link']['rs_helios_top_base_link']['y']}\n             ${calibration['sensor_kit_base_link']['rs_helios_top_base_link']['z']}\"\nrpy=\"${calibration['sensor_kit_base_link']['rs_helios_top_base_link']['roll']}\n             ${calibration['sensor_kit_base_link']['rs_helios_top_base_link']['pitch']}\n             ${calibration['sensor_kit_base_link']['rs_helios_top_base_link']['yaw']}\"\n/&gt;\n&lt;/xacro:VLS-128&gt;\n&lt;xacro:VLP-16 parent=\"sensor_kit_base_link\" name=\"rs_bpearl_front\" topic=\"/points_raw\" hz=\"10\" samples=\"220\" gpu=\"$(arg gpu)\"&gt;\n&lt;origin\nxyz=\"${calibration['sensor_kit_base_link']['rs_bpearl_front_base_link']['x']}\n             ${calibration['sensor_kit_base_link']['rs_bpearl_front_base_link']['y']}\n             ${calibration['sensor_kit_base_link']['rs_bpearl_front_base_link']['z']}\"\nrpy=\"${calibration['sensor_kit_base_link']['rs_bpearl_front_base_link']['roll']}\n             ${calibration['sensor_kit_base_link']['rs_bpearl_front_base_link']['pitch']}\n             ${calibration['sensor_kit_base_link']['rs_bpearl_front_base_link']['yaw']}\"\n/&gt;\n&lt;/xacro:VLP-16&gt;\n\n&lt;!-- camera --&gt;\n&lt;xacro:monocular_camera_macro\nname=\"camera0/camera\"\nparent=\"sensor_kit_base_link\"\nnamespace=\"\"\nx=\"${calibration['sensor_kit_base_link']['camera0/camera_link']['x']}\"\ny=\"${calibration['sensor_kit_base_link']['camera0/camera_link']['y']}\"\nz=\"${calibration['sensor_kit_base_link']['camera0/camera_link']['z']}\"\nroll=\"${calibration['sensor_kit_base_link']['camera0/camera_link']['roll']}\"\npitch=\"${calibration['sensor_kit_base_link']['camera0/camera_link']['pitch']}\"\nyaw=\"${calibration['sensor_kit_base_link']['camera0/camera_link']['yaw']}\"\nfps=\"30\"\nwidth=\"800\"\nheight=\"400\"\nfov=\"1.3\"\n/&gt;\n\n&lt;!-- gnss --&gt;\n&lt;xacro:imu_macro\nname=\"gnss\"\nparent=\"sensor_kit_base_link\"\nnamespace=\"\"\nx=\"${calibration['sensor_kit_base_link']['gnss_link']['x']}\"\ny=\"${calibration['sensor_kit_base_link']['gnss_link']['y']}\"\nz=\"${calibration['sensor_kit_base_link']['gnss_link']['z']}\"\nroll=\"${calibration['sensor_kit_base_link']['gnss_link']['roll']}\"\npitch=\"${calibration['sensor_kit_base_link']['gnss_link']['pitch']}\"\nyaw=\"${calibration['sensor_kit_base_link']['gnss_link']['yaw']}\"\nfps=\"100\"\n/&gt;\n\n&lt;/xacro:macro&gt;\n&lt;/robot&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#sensorsxacro","title":"sensors.xacro","text":"<p>This files links our sensor_kit main frame (<code>sensor_kit_base_link</code>) to base_link. Also, you have sensors which will be calibrated directly to base_link, you can add it to here.</p> <p>Here is the sensors.xacro file for sample_sensor_kit_description package: (velodyne_rear transformation is directly used with base_link)</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name=\"vehicle\" xmlns:xacro=\"http://ros.org/wiki/xacro\"&gt;\n&lt;xacro:arg name=\"config_dir\" default=\"$(find sample_sensor_kit_description)/config\"/&gt;\n&lt;xacro:property name=\"calibration\" value=\"${xacro.load_yaml('$(arg config_dir)/sensors_calibration.yaml')}\"/&gt;\n\n&lt;!-- sensor kit --&gt;\n&lt;xacro:include filename=\"sensor_kit.xacro\"/&gt;\n&lt;xacro:sensor_kit_macro\nparent=\"base_link\"\nx=\"${calibration['base_link']['sensor_kit_base_link']['x']}\"\ny=\"${calibration['base_link']['sensor_kit_base_link']['y']}\"\nz=\"${calibration['base_link']['sensor_kit_base_link']['z']}\"\nroll=\"${calibration['base_link']['sensor_kit_base_link']['roll']}\"\npitch=\"${calibration['base_link']['sensor_kit_base_link']['pitch']}\"\nyaw=\"${calibration['base_link']['sensor_kit_base_link']['yaw']}\"\n/&gt;\n\n&lt;!-- embedded sensors --&gt;\n&lt;xacro:include filename=\"$(find velodyne_description)/urdf/VLP-16.urdf.xacro\"/&gt;\n&lt;xacro:VLP-16 parent=\"base_link\" name=\"velodyne_rear\" topic=\"velodyne_rear/velodyne_points\" hz=\"10\" samples=\"220\" gpu=\"false\"&gt;\n&lt;origin\nxyz=\"${calibration['base_link']['velodyne_rear_base_link']['x']}\n           ${calibration['base_link']['velodyne_rear_base_link']['y']}\n           ${calibration['base_link']['velodyne_rear_base_link']['z']}\"\nrpy=\"${calibration['base_link']['velodyne_rear_base_link']['roll']}\n           ${calibration['base_link']['velodyne_rear_base_link']['pitch']}\n           ${calibration['base_link']['velodyne_rear_base_link']['yaw']}\"\n/&gt;\n&lt;/xacro:VLP-16&gt;\n&lt;/robot&gt;\n</code></pre> <p>At our tutorial vehicle, there is no directly sensor transformation for base_link, thus our sensors.xacro file includes only <code>base_link</code> and <code>sensor_kit_base_link</code> link.</p> <code>sensors.xacro</code> for tutorial_vehicle_sensor_kit_description <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name=\"vehicle\" xmlns:xacro=\"http://ros.org/wiki/xacro\"&gt;\n&lt;xacro:arg name=\"config_dir\" default=\"$(find tutorial_vehicle_sensor_kit_description)/config\"/&gt;\n&lt;xacro:property name=\"calibration\" value=\"${xacro.load_yaml('$(arg config_dir)/sensors_calibration.yaml')}\"/&gt;\n\n&lt;!-- sensor kit --&gt;\n&lt;xacro:include filename=\"sensor_kit.xacro\"/&gt;\n&lt;xacro:sensor_kit_macro\nparent=\"base_link\"\nx=\"${calibration['base_link']['sensor_kit_base_link']['x']}\"\ny=\"${calibration['base_link']['sensor_kit_base_link']['y']}\"\nz=\"${calibration['base_link']['sensor_kit_base_link']['z']}\"\nroll=\"${calibration['base_link']['sensor_kit_base_link']['roll']}\"\npitch=\"${calibration['base_link']['sensor_kit_base_link']['pitch']}\"\nyaw=\"${calibration['base_link']['sensor_kit_base_link']['yaw']}\"\n/&gt;\n&lt;/robot&gt;\n</code></pre> <p>After the completing <code>sensor_kit_calibration.yaml</code>, <code>sensors_calibration.yaml</code>, <code>sensor_kit.xacro</code> and <code>sensors.xacro</code> file, our sensor description package is finished, we will continue with modifying <code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch</code> package.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#sensor-launch","title":"Sensor launch","text":"<p>At this package (<code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch</code>), we will launch our sensors and their pipelines. So, we will also use <code>common_sensor_launch</code> package for launching the lidar sensing pipeline. This image below demonstrates our sensor pipeline, which we will construct in this section.</p> <p> </p>      Sample Launch workflow for sensing design.    <p>The <code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch</code> package folder structure like this:</p> <pre><code>&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch/\n      \u251c\u2500 config/\n      \u251c\u2500 data/\n      \u2514\u2500 launch/\n+           \u251c\u2500 camera.launch.xml\n+           \u251c\u2500 gnss.launch.xml\n+           \u251c\u2500 imu.launch.xml\n+           \u251c\u2500 lidar.launch.xml\n+           \u251c\u2500 pointcloud_preprocessor.launch.py\n+           \u2514\u2500 sensing.launch.xml\n</code></pre> <p>So, we will modify the launch files which located the <code>launch</code> folder for launching and manipulating our sensors. The main launch file is <code>sensing.launch.xml</code>. This launch file launches other sensing launch files. The current autoware sensing launch files design for <code>sensor_kit_launch</code> package is the diagram below.</p> <p> </p>      Launch file flows over sensing.launch.xml launch file.    <p>The <code>sensing.launch.xml</code> also launches <code>vehicle_velocity_converter</code> package for converting <code>autoware_auto_vehicle_msgs::msg::VelocityReport</code> message to <code>geometry_msgs::msg::TwistWithCovarianceStamped</code> for gyro_odometer node. So, be sure your vehicle_interface publishes <code>/vehicle/status/velocity_status</code> topic with <code>autoware_auto_vehicle_msgs::msg::VelocityReport</code> type, or you must update <code>input_vehicle_velocity_topic</code> at <code>sensing.launch.xml</code>.</p> <pre><code>    ...\n    &lt;include file=\"$(find-pkg-share vehicle_velocity_converter)/launch/vehicle_velocity_converter.launch.xml\"&gt;\n-     &lt;arg name=\"input_vehicle_velocity_topic\" value=\"/vehicle/status/velocity_status\"/&gt;\n+     &lt;arg name=\"input_vehicle_velocity_topic\" value=\"&lt;YOUR-VELOCITY-STATUS-TOPIC&gt;\"/&gt;\n     &lt;arg name=\"output_twist_with_covariance\" value=\"/sensing/vehicle_velocity_converter/twist_with_covariance\"/&gt;\n    &lt;/include&gt;\n    ...\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#lidar-launching","title":"Lidar Launching","text":"<p>Let's start with modifying <code>lidar.launch.xml</code> file for launching our lidar sensor driver with autoware. Please check supported lidar sensors over the nebula driver in the GitHub repository.</p> <p>If you are using Velodyne Lidar sensor, you can use the sample_sensor_kit_launch template, but you need to update <code>sensor_id</code>, <code>data_port</code>, <code>sensor_frame</code> and other necessary changes (<code>max_range</code>, <code>scan_phase</code>, etc.).</p> <pre><code>    &lt;group&gt;\n-     &lt;push-ros-namespace namespace=\"left\"/&gt;\n+     &lt;push-ros-namespace namespace=\"&lt;YOUR-SENSOR-NAMESPACE&gt;\"/&gt;\n     &lt;include file=\"$(find-pkg-share common_sensor_launch)/launch/velodyne_VLP16.launch.xml\"&gt;\n        &lt;arg name=\"max_range\" value=\"5.0\"/&gt;\n-       &lt;arg name=\"sensor_frame\" value=\"velodyne_left\"/&gt;\n+       &lt;arg name=\"sensor_frame\" value=\"&lt;YOUR-SENSOR-FRAME&gt;\"/&gt;\n-       &lt;arg name=\"sensor_ip\" value=\"192.168.1.202\"/&gt;\n+       &lt;arg name=\"sensor_ip\" value=\"&lt;YOUR-SENSOR-IP&gt;\"/&gt;\n       &lt;arg name=\"host_ip\" value=\"$(var host_ip)\"/&gt;\n-       &lt;arg name=\"data_port\" value=\"2369\"/&gt;\n+       &lt;arg name=\"data_port\" value=&lt;YOUR-DATA-PORT&gt;/&gt;\n       &lt;arg name=\"scan_phase\" value=\"180.0\"/&gt;\n        &lt;arg name=\"cloud_min_angle\" value=\"300\"/&gt;\n        &lt;arg name=\"cloud_max_angle\" value=\"60\"/&gt;\n        &lt;arg name=\"launch_driver\" value=\"$(var launch_driver)\"/&gt;\n        &lt;arg name=\"vehicle_mirror_param_file\" value=\"$(var vehicle_mirror_param_file)\"/&gt;\n        &lt;arg name=\"use_pointcloud_container\" value=\"$(var use_pointcloud_container)\"/&gt;\n        &lt;arg name=\"container_name\" value=\"$(var pointcloud_container_name)\"/&gt;\n      &lt;/include&gt;\n    &lt;/group&gt;\n</code></pre> <p>Please add similar launch groups according to your sensor architecture. For example, we use Robosense Lidars for our <code>tutorial_vehicle</code>, so the lidar group for Robosense Lidar should be like this structure:</p> <p>Warning</p> <p>under construction</p> <p>If you are using a Hesai lidar (i.e. PandarQT64, please check nebula driver page for supported sensors), you can add the group like this structure at <code>lidar.launch.xml</code>:</p> <pre><code>    &lt;group&gt;\n&lt;push-ros-namespace namespace=\"&lt;YOUR-SENSOR-NAMESPACE&gt;\"/&gt;\n&lt;include file=\"$(find-pkg-share common_sensor_launch)/launch/hesai_PandarQT64.launch.xml\"&gt;\n&lt;arg name=\"max_range\" value=\"100\"/&gt;\n&lt;arg name=\"sensor_frame\" value=\"&lt;YOUR-HESAI-SENSOR-FRAME&gt;\"/&gt;\n&lt;arg name=\"sensor_ip\" value=\"&lt;YOUR-HESAI-SENSOR-IP&gt;\"/&gt;\n&lt;arg name=\"host_ip\" value=\"$(var host_ip)\"/&gt;\n&lt;arg name=\"data_port\" value=\"&lt;YOUR-HESAI-SENSOR-DATA-PORT&gt;\"/&gt;\n&lt;arg name=\"scan_phase\" value=\"0.0\"/&gt;\n&lt;arg name=\"cloud_min_angle\" value=\"0\"/&gt;\n&lt;arg name=\"cloud_max_angle\" value=\"360\"/&gt;\n&lt;arg name=\"launch_driver\" value=\"$(var launch_driver)\"/&gt;\n&lt;arg name=\"vehicle_mirror_param_file\" value=\"$(var vehicle_mirror_param_file)\"/&gt;\n&lt;arg name=\"use_pointcloud_container\" value=\"$(var use_pointcloud_container)\"/&gt;\n&lt;arg name=\"container_name\" value=\"$(var pointcloud_container_name)\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n</code></pre> <p>You can create .launch.xml for common sensor launch, please check <code>hesai_PandarQT64.launch.xml</code> as an example.</p> <p>The nebula_node_container.py creates the Lidar pipeline for autoware, the pointcloud preprocessing pipeline is constructed for each lidar please check pointcloud_preprocessor package for filters information as well.</p> <p>For example, If you want to change your <code>outlier_filter</code> method, you can modify the pipeline components like this way:</p> <pre><code>    nodes.append(\n        ComposableNode(\n            package=\"pointcloud_preprocessor\",\n-           plugin=\"pointcloud_preprocessor::RingOutlierFilterComponent\",\n-           name=\"ring_outlier_filter\",\n+           plugin=\"pointcloud_preprocessor::DualReturnOutlierFilterComponent\",\n+           name=\"dual_return_outlier_filter\",\n           remappings=[\n                (\"input\", \"rectified/pointcloud_ex\"),\n                (\"output\", \"pointcloud\"),\n            ],\n            extra_arguments=[{\"use_intra_process_comms\": LaunchConfiguration(\"use_intra_process\")}],\n        )\n    )\n</code></pre> <p>We will use the default pointcloud_preprocessor pipeline for our tutorial_vehicle, thus we will not modify nebula_node_container.py.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#camera-launching","title":"Camera Launching","text":"<p>In this section, we will launch our camera driver and 2D detection pipeline for Autoware for tutorial_vehicle. The reason we do this is that there is a one computer for tutorial_vehicle. If you are using two or more computers for Autoware, you can launch the camera and 2D detection pipeline separately. For example, you can clone your camera driver at <code>src/sensor_component/external</code> folder (please don't forget adding this driver to <code>autoware.repos</code> file):</p> <pre><code>&lt;YOUR-AUTOWARE-DIR&gt;\n   \u2514\u2500 src/\n         \u2514\u2500 sensor_component/\n            \u2514\u2500 external/\n                \u2514\u2500 YOUR-CAMERA-DRIVER\n</code></pre> <p>After that, you can just add your camera driver at <code>camera.launch.xml</code>:</p> <pre><code>    ...\n+   &lt;include file=\"$(find-pkg-share &lt;YOUR-SENSOR-DRIVER&gt;)/launch/YOUR-CAMERA-LAUNCH-FILE\"&gt;\n   ...\n</code></pre> <p>Then, you can launch tensorrt_yolo node via adding yolo.launch.xml on your design like that: (i.e., it is included in tier4_perception_launch package in autwoare.universe) <code>image_number</code> argument defines your camera number</p> <pre><code>  &lt;include file=\"$(find-pkg-share tensorrt_yolo)/launch/yolo.launch.xml\"&gt;\n&lt;arg name=\"image_raw0\" value=\"$(var image_raw0)\"/&gt;\n&lt;arg name=\"image_raw1\" value=\"$(var image_raw1)\"/&gt;\n&lt;arg name=\"image_raw2\" value=\"$(var image_raw2)\"/&gt;\n&lt;arg name=\"image_raw3\" value=\"$(var image_raw3)\"/&gt;\n&lt;arg name=\"image_raw4\" value=\"$(var image_raw4)\"/&gt;\n&lt;arg name=\"image_raw5\" value=\"$(var image_raw5)\"/&gt;\n&lt;arg name=\"image_raw6\" value=\"$(var image_raw6)\"/&gt;\n&lt;arg name=\"image_raw7\" value=\"$(var image_raw7)\"/&gt;\n&lt;arg name=\"image_number\" value=\"$(var image_number)\"/&gt;\n&lt;/include&gt;\n</code></pre> <p>Since we are using the same computer for 2D detection pipeline and all Autoware nodes, we will design our camera and 2D detection pipeline using composable nodes and container structure. So, it will decrease our network interface usage. First of all, let's start with our camera sensor: Lucid Vision TRIO54S. We will use this sensor with lucid_vision_driver at the autowarefoundation organization. We can clone this driver <code>src/sensor_component/external</code> folder as well. After the cloning and the building camera driver, we will create \"camera_node_container.launch.py\" for launching camera and tensorrt_yolo node in same container.</p> <code>camera_node_container.launch.py</code> launch file for tutorial_vehicle <p>```py   import launch   from launch.actions import DeclareLaunchArgument   from launch.actions import SetLaunchConfiguration   from launch.conditions import IfCondition   from launch.conditions import UnlessCondition   from launch.substitutions.launch_configuration import LaunchConfiguration   from launch_ros.actions import ComposableNodeContainer   from launch_ros.descriptions import ComposableNode   from launch_ros.substitutions import FindPackageShare   from launch.actions import OpaqueFunction   import yaml</p> <p>def launch_setup(context, args, *kwargs):</p> <p>output_topic= LaunchConfiguration(\"output_topic\").perform(context)</p> <p>image_name = LaunchConfiguration(\"input_image\").perform(context)   camera_container_name = LaunchConfiguration(\"camera_container_name\").perform(context)   camera_namespace = \"/lucid_vision/\" + image_name</p> <p># tensorrt params   gpu_id = int(LaunchConfiguration(\"gpu_id\").perform(context))   mode = LaunchConfiguration(\"mode\").perform(context)   calib_image_directory = FindPackageShare(\"tensorrt_yolo\").perform(context) + \"/calib_image/\"   tensorrt_config_path = FindPackageShare('tensorrt_yolo').perform(context)+ \"/config/\" + LaunchConfiguration(\"yolo_type\").perform(context) + \".param.yaml\"</p> <p>with open(tensorrt_config_path, \"r\") as f:       tensorrt_yaml_param = yaml.safe_load(f)[\"/**\"][\"ros__parameters\"]</p> <p>camera_param_path=FindPackageShare(\"lucid_vision_driver\").perform(context)+\"/param/\"+image_name+\".param.yaml\"   with open(camera_param_path, \"r\") as f:     camera_yaml_param = yaml.safe_load(f)[\"/**\"][\"ros__parameters\"]</p> <p>container = ComposableNodeContainer(     name=camera_container_name,     namespace=\"/perception/object_detection\",     package=\"rclcpp_components\",     executable=LaunchConfiguration(\"container_executable\"),     output=\"screen\",     composable_node_descriptions=[         ComposableNode(             package=\"lucid_vision_driver\",             plugin=\"ArenaCameraNode\",             name=\"arena_camera_node\",             parameters=[{                 \"camera_name\": camera_yaml_param['camera_name'],                 \"frame_id\": camera_yaml_param['frame_id'],                 \"pixel_format\": camera_yaml_param['pixel_format'],                 \"serial_no\": camera_yaml_param['serial_no'],                 \"camera_info_url\": camera_yaml_param['camera_info_url'],                 \"fps\": camera_yaml_param['fps'],                 \"horizontal_binning\": camera_yaml_param['horizontal_binning'],                 \"vertical_binning\": camera_yaml_param['vertical_binning'],                 \"use_default_device_settings\": camera_yaml_param['use_default_device_settings'],                 \"exposure_auto\": camera_yaml_param['exposure_auto'],                 \"exposure_target\": camera_yaml_param['exposure_target'],                 \"gain_auto\": camera_yaml_param['gain_auto'],                 \"gain_target\": camera_yaml_param['gain_target'],                 \"gamma_target\": camera_yaml_param['gamma_target'],                 \"enable_compressing\": camera_yaml_param['enable_compressing'],                 \"enable_rectifying\": camera_yaml_param['enable_rectifying'],             }],             remappings=[             ],             extra_arguments=[                 {\"use_intra_process_comms\": LaunchConfiguration(\"use_intra_process\")}             ],         ),</p> <pre><code>    ComposableNode(\n        namespace='/perception/object_recognition/detection',\n        package=\"tensorrt_yolo\",\n        plugin=\"object_recognition::TensorrtYoloNodelet\",\n        name=\"tensorrt_yolo\",\n        parameters=[\n            {\n                \"mode\": mode,\n                \"gpu_id\": gpu_id,\n                \"onnx_file\": FindPackageShare(\"tensorrt_yolo\").perform(context) +  \"/data/\" + LaunchConfiguration(\"yolo_type\").perform(context) + \".onnx\",\n                \"label_file\": FindPackageShare(\"tensorrt_yolo\").perform(context) + \"/data/\" + LaunchConfiguration(\"label_file\").perform(context),\n                \"engine_file\": FindPackageShare(\"tensorrt_yolo\").perform(context) + \"/data/\"+ LaunchConfiguration(\"yolo_type\").perform(context) + \".engine\",\n                \"calib_image_directory\": calib_image_directory,\n                \"calib_cache_file\": FindPackageShare(\"tensorrt_yolo\").perform(context) + \"/data/\" + LaunchConfiguration(\"yolo_type\").perform(context) + \".cache\",\n                \"num_anchors\": tensorrt_yaml_param['num_anchors'],\n                \"anchors\": tensorrt_yaml_param['anchors'],\n                \"scale_x_y\": tensorrt_yaml_param['scale_x_y'],\n                \"score_threshold\": tensorrt_yaml_param['score_threshold'],\n                \"iou_thresh\": tensorrt_yaml_param['iou_thresh'],\n                \"detections_per_im\": tensorrt_yaml_param['detections_per_im'],\n                \"use_darknet_layer\": tensorrt_yaml_param['use_darknet_layer'],\n                \"ignore_thresh\": tensorrt_yaml_param['ignore_thresh'],\n            }\n        ],\n        remappings=[\n            (\"in/image\", camera_namespace + \"/image_rect\"),\n            (\"out/objects\", output_topic),\n            (\"out/image\", output_topic + \"/debug/image\"),\n        ],\n        extra_arguments=[\n            {\"use_intra_process_comms\": LaunchConfiguration(\"use_intra_process\")}\n        ],\n    ),\n],\n</code></pre> <p>)   return [container]</p> <p>def generate_launch_description(): launch_arguments = []</p> <pre><code>def add_launch_arg(name: str, default_value=None, description=None):\n    # a default_value of None is equivalent to not passing that kwarg at all\n    launch_arguments.append(\n        DeclareLaunchArgument(name, default_value=default_value, description=description)\n    )\nadd_launch_arg(\"mode\",\"\")\nadd_launch_arg(\"input_image\",\"\", description=\"input camera topic\")\nadd_launch_arg(\"camera_container_name\",\"\")\nadd_launch_arg(\"yolo_type\",\"\", description=\"yolo model type\")\nadd_launch_arg(\"label_file\",\"\" ,description=\"tensorrt node label file\")\nadd_launch_arg(\"gpu_id\",\"\", description=\"gpu setting\")\nadd_launch_arg(\"use_intra_process\", \"\", \"use intra process\")\nadd_launch_arg(\"use_multithread\", \"\", \"use multithread\")\n\nset_container_executable = SetLaunchConfiguration(\n    \"container_executable\",\n    \"component_container\",\n    condition=UnlessCondition(LaunchConfiguration(\"use_multithread\")),\n)\n\nset_container_mt_executable = SetLaunchConfiguration(\n    \"container_executable\",\n    \"component_container_mt\",\n    condition=IfCondition(LaunchConfiguration(\"use_multithread\")),\n)\n\nreturn launch.LaunchDescription(\n    launch_arguments\n    + [set_container_executable, set_container_mt_executable]\n    + [OpaqueFunction(function=launch_setup)]\n)\n\n```\n</code></pre> <p>The important points for creating <code>camera_node_container.launch.py</code> if you decided to use container for 2D detection pipeline are:</p> <ul> <li>Please be careful with design, if you are using multiple cameras, the design must be adaptable for this</li> <li>The tensorrt_yolo node input expects rectified image as input, so if your sensor_driver doesn't support image rectification, you can use <code>image_proc</code> package.<ul> <li>You can add something like this in your pipeline for getting rectifying image:</li> </ul> </li> </ul> <pre><code>        ...\n        ComposableNode(\n        namespace=camera_ns,\n        package='image_proc',\n        plugin='image_proc::RectifyNode',\n        name='rectify_camera_image_node',\n        # Remap subscribers and publishers\n        remappings=[\n        ('image', camera_ns+\"/image\"),\n        ('camera_info', input_camera_info),\n        ('image_rect', 'image_rect')\n        ],\n        extra_arguments=[\n        {\"use_intra_process_comms\": LaunchConfiguration(\"use_intra_process\")}\n        ],\n        ),\n        ...\n</code></pre> <ul> <li>Since lucid_vision_driver supports image_rectification, there is no need to add image_proc for tutorial_vehicle.</li> <li>Please be careful with namespace,   for example, we will use <code>/perception/object_detection</code> as tensorrt_yolo node namespace,   it will be explained in autoware usage section.   For more information,   please check image_projection_based_fusion package.</li> </ul> <p>After the preparing <code>camera_node_container.launch.py</code> to our forked <code>common_sensor_launch</code> package, we need to build the package:</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-up-to common_sensor_launch\n</code></pre> <p>Next, we will add camera_node_container.launch.py to <code>camera.launch.xml</code>, we must define necessary tensorrt_yolo parameters like this:</p> <pre><code>+  &lt;!--    common parameters --&gt;\n+  &lt;arg name=\"image_0\" default=\"camera_0\" description=\"image raw topic name\"/&gt;\n+  &lt;arg name=\"image_1\" default=\"camera_1\" description=\"image raw topic name\"/&gt;\n  ...\n\n+  &lt;!--    tensorrt params --&gt;\n+  &lt;arg name=\"mode\" default=\"FP32\"/&gt;\n+  &lt;arg name=\"yolo_type\" default=\"yolov3\" description=\"choose image raw number(0-7)\"/&gt;\n+  &lt;arg name=\"label_file\" default=\"coco.names\" description=\"yolo label file\"/&gt;\n+  &lt;arg name=\"gpu_id\" default=\"0\" description=\"choose your gpu id for inference\"/&gt;\n+  &lt;arg name=\"use_intra_process\" default=\"true\"/&gt;\n+  &lt;arg name=\"use_multithread\" default=\"true\"/&gt;\n</code></pre> <p>Then, launch camera nodes with these arguments, if you have two or more cameras, you can include it also like this:</p> <pre><code>+  &lt;group&gt;\n+    &lt;push-ros-namespace namespace=\"camera\"/&gt;\n+    &lt;include file=\"$(find-pkg-share common_sensor_launch)/launch/camera_node_container.launch.py\"&gt;\n+      &lt;arg name=\"mode\" value=\"$(var mode)\"/&gt;\n+      &lt;arg name=\"input_image\" value=\"$(var image_0)\"/&gt;\n+      &lt;arg name=\"camera_container_name\" value=\"front_camera_container\"/&gt;\n+      &lt;arg name=\"yolo_type\" value=\"$(var yolo_type)\"/&gt;\n+      &lt;arg name=\"label_file\" value=\"$(var label_file)\"/&gt;\n+      &lt;arg name=\"gpu_id\" value=\"$(var gpu_id)\"/&gt;\n+      &lt;arg name=\"use_intra_process\" value=\"$(var use_intra_process)\"/&gt;\n+      &lt;arg name=\"use_multithread\" value=\"$(var use_multithread)\"/&gt;\n+      &lt;arg name=\"output_topic\" value=\"camera0/rois0\"/&gt;\n+    &lt;/include&gt;\n+    &lt;include file=\"$(find-pkg-share common_sensor_launch)/launch/camera_node_container.launch.py\"&gt;\n+      &lt;arg name=\"mode\" value=\"$(var mode)\"/&gt;\n+      &lt;arg name=\"input_image\" value=\"$(var image_1)\"/&gt;\n+      &lt;arg name=\"camera_container_name\" value=\"front_camera_container\"/&gt;\n+      &lt;arg name=\"yolo_type\" value=\"$(var yolo_type)\"/&gt;\n+      &lt;arg name=\"label_file\" value=\"$(var label_file)\"/&gt;\n+      &lt;arg name=\"gpu_id\" value=\"$(var gpu_id)\"/&gt;\n+      &lt;arg name=\"use_intra_process\" value=\"$(var use_intra_process)\"/&gt;\n+      &lt;arg name=\"use_multithread\" value=\"$(var use_multithread)\"/&gt;\n+      &lt;arg name=\"output_topic\" value=\"camera1/rois1\"/&gt;\n+    &lt;/include&gt;\n+    ...\n+  &lt;/group&gt;\n</code></pre> <p>Since there is one camera for tutorial_vehicle, the <code>camera.launch.xml</code> should be like this:</p> <code>camera.launch.xml</code> for tutorial_vehicle <pre><code>&lt;launch&gt;\n&lt;arg name=\"launch_driver\" default=\"true\"/&gt;\n&lt;!--    common parameters --&gt;\n&lt;arg name=\"image_0\" default=\"camera_0\" description=\"image raw topic name\"/&gt;\n\n&lt;!--    tensorrt params --&gt;\n&lt;arg name=\"mode\" default=\"FP32\"/&gt;\n&lt;arg name=\"yolo_type\" default=\"yolov3\" description=\"choose image raw number(0-7)\"/&gt;\n&lt;arg name=\"label_file\" default=\"coco.names\" description=\"choose image raw number(0-7)\"/&gt;\n&lt;arg name=\"gpu_id\" default=\"0\" description=\"choose image raw number(0-7)\"/&gt;\n&lt;arg name=\"use_intra_process\" default=\"true\"/&gt;\n&lt;arg name=\"use_multithread\" default=\"true\"/&gt;\n\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"camera\"/&gt;\n&lt;include file=\"$(find-pkg-share common_sensor_launch)/launch/camera_node_container.launch.py\"&gt;\n&lt;arg name=\"mode\" value=\"$(var mode)\"/&gt;\n&lt;arg name=\"input_image\" value=\"$(var image_0)\"/&gt;\n&lt;arg name=\"camera_container_name\" value=\"front_camera_container\"/&gt;\n&lt;arg name=\"yolo_type\" value=\"$(var yolo_type)\"/&gt;\n&lt;arg name=\"label_file\" value=\"$(var label_file)\"/&gt;\n&lt;arg name=\"gpu_id\" value=\"$(var gpu_id)\"/&gt;\n&lt;arg name=\"use_intra_process\" value=\"$(var use_intra_process)\"/&gt;\n&lt;arg name=\"use_multithread\" value=\"$(var use_multithread)\"/&gt;\n&lt;arg name=\"output_topic\" value=\"camera0/rois0\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n&lt;/launch&gt;\n</code></pre> <p>You can check 2D detection pipeline with launching camera.launch.xml, but we need to build the driver and tensorrt_yolo package first. We will add our sensor driver to sensor_kit_launch's <code>package.xml</code> dependencies.</p> <pre><code>+ &lt;exec_depend&gt;&lt;YOUR-CAMERA-DRIVER-PACKAGE&gt;&lt;/exec_depend&gt;\n(optionally, if you will launch tensorrt_yolo at here)\n+ &lt;exec_depend&gt;tensorrt_yolo&lt;/exec_depend&gt;\n</code></pre> <p>Build necessary packages with:</p> <pre><code>cd &lt;YOUR-AUTOWARE-DIR&gt;\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-up-to common_sensor_launch &lt;YOUR-VEHICLE-NAME&gt;_sensor_kit_launch\n</code></pre> <p>Then, you can test your camera pipeline:</p> <pre><code>ros2 launch &lt;YOUR-SENSOR-KIT-LAUNCH&gt; camera.launch.xml\n# example for tutorial_vehicle: ros2 launch tutorial_vehicle_sensor_kit_launch camera.launch.xml\n</code></pre> <p>Then the rois topics will appear, you can check debug image with rviz2 or rqt.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#gnssins-launching","title":"GNSS/INS Launching","text":"<p>We will set up the GNSS/INS sensor launches at <code>gnss.launch.xml</code>. The default GNSS sensor options at <code>sample_sensor_kit_launch</code> for u-blox and septentrio is included in <code>gnss.launch.xml</code>, so If we use other sensors as GNSS/INS receiver, we need to add it here. Moreover, gnss_poser package launches here, we will use this package for the pose source of our vehicle at localization initialization but remember, your sensor_driver must provide autoware gnss orientation message for this node. If you are ready with your GNSS/INS driver, you must set <code>navsatfix_topic_name</code> and <code>orientation_topic_name</code> variables at this launch file for gnss_poser arguments. For Example, necessary modifications for  should be like this:</p> <pre><code>  ...\n- &lt;arg name=\"gnss_receiver\" default=\"ublox\" description=\"ublox(default) or septentrio\"/&gt;\n+ &lt;arg name=\"gnss_receiver\" default=\"&lt;YOUR-GNSS-SENSOR&gt;\" description=\"ublox(default), septentrio or &lt;YOUR-GNSS-SENSOR&gt;\"/&gt;\n\n &lt;group&gt;\n    &lt;push-ros-namespace namespace=\"gnss\"/&gt;\n\n    &lt;!-- Switch topic name --&gt;\n    &lt;let name=\"navsatfix_topic_name\" value=\"ublox/nav_sat_fix\" if=\"$(eval &amp;quot;'$(var gnss_receiver)'=='ublox'&amp;quot;)\"/&gt;\n    &lt;let name=\"navsatfix_topic_name\" value=\"septentrio/nav_sat_fix\" if=\"$(eval &amp;quot;'$(var gnss_receiver)'=='septentrio'&amp;quot;)\"/&gt;\n+   &lt;let name=\"navsatfix_topic_name\" value=\"&lt;YOUR-SENSOR&gt;/nav_sat_fix\" if=\"$(eval &amp;quot;'$(var gnss_receiver)'=='&lt;YOUR-GNSS-SENSOR&gt;'&amp;quot;)\"/&gt;\n   &lt;let name=\"orientation_topic_name\" value=\"/autoware_orientation\"/&gt;\n\n    ...\n\n+   &lt;!-- YOUR GNSS Driver --&gt;\n+   &lt;group if=\"$(eval &amp;quot;'$(var launch_driver)' and '$(var gnss_receiver)'=='&lt;YOUR-GNSS-SENSOR&gt;'&amp;quot;)\"&gt;\n+     &lt;include file=\"$(find-pkg-share &lt;YOUR-GNSS-SENSOR-DRIVER-PKG&gt;)/launch/&lt;YOUR-GNSS-SENSOR&gt;.launch.xml\"/&gt;\n+   &lt;/group&gt;\n   ...\n-   &lt;arg name=\"gnss_frame\" value=\"gnss_link\"/&gt;\n+   &lt;arg name=\"gnss_frame\" value=\"&lt;YOUR-GNSS-SENSOR-FRAME&gt;\"/&gt;\n   ...\n</code></pre> <p>Also, you can remove dependencies and unused sensor launch files at <code>gnss.launch.xml</code>. For example, we will use Clap B7 sensor as a GNSS/INS and IMU sensor, and we will use nrtip_client_ros for RTK. Also, we will add these packages to autoware.repos file.</p> <pre><code>+ sensor_component/external/clap_b7_driver:\n+   type: git\n+   url: https://github.com/Robeff-Technology/clap_b7_driver.git\n+   version: release/autoware\n+ sensor_component/external/ntrip_client_ros :\n+   type: git\n+   url: https://github.com/Robeff-Technology/ntrip_client_ros.git\n+   version: release/humble\n</code></pre> <p>So, our <code>gnss.launch.xml</code> for tutorial vehicle should be like this file (Clap B7 includes IMU also, so we will add imu_corrector at this file):</p> <code>gnss.launch.xml</code> for tutorial_vehicle <pre><code>&lt;launch&gt;\n&lt;arg name=\"launch_driver\" default=\"true\"/&gt;\n\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"gnss\"/&gt;\n\n&lt;!-- Switch topic name --&gt;\n&lt;let name=\"navsatfix_topic_name\" value=\"/clap/ros/gps_nav_sat_fix\"/&gt;\n&lt;let name=\"orientation_topic_name\" value=\"/clap/autoware_orientation\"/&gt;\n\n&lt;!-- CLAP GNSS Driver --&gt;\n&lt;group if=\"$(eval &amp;quot;'$(var launch_driver)'\"&gt;\n&lt;node pkg=\"clap_b7_driver\" exec=\"clap_b7_driver_node\" name=\"clap_b7_driver\" output=\"screen\"&gt;\n&lt;param from=\"$(find-pkg-share clap_b7_driver)/config/clap_b7_driver.param.yaml\"/&gt;\n&lt;/node&gt;\n&lt;!-- ntrip Client --&gt;\n&lt;include file=\"$(find-pkg-share ntrip_client_ros)/launch/ntrip_client_ros.launch.py\"/&gt;\n&lt;/group&gt;\n\n&lt;!-- NavSatFix to MGRS Pose --&gt;\n&lt;include file=\"$(find-pkg-share autoware_gnss_poser)/launch/gnss_poser.launch.xml\"&gt;\n&lt;arg name=\"input_topic_fix\" value=\"$(var navsatfix_topic_name)\"/&gt;\n&lt;arg name=\"input_topic_orientation\" value=\"$(var orientation_topic_name)\"/&gt;\n\n&lt;arg name=\"output_topic_gnss_pose\" value=\"pose\"/&gt;\n&lt;arg name=\"output_topic_gnss_pose_cov\" value=\"pose_with_covariance\"/&gt;\n&lt;arg name=\"output_topic_gnss_fixed\" value=\"fixed\"/&gt;\n\n&lt;arg name=\"use_gnss_ins_orientation\" value=\"true\"/&gt;\n&lt;!-- Please enter your gnss frame here --&gt;\n&lt;arg name=\"gnss_frame\" value=\"GNSS_INS/gnss_ins_link\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n\n&lt;!-- IMU corrector --&gt;\n&lt;group&gt;\n&lt;push-ros-namespace namespace=\"imu\"/&gt;\n&lt;include file=\"$(find-pkg-share imu_corrector)/launch/imu_corrector.launch.xml\"&gt;\n&lt;arg name=\"input_topic\" value=\"/sensing/gnss/clap/ros/imu\"/&gt;\n&lt;arg name=\"output_topic\" value=\"imu_data\"/&gt;\n&lt;arg name=\"param_file\" value=\"$(find-pkg-share individual_params)/config/$(var vehicle_id)/robione_sensor_kit/imu_corrector.param.yaml\"/&gt;\n&lt;/include&gt;\n&lt;include file=\"$(find-pkg-share imu_corrector)/launch/gyro_bias_estimator.launch.xml\"&gt;\n&lt;arg name=\"input_imu_raw\" value=\"/sensing/gnss/clap/ros/imu\"/&gt;\n&lt;arg name=\"input_twist\" value=\"/sensing/vehicle_velocity_converter/twist_with_covariance\"/&gt;\n&lt;arg name=\"imu_corrector_param_file\" value=\"$(find-pkg-share individual_params)/config/$(var vehicle_id)/robione_sensor_kit/imu_corrector.param.yaml\"/&gt;\n&lt;/include&gt;\n&lt;/group&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-sensor-model/#imu-launching","title":"IMU Launching","text":"<p>You can add your IMU sensor launch file at <code>imu.launch.xml</code> file. At the sample_sensor_kit, there is Tamagawa IMU sensor used as a IMU sensor. You can add your IMU driver instead of the Tamagawa IMU driver. Also, we will launch gyro_bias_estimator and imu_corrector at <code>imu.launch.xml</code> file. Please refer these documentations for more information (We added imu_corrector and gyro_bias_estimator at gnss.launch.xml at tutorial_vehicle, so we will not create and use <code>imu.launch.xml</code> for tutorial_vehicle). Please don't forget changing <code>imu_raw_name</code> argument for describing the raw imu topic.</p> <p>Here is a sample <code>imu.launch.xml</code> launch file for autoware:</p> <pre><code>&lt;launch&gt;\n  &lt;arg name=\"launch_driver\" default=\"true\"/&gt;\n\n  &lt;group&gt;\n    &lt;push-ros-namespace namespace=\"imu\"/&gt;\n\n-     &lt;group&gt;\n-       &lt;push-ros-namespace namespace=\"tamagawa\"/&gt;\n-       &lt;node pkg=\"tamagawa_imu_driver\" name=\"tag_serial_driver\" exec=\"tag_serial_driver\" if=\"$(var launch_driver)\"&gt;\n-         &lt;remap from=\"imu/data_raw\" to=\"imu_raw\"/&gt;\n-         &lt;param name=\"port\" value=\"/dev/imu\"/&gt;\n-         &lt;param name=\"imu_frame_id\" value=\"tamagawa/imu_link\"/&gt;\n-       &lt;/node&gt;\n-     &lt;/group&gt;\n\n+     &lt;group&gt;\n+       &lt;push-ros-namespace namespace=\"&lt;YOUR-IMU_MODEL&gt;\"/&gt;\n+       &lt;node pkg=\"&lt;YOUR-IMU-DRIVER-PACKAGE&gt;\" name=\"&lt;YOUR-IMU-DRIVER&gt;\" exec=\"&lt;YOUR-IMU-DRIVER-EXECUTIBLE&gt;\" if=\"$(var launch_driver)\"&gt;\n+       &lt;!-- Add necessary params here --&gt;\n+       &lt;/node&gt;\n+     &lt;/group&gt;\n\n-   &lt;arg name=\"imu_raw_name\" default=\"tamagawa/imu_raw\"/&gt;\n+   &lt;arg name=\"imu_raw_name\" default=\"&lt;YOUR-IMU_MODEL/YOUR-RAW-IMU-TOPIC&gt;\"/&gt;\n   &lt;arg name=\"imu_corrector_param_file\" default=\"$(find-pkg-share individual_params)/config/$(var vehicle_id)/sample_sensor_kit/imu_corrector.param.yaml\"/&gt;\n    &lt;include file=\"$(find-pkg-share imu_corrector)/launch/imu_corrector.launch.xml\"&gt;\n      &lt;arg name=\"input_topic\" value=\"$(var imu_raw_name)\"/&gt;\n      &lt;arg name=\"output_topic\" value=\"imu_data\"/&gt;\n      &lt;arg name=\"param_file\" value=\"$(var imu_corrector_param_file)\"/&gt;\n    &lt;/include&gt;\n\n    &lt;include file=\"$(find-pkg-share imu_corrector)/launch/gyro_bias_estimator.launch.xml\"&gt;\n      &lt;arg name=\"input_imu_raw\" value=\"$(var imu_raw_name)\"/&gt;\n      &lt;arg name=\"input_twist\" value=\"/sensing/vehicle_velocity_converter/twist_with_covariance\"/&gt;\n      &lt;arg name=\"imu_corrector_param_file\" value=\"$(var imu_corrector_param_file)\"/&gt;\n    &lt;/include&gt;\n  &lt;/group&gt;\n&lt;/launch&gt;\n</code></pre> <p>Please make necessary modifications on this file according to your IMU driver. Since there is no dedicated IMU sensor on tutorial_vehicle, we will remove their launch in <code>sensing.launch.xml</code>.</p> <pre><code>-   &lt;!-- IMU Driver --&gt;\n-   &lt;include file=\"$(find-pkg-share tutorial_vehicle_sensor_kit_launch)/launch/imu.launch.xml\"&gt;\n-     &lt;arg name=\"launch_driver\" value=\"$(var launch_driver)\"/&gt;\n-   &lt;/include&gt;\n</code></pre> <p>You can add or remove launch files in <code>sensing.launch.xml</code> according to your sensor architecture.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/","title":"Creating a vehicle model for Autoware","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#creating-a-vehicle-model-for-autoware","title":"Creating a vehicle model for Autoware","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#introduction","title":"Introduction","text":"<p>This page introduces the following packages for the vehicle model:</p> <ol> <li><code>&lt;YOUR-VEHICLE-NAME&gt;_vehicle_description</code></li> <li><code>&lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch</code></li> </ol> <p>Previously, we forked our vehicle model at the creating autoware repositories page step. For instance, we created tutorial_vehicle_launch as an implementation example for the said step. Please ensure that the _vehicle_launch repository is included in Autoware, following the directory structure below:</p> <pre><code>&lt;YOUR-OWN-AUTOWARE-DIR&gt;/\n  \u2514\u2500 src/\n       \u2514\u2500 vehicle/\n            \u2514\u2500 &lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch/\n                 \u251c\u2500 &lt;YOUR-VEHICLE-NAME&gt;_vehicle_description/\n                 \u2514\u2500 &lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch/\n</code></pre> <p>If your forked Autoware meta-repository doesn't include <code>&lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch</code> with the correct folder structure as shown above, please add your forked <code>&lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch</code> repository to the autoware.repos file and run the vcs import src &lt; autoware.repos command in your terminal to import the newly included repositories at autoware.repos file.</p> <p>Now, we are ready to modify the following vehicle model packages for our vehicle. Firstly, we need to rename the description and launch packages:</p> <pre><code>&lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch/\n- \u251c\u2500 sample_vehicle_description/\n+ \u251c\u2500 &lt;YOUR-VEHICLE-NAME&gt;_vehicle_description/\n- \u2514\u2500 sample_vehicle_launch/\n+ \u2514\u2500 &lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch/\n</code></pre> <p>After that, we will change our package names in the package.xml file and CMakeLists.txt file of the sample_vehicle_description and sample_vehicle_launch packages. So, open the package.xml file and CMakeLists.txt file with any text editor or IDE of your preference and perform the following changes:</p> <p>Change the <code>&lt;name&gt;</code> attribute at <code>package.xml</code> file:</p> <pre><code>&lt;package format=\"3\"&gt;\n- &lt;name&gt;sample_vehicle_description&lt;/name&gt;\n+ &lt;name&gt;&lt;YOUR-VEHICLE-NAME&gt;_vehicle_description&lt;/name&gt;\n &lt;version&gt;0.1.0&lt;/version&gt;\n  &lt;description&gt;The vehicle_description package&lt;/description&gt;\n  ...\n  ...\n</code></pre> <p>Change the <code>project()</code> method at <code>CmakeList.txt</code> file.</p> <pre><code>  cmake_minimum_required(VERSION 3.5)\n- project(sample_vehicle_description)\n+ project(&lt;YOUR-VEHICLE-NAME&gt;_vehicle_description)\n\n find_package(ament_cmake_auto REQUIRED)\n...\n...\n</code></pre> <p>Remember to apply the name changes and project method for BOTH <code>&lt;YOUR-VEHICLE-NAME&gt;_vehicle_description</code>and <code>&lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch</code> ROS 2 packages. Once finished, we can proceed to build said packages:</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-up-to &lt;YOUR-VEHICLE-NAME&gt;_vehicle_description &lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#vehicle-description","title":"Vehicle description","text":"<p>The main purpose of this package is to describe the vehicle dimensions, 3D model of the vehicle, mirror_dimensions of the vehicle, simulator model parameters and URDF of the vehicle.</p> <p>The folder structure of vehicle_description package is:</p> <pre><code>&lt;YOUR-VEHICLE-NAME&gt;_vehicle_description/\n   \u251c\u2500 config/\n   \u2502     \u251c\u2500 mirror.param.yaml\n   \u2502     \u251c\u2500 simulator_model.param.yaml\n   \u2502     \u2514\u2500 vehicle_info.param.yaml\n   \u251c\u2500 mesh/\n   \u2502     \u251c\u2500 &lt;YOUR-VEHICLE-MESH-FILE&gt;.dae (or .fbx)\n   \u2502     \u251c\u2500 ...\n   \u2514\u2500 urdf/\n         \u2514\u2500 vehicle.xacro\n</code></pre> <p>Now, we will modify these files according to our vehicle design.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#mirrorparamyaml","title":"mirror.param.yaml","text":"<p>This file describes your vehicle mirror dimension for CropBox filter of PointCloudPreprocessor. This is important for cropping mirrors from your lidar's point cloud.</p> <p>The <code>mirror.param.yaml</code> consist of the following parameters:</p> <pre><code>/**:\nros__parameters:\nmin_longitudinal_offset: 0.0\nmax_longitudinal_offset: 0.0\nmin_lateral_offset: 0.0\nmax_lateral_offset: 0.0\nmin_height_offset: 0.0\nmax_height_offset: 0.0\n</code></pre> <p>The mirror param file should be filled with this dimension information, please be careful with <code>min_lateral_offset</code>parameter, it could be negative value like the mirror dimension figure below.</p> <p> </p>      Dimension demonstration for mirror.param.yaml    <p>Warning</p> <p>Since there is no mirror in <code>tutorial_vehicle</code>, all values set to 0.0. If your vehicle does not have mirror, you can set these values 0.0 as well.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#simulator_modelparamyaml","title":"simulator_model.param.yaml","text":"<p>This file is a configuration file for the simulator environment. Please update these parameters according to your vehicle specifications. For detailed information about variables, please check the simple_planning_simulator package. The file consists of these parameters:</p> <pre><code>/**:\nros__parameters:\nsimulated_frame_id: \"base_link\" # center of the rear axle.\norigin_frame_id: \"map\"\nvehicle_model_type: \"DELAY_STEER_ACC_GEARED\" # options: IDEAL_STEER_VEL / IDEAL_STEER_ACC / IDEAL_STEER_ACC_GEARED / DELAY_STEER_ACC / DELAY_STEER_ACC_GEARED\ninitialize_source: \"INITIAL_POSE_TOPIC\" #  options: ORIGIN / INITIAL_POSE_TOPIC\ntimer_sampling_time_ms: 25\nadd_measurement_noise: False # the Gaussian noise is added to the simulated results\nvel_lim: 50.0 # limit of velocity\nvel_rate_lim: 7.0 # limit of acceleration\nsteer_lim: 1.0 # limit of steering angle\nsteer_rate_lim: 5.0 # limit of steering angle change rate\nacc_time_delay: 0.1 # dead time for the acceleration input\nacc_time_constant: 0.1 # time constant of the 1st-order acceleration dynamics\nsteer_time_delay: 0.24 # dead time for the steering input\nsteer_time_constant: 0.27 # time constant of the 1st-order steering dynamics\nx_stddev: 0.0001 # x standard deviation for dummy covariance in map coordinate\ny_stddev: 0.0001 # y standard deviation for dummy covariance in map coordinate\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#vehicle_infoparamyaml","title":"vehicle_info.param.yaml","text":"<p>This file stores the vehicle dimensions for Autoware modules. Please update it with your vehicle information. You can refer to the vehicle dimensions page for detailed dimension demonstration. Here is the <code>vehicle_info.param.yaml</code> for sample_vehicle:</p> <pre><code>/**:\nros__parameters:\nwheel_radius: 0.383 # The radius of the wheel, primarily used for dead reckoning.\nwheel_width: 0.235 # The lateral width of a wheel tire, primarily used for dead reckoning.\nwheel_base: 2.79 # between front wheel center and rear wheel center\nwheel_tread: 1.64 # between left wheel center and right wheel center\nfront_overhang: 1.0 # between front wheel center and vehicle front\nrear_overhang: 1.1 # between rear wheel center and vehicle rear\nleft_overhang: 0.128 # between left wheel center and vehicle left\nright_overhang: 0.128 # between right wheel center and vehicle right\nvehicle_height: 2.5\nmax_steer_angle: 0.70 # [rad]\n</code></pre> <p>Please update <code>vehicle_info.param.yaml</code> with your vehicle information.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#3d-model-of-vehicle","title":"3D model of vehicle","text":"<p>You can use .fbx or .dae format as a 3D model with autoware. For the tutorial_vehicle, we exported our 3D model as a .fbx file in the tutorial_vehicle_launch repository. We will set the .fbx file path at <code>vehicle.xacro</code> file.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#vehiclexacro","title":"vehicle.xacro","text":"<p>This .xacro file links the base_link of the vehicle to the 3D mesh. Therefore, we need to make some modifications in this file.</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot xmlns:xacro=\"http://ros.org/wiki/xacro\"&gt;\n  &lt;!-- load parameter --&gt;\n- &lt;xacro:property name=\"vehicle_info\" value=\"${xacro.load_yaml('$(find sample_vehicle_description)/config/vehicle_info.param.yaml')}\"/&gt;\n+ &lt;xacro:property name=\"vehicle_info\" value=\"${xacro.load_yaml('$(find &lt;YOUR-VEHICLE-NAME&gt;_vehicle_description)/config/vehicle_info.param.yaml')}\"/&gt;\n\n &lt;!-- vehicle body --&gt;\n  &lt;link name=\"base_link\"&gt;\n    &lt;visual&gt;\n      &lt;origin xyz=\"${vehicle_info['/**']['ros__parameters']['wheel_base']/2.0} 0 0\" rpy=\"${pi/2.0} 0 ${pi}\"/&gt;\n      &lt;geometry&gt;\n-       &lt;mesh filename=\"package://sample_vehicle_description/mesh/lexus.dae\" scale=\"1 1 1\"/&gt;\n+       &lt;mesh filename=\"package://&lt;YOUR-VEHICLE-NAME&gt;_vehicle_description/mesh/&lt;YOUR-3D-MESH-FILE&gt;\" scale=\"1 1 1\"/&gt;\n     &lt;/geometry&gt;\n    &lt;/visual&gt;\n  &lt;/link&gt;\n&lt;/robot&gt;\n</code></pre> <p>You can also modify roll, pitch, yaw, x, y, z and scale values for the correct position and orientation of the vehicle.</p> <p>Please build vehicle_description package after the completion of your _vehicle_description package.</p> <pre><code>cd &lt;YOUR-AUTOWARE-DIR&gt;\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-up-to &lt;YOUR-VEHICLE-NAME&gt;_vehicle_description &lt;YOUR-VEHICLE-NAME&gt;_vehicle_launch\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#launching-vehicle-interface","title":"Launching vehicle interface","text":"<p>If your vehicle interface is ready, then you can add your vehicle_interface launch file in <code>vehicle_interface.launch.xml</code>. Please check the creating vehicle interface page for more info.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-and-sensor-model/creating-vehicle-model/#launch-planning-simulator-with-your-own-vehicle","title":"Launch planning simulator with your own vehicle","text":"<p>After completing the sensor_model, individual_parameters and vehicle model of your vehicle, you are ready to launch the planning simulator with your own vehicle. If you are not sure if every custom package in your Autoware project folder is built, please build all packages:</p> <pre><code>cd &lt;YOUR-AUTOWARE-DIR&gt;\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>To launch the planning simulator, source the install/setup.bash file in your Autoware project folder and run this command in your terminal:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/Files/autoware_map/sample-map-planning/ vehicle_model:=&lt;YOUR-VEHICLE-MODEL&gt; sensor_model:=&lt;YOUR-SENSOR-KIT&gt; vehicle_id:=&lt;YOUR-VEHICLE-ID&gt;\n</code></pre> <p>For example, if we try planning simulator with the tutorial_vehicle:</p> <pre><code>ros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/Files/autoware_map/sample-map-planning/ vehicle_model:=tutorial_vehicle sensor_model:=tutorial_vehicle_sensor_kit vehicle_id:=tutorial_vehicle\n</code></pre> <p>The planning simulator will open, and you can give an initial pose to your vehicle using <code>2D Pose Estimate</code> button or by pressing the <code>P</code> key on your keyboard. You can click everywhere for vehicle initialization.</p> <p> </p>      Our tutorial_vehicle on rviz with TF data"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/ackermann-kinematic-model/","title":"Ackermann kinematic model","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/ackermann-kinematic-model/#ackermann-kinematic-model","title":"Ackermann kinematic model","text":"<p>Autoware now supports control inputs for vehicles based on an Ackermann kinematic model. This section introduces you a brief concept of the Ackermann kinematic model and explains how Autoware controls it. Please remember, Autoware control output (/control/command/control_cmd) publishes lateral and longitudinal commands according to the Ackermann kinematic model.</p> <ul> <li>If your vehicle does not suit the Ackermann kinematic model, you have to modify the control commands. Another document gives you an example how to convert your Ackermann kinematic model control inputs into a differential drive model.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/ackermann-kinematic-model/#geometry","title":"Geometry","text":"<p>The basic style of the Ackermann kinematic model has four wheels with an Ackermann link on the front, and it is powered by the rear wheels. The key point of Ackermann kinematic model is that the axes of all wheels intersect at the same point, which means all wheels will trace a circular trajectory with a different radii but a common center point (See the figure below). Therefore, this model has a great advantage that it minimizes the slippage of the wheels and prevents tires from getting worn soon.</p> <p>In general, the Ackermann kinematic model accepts the longitudinal speed \\(v\\) and the steering angle \\(\\phi\\) as inputs. In autoware, \\(\\phi\\) is positive if it is steered counterclockwise, so the steering angle in the figure below is actually negative.</p> <p> </p>      The basic style of an Ackermann kinematic model. The left figure shows a vehicle facing straight forward, while the right figure shows a vehicle steering to the right."},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/ackermann-kinematic-model/#control","title":"Control","text":"<p>Autoware publishes a ROS 2 topic named <code>control_cmd</code> from several types of publishers. A <code>control_cmd</code> topic is a <code>AckermannControlCommand</code> type message that contains</p> AckermannControlCommand<pre><code>  builtin_interfaces/Time stamp\n  autoware_auto_control_msgs/AckermannLateralCommand lateral\n  autoware_auto_control_msgs/LongitudinalCommand longitudinal\n</code></pre> <p>where,</p> AckermannLateralCommand<pre><code>  builtin_interfaces/Time stamp\n  float32 steering_tire_angle\n  float32 steering_tire_rotation_rate\n</code></pre> LongitudinalCommand<pre><code>  builtin_interfaces/Time stamp\n  float32 speed\n  float32 accelaration\n  float32 jerk\n</code></pre> <p>See the AckermannLateralCommand.idl and LongitudinalCommand.idl for details.</p> <p>The vehicle interface should realize these control commands through your vehicle's control device.</p> <p>Moreover, Autoware also provides brake commands, light commands, and more (see vehicle interface design), so the vehicle interface module should be applicable to these commands as long as there are devices available to handle them.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/creating-vehicle-interface/","title":"Creating vehicle interface","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/creating-vehicle-interface/#creating-vehicle-interface","title":"Creating vehicle interface","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/creating-vehicle-interface/#how-to-implement-a-vehicle-interface","title":"How to implement a vehicle interface","text":"<p>The following instructions describe how to create a vehicle interface.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/creating-vehicle-interface/#1-create-a-directory-for-vehicle-interface","title":"1. Create a directory for vehicle interface","text":"<p>It is recommended to create your vehicle interface at <code>&lt;your-autoware-dir&gt;/src/vehicle/external</code></p> <pre><code>cd &lt;your-autoware-dir&gt;/src/vehicle/external\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/creating-vehicle-interface/#2-install-or-implement-your-own-vehicle-interface","title":"2. Install or implement your own vehicle interface","text":"<p>If there is an already complete vehicle interface package (like <code>pacmod_interface</code>), you can install it to your environment. If not, you have to implement your own vehicle interface by yourself. Let's create a new package by <code>ros2 pkg create</code>. The following example will show you how to create a vehicle interface package named <code>my_vehicle_interface</code>.</p> <pre><code>ros2 pkg create --build-type ament_cmake my_vehicle_interface\n</code></pre> <p>Then, you should write your implementation of vehicle interface in <code>my_vehicle_interface/src</code>. Again, since this implementation is so specific to the control device of your vehicle, it is beyond the scope of this document to describe how to implement your vehicle interface in detail. Here are some factors that might be considered:</p> <ul> <li>Some necessary topic subscription of control commands topics from Autoware to control your vehicle:</li> </ul> Topic Name Topic Type Description /control/command/control_cmd autoware_auto_control_msgs/msg/AckermannControlCommand This topic includes main topics for controlling our vehicle like a steering tire angle, speed, acceleration, etc. /control/command/gear_cmd autoware_auto_vehicle_msgs/msg/GearCommand This topic includes gear command for autonomous driving, please check message values to make sense of gears values. Please check the message definition of this type. /control/current_gate_mode tier4_control_msgs/msg/GateMode This topic describes control on the autoware or not. Please check GateMode message type for detailed information. /control/command/emergency_cmd tier4_vehicle_msgs/msg/VehicleEmergencyStamped This topic sends emergency when autoware is on emergency state. Please check VehicleEmergencyStamped message type for detailed information. /control/command/turn_indicators_cmd autoware_auto_vehicle_msgs/msg/TurnIndicatorsCommand This topic indicates a turn signal for your own vehicle. Please check TurnIndicatorsCommand message type for detailed information. /control/command/hazard_lights_cmd autoware_auto_vehicle_msgs/msg/HazardLightsCommand This topic sends command for hazard lights. Please check HazardLightsCommand /control/command/actuation_cmd tier4_vehicle_msgs/msg/ActuationCommandStamped This topic is enabled when you use <code>raw_vehicle_command_converter</code> for control your vehicle with TYPE B which we mentioned at Vehicle interface section. In summary, if you are using Type B on your vehicle, this topic appeared and included with gas, brake, steering-wheel actuation commands. Please check ActuationCommandStamped message type for detailed information. etc. etc. etc. <ul> <li>Some necessary topic publication of vehicle status topics from vehicle interface to Autoware:</li> </ul> Topic Name Topic Type Description /vehicle/status/battery_charge tier4_vehicle_msgs/msg/BatteryStatus This topic includes battery information. Please check BatteryStatus message type for detailed information. You can use this value as describing fuel level, etc. /vehicle/status/control_mode autoware_auto_vehicle_msgs/msg/ControlModeReport This topic describes the current control mode of vehicle. Please check ControlModeReport message type for detailed information. /vehicle/status/gear_status autoware_auto_vehicle_msgs/msg/GearReport This topic includes the current gear status of the vehicle. Please check GearReport message type for detailed information. /vehicle/status/hazard_lights_status autoware_auto_vehicle_msgs/msg/HazardLightsReport This topic describes hazard light status of the vehicle. Please check HazardLightsReport message type for detailed information. /vehicle/status/turn_indicators_status autoware_auto_vehicle_msgs/msg/TurnIndicatorsReport This topic reports the steering status of the vehicle. Please check SteeringReport message type for detailed information. /vehicle/status/steering_status autoware_auto_vehicle_msgs/msg/SteeringReport This topic reports the steering status of the vehicle. Please check SteeringReport message type for detailed information. /vehicle/status/velocity_Status autoware_auto_vehicle_msgs/msg/VelocityReport This topic gives us the velocity status of the vehicle. Please check VelocityReport message type for detailed information. etc. etc. etc. <p>This diagram as an example for communication of vehicle interface and autoware with describing sample topics and message types.</p> <p> </p>      Sample demonstration of vehicle and autoware communication.     There are some topics and types included in this diagram and     it can be changed your desired control command or autoware updates.    <p>You must create a subscriber and publisher with these topics on your vehicle interface. Let's explain with the simple demonstration of subscribing <code>/control/command/control_cmd</code> and publishing <code>/vehicle/status/gear_status</code> topics.</p> <p>So, your <code>YOUR-OWN-VEHICLE-INTERFACE.hpp</code> header file should be like this:</p> <pre><code>...\n#include &lt;autoware_auto_control_msgs/msg/ackermann_control_command.hpp&gt;\n#include &lt;autoware_auto_vehicle_msgs/msg/gear_report.hpp&gt;\n...\n\nclass &lt;YOUR-OWN-INTERFACE&gt; : public rclcpp::Node\n{\npublic:\n...\nprivate:\n...\n// from autoware\nrclcpp::Subscription&lt;autoware_auto_control_msgs::msg::AckermannControlCommand&gt;::SharedPtr\ncontrol_cmd_sub_;\n...\n// from vehicle\nrclcpp::Publisher&lt;autoware_auto_vehicle_msgs::msg::GearReport&gt;::SharedPtr gear_status_pub_;\n...\n// autoware command messages\n...\nautoware_auto_control_msgs::msg::AckermannControlCommand::ConstSharedPtr control_cmd_ptr_;\n...\n// callbacks\n...\nvoid callback_control_cmd(\nconst autoware_auto_control_msgs::msg::AckermannControlCommand::ConstSharedPtr msg);\n...\nvoid to_vehicle();\nvoid from_vehicle();\n}\n</code></pre> <p>And your <code>YOUR-OWN-VEHICLE-INTERFACE.cpp</code> .cpp file should be like this:</p> <pre><code>#include &lt;YOUR-OWN-VEHICLE-INTERFACE&gt;/&lt;YOUR-OWN-VEHICLE-INTERFACE&gt;.hpp&gt;\n...\n\n&lt;YOUR-OWN-VEHICLE-INTERFACE&gt;::&lt;YOUR-OWN-VEHICLE-INTERFACE&gt;()\n: Node(\"&lt;YOUR-OWN-VEHICLE-INTERFACE&gt;\")\n{\n...\n/* subscribers */\nusing std::placeholders::_1;\n// from autoware\ncontrol_cmd_sub_ = create_subscription&lt;autoware_auto_control_msgs::msg::AckermannControlCommand&gt;(\n\"/control/command/control_cmd\", 1, std::bind(&amp;&lt;YOUR-OWN-VEHICLE-INTERFACE&gt;::callback_control_cmd, this, _1));\n...\n// to autoware\ngear_status_pub_ = create_publisher&lt;autoware_auto_vehicle_msgs::msg::GearReport&gt;(\n\"/vehicle/status/gear_status\", rclcpp::QoS{1});\n...\n}\n\nvoid &lt;YOUR-OWN-VEHICLE-INTERFACE&gt;::callback_control_cmd(\nconst autoware_auto_control_msgs::msg::AckermannControlCommand::ConstSharedPtr msg)\n{\ncontrol_cmd_ptr_ = msg;\n}\n\nvoid &lt;YOUR-OWN-VEHICLE-INTERFACE&gt;::to_vehicle()\n{\n...\n// you should implement this structure according to your own vehicle design\ncontrol_command_to_vehicle(control_cmd_ptr_);\n...\n}\n\nvoid &lt;YOUR-OWN-VEHICLE-INTERFACE&gt;::to_autoware()\n{\n...\n// you should implement this structure according to your own vehicle design\nautoware_auto_vehicle_msgs::msg::GearReport gear_report_msg;\nconvert_gear_status_to_autoware_msg(gear_report_msg);\ngear_status_pub_-&gt;publish(gear_report_msg);\n...\n}\n</code></pre> <ul> <li>Modification of control values if needed<ul> <li>In some cases, you may need to modify the control commands. For example, Autoware expects vehicle velocity information in m/s units, but if your vehicle publishes it in a different format (i.e., km/h), you must convert it before sending it to Autoware.</li> </ul> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/creating-vehicle-interface/#3-prepare-a-launch-file","title":"3. Prepare a launch file","text":"<p>After you implement your vehicle interface, or you want to debug it by launching it, create a launch file of your vehicle interface, and include it to <code>vehicle_interface.launch.xml</code> which included in <code>&lt;VEHICLE_ID&gt;_vehicle_launch</code> package that we forked and created at creating vehicle and sensor model page.</p> <p>Do not get confused. First, you need to create a launch file for your own vehicle interface module (like <code>my_vehicle_interface.launch.xml</code>) and then include that to <code>vehicle_interface.launch.xml</code> which exists in another directory. Here are the details.</p> <ol> <li> <p>Add a <code>launch</code> directory in the <code>my_vehicle_interface</code> directory, and create a launch file of your own vehicle interface in it. Take a look at Creating a launch file in the ROS 2 documentation.</p> </li> <li> <p>Include your launch file which is created for vehicle_interface to <code>&lt;YOUR-VEHICLE-NAME&gt;_launch/&lt;YOUR-VEHICLE-NAME&gt;_launch/launch/vehicle_interface.launch.xml</code> by opening it and add the included terms like below.</p> </li> </ol> vehicle_interface.launch.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n&lt;arg name=\"vehicle_id\" default=\"$(env VEHICLE_ID default)\"/&gt;\n&lt;!-- please add your created vehicle interface launch file --&gt;\n&lt;include file=\"$(find-pkg-share my_vehicle_interface)/launch/my_vehicle_interface.launch.xml\"&gt;\n&lt;/include&gt;\n&lt;/launch&gt;\n</code></pre> <p>Finally, your directory structure may look like below. Most of the files are omitted for clarity, but the files shown here needs modification as said in the previous and current process.</p> <pre><code>&lt;your-autoware-dir&gt;/\n\u2514\u2500 src/\n    \u2514\u2500 vehicle/\n        \u251c\u2500 external/\n+       \u2502   \u2514\u2500 &lt;YOUR-VEHICLE-NAME&gt;_interface/\n+       \u2502       \u251c\u2500 src/\n+       \u2502       \u2514\u2500 launch/\n+       \u2502            \u2514\u2500 my_vehicle_interface.launch.xml\n+       \u2514\u2500 &lt;YOUR-VEHICLE-NAME&gt;_launch/ (COPIED FROM sample_vehicle_launch)\n+           \u251c\u2500 &lt;YOUR-VEHICLE-NAME&gt;_launch/\n+           \u2502  \u251c\u2500 launch/\n+           \u2502  \u2502  \u2514\u2500 vehicle_interface.launch.xml\n+           \u2502  \u251c\u2500 CMakeLists.txt\n+           \u2502  \u2514\u2500 package.xml\n+           \u251c\u2500 &lt;YOUR-VEHICLE-NAME&gt;_description/\n+           \u2502  \u251c\u2500 config/\n+           \u2502  \u251c\u2500 mesh/\n+           \u2502  \u251c\u2500 urdf/\n+           \u2502  \u2502  \u2514\u2500 vehicle.xacro\n+           \u2502  \u251c\u2500 CMakeLists.txt\n+           \u2502  \u2514\u2500 package.xml\n+           \u2514\u2500 README.md\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/creating-vehicle-interface/#4-build-the-vehicle-interface-package-and-the-launch-package","title":"4. Build the vehicle interface package and the launch package","text":"<p>Build three packages <code>my_vehicle_interface</code>, <code>&lt;YOUR-VEHICLE-NAME&gt;_launch</code> and <code>&lt;YOUR-VEHICLE-NAME&gt;_description</code> by <code>colcon build</code>, or you can just build the entire Autoware if you have done other things.</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --packages-select my_vehicle_interface &lt;YOUR-VEHICLE-NAME&gt;_launch &lt;YOUR-VEHICLE-NAME&gt;_description\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/creating-vehicle-interface/#5-when-you-launch-autoware","title":"5. When you launch Autoware","text":"<p>Finally, you are done implementing your vehicle interface module! Be careful that you need to launch Autoware with the proper <code>vehicle_model</code> option like the example below. This example is launching planning simulator.</p> <pre><code>ros2 launch autoware_launch planning.launch.xml map_path:=$HOME/autoware_map/sample-map-planning vehicle_model:=&lt;YOUR-VEHICLE-NAME&gt; sensor_model:=&lt;YOUR-VEHICLE-NAME&gt;_sensor_kit\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/creating-vehicle-interface/#tips","title":"Tips","text":"<p>There are some tips that may help you.</p> <ul> <li> <p>You can subdivide your vehicle interface into smaller packages if you want. Then your directory structure may look like below (not the only way though). Do not forget to launch all packages in <code>my_vehicle_interface.launch.xml</code>.</p> <pre><code>&lt;your-autoware-dir&gt;/\n\u2514\u2500 src/\n    \u2514\u2500 vehicle/\n        \u251c\u2500 external/\n        \u2502   \u2514\u2500 my_vehicle_interface/\n        \u2502       \u251c\u2500 src/\n        \u2502       \u2502   \u251c\u2500 package1/\n        \u2502       \u2502   \u251c\u2500 package2/\n        \u2502       \u2502   \u2514\u2500 package3/\n        \u2502       \u2514\u2500 launch/\n        \u2502            \u2514\u2500 my_vehicle_interface.launch.xml\n        \u251c\u2500 sample_vehicle_launch/\n        \u2514\u2500 my_vehicle_name_launch/\n</code></pre> </li> </ul> <ul> <li> <p>If you are using a vehicle interface and launch package from a open git repository, or created your own as a git repository, it is highly recommended to add those repositories to your <code>autoware.repos</code> file which is located to directly under your autoware folder like the example below. You can specify the branch or commit hash by the version tag.</p> autoware.repos<pre><code># vehicle (this section should be somewhere in autoware.repos and add the below)\nvehicle/external/my_vehicle_interface:\ntype: git\nurl: https://github.com/&lt;repository-name-B&gt;/my_vehicle_interface.git\nversion: main\n</code></pre> <p>Then you can import your entire environment easily to another local device by using the <code>vcs import</code> command. (See the source installation guide)</p> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/customizing-for-differential-drive-model/","title":"Customizing for differential drive vehicle","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/customizing-for-differential-drive-model/#customizing-for-differential-drive-vehicle","title":"Customizing for differential drive vehicle","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/customizing-for-differential-drive-model/#1-introduction","title":"1. Introduction","text":"<p>Currently, Autoware assumes that vehicles use an Ackermann kinematic model with Ackermann steering. Thus, Autoware adopts the Ackermann command format for the Control module's output (see the AckermannDrive ROS message definition for an overview of Ackermann commands, and the AckermannControlCommands struct used in Autoware for more details).</p> <p>However, it is possible to integrate Autoware with a vehicle that follows a differential drive kinematic model, as commonly used by small mobile robots. The differential vehicles can be either four-wheel or two-wheel, as described in the figure below.</p> <p> </p>      Sample differential vehicles with four-wheel and two-wheel models."},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/customizing-for-differential-drive-model/#2-procedure","title":"2. Procedure","text":"<p>One simple way of using Autoware with a differential drive vehicle is to create a <code>vehicle_interface</code> package that translates Ackermann commands to differential drive commands. Here are two points that you need to consider:</p> <ul> <li>Create <code>vehicle_interface</code> package for differential drive vehicle</li> <li>Set an appropriate <code>wheel_base</code></li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/customizing-for-differential-drive-model/#21-create-a-vehicle_interface-package-for-differential-drive-vehicle","title":"2.1 Create a <code>vehicle_interface</code> package for differential drive vehicle","text":"<p>An Ackermann command in Autoware consists of two main control inputs:</p> <ul> <li>steering angle (\\(\\omega\\))</li> <li>velocity (\\(v\\))</li> </ul> <p>Conversely, a typical differential drive command consists of the following inputs:</p> <ul> <li>left wheel velocity (\\(v_l\\))</li> <li>right wheel velocity (\\(v_r\\))</li> </ul> <p>So, one way in which an Ackermann command can be converted to a differential drive command is by using the following equations:</p> \\[ v_l = v - \\frac{l\\omega}{2}, v_r = v + \\frac{l\\omega}{2} \\] <p>where \\(l\\) denotes wheel tread.</p> <p>Here is the example <code>.cpp</code> snippet for converting ackermann model kinematics to a differential model:</p> <pre><code>...\nvoid convert_ackermann_to_differential(\nautoware_auto_control_msgs::msg::AckermannControlCommand &amp; ackermann_msg\nmy_vehicle_msgs::msg::DifferentialCommand &amp; differential_command)\n{\ndifferential_command.left_wheel.velocity =\nackermann_msg.longitudinal.speed - (ackermann_msg.lateral.steering_tire_angle * my_wheel_tread) / 2;\ndifferential_command.right_wheel.velocity =\nackermann_msg.longitudinal.speed + (ackermann_msg.lateral.steering_tire_angle * my_wheel_tread) / 2;\n}\n...\n</code></pre> <p>For information about other factors that need to be considered when creating a <code>vehicle_interface</code> package, refer to the creating <code>vehicle_interface</code> page.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/customizing-for-differential-drive-model/#22-set-an-appropriate-wheel_base","title":"2.2 Set an appropriate <code>wheel_base</code>","text":"<p>A differential drive robot does not necessarily have front and rear wheels, which means that the wheelbase (the horizontal distance between the axles of the front and rear wheels) cannot be defined. However, Autoware expects <code>wheel_base</code> to be set in <code>vehicle_info.param.yaml</code> with some value. Thus, you need to set a pseudo value for <code>wheel_base</code>.</p> <p>The appropriate pseudo value for <code>wheel_base</code> depends on the size of your vehicle. Setting it to be the same value as <code>wheel_tread</code> is one possible choice.</p> <p>Warning</p> <ul> <li>If the <code>wheel_base</code> value is set too small then the vehicle may behave unexpectedly. For example, the vehicle may drive beyond the bounds of a calculated path.</li> <li>Conversely, if <code>wheel_base</code> is set too large, the vehicle's range of motion will be restricted. The reason being that Autoware's Planning module will calculate an overly conservative trajectory based on the assumed vehicle length.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/customizing-for-differential-drive-model/#3-known-issues","title":"3. Known issues","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/customizing-for-differential-drive-model/#motion-model-incompatibility","title":"Motion model incompatibility","text":"<p>Since Autoware assumes that vehicles use a steering system, it is not possible to take advantage of the flexibility of a differential drive system's motion model.</p> <p>For example, when planning a parking maneuver with the <code>freespace_planner</code> module, Autoware may drive the differential drive vehicle forward and backward, even if the vehicle can be parked with a simpler trajectory that uses pure rotational movement.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/vehicle-interface/","title":"Vehicle interface overview","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/vehicle-interface/#vehicle-interface","title":"Vehicle interface","text":""},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/vehicle-interface/#what-is-the-vehicle-interface","title":"What is the vehicle interface?","text":"<p>The purpose of the vehicle interface package is to convert the control messages calculated from the autoware into a form that the vehicle can understand and transmit them to the vehicle (CAN, Serial message, etc.) and to decode the data coming from the vehicle and publish it through the ROS 2 topics that the autoware expects. So, we can say that the purposes of the vehicle_interface are:</p> <ol> <li> <p>Converting Autoware control commands to a vehicle-specific format. Example control commands of autoware:</p> <ul> <li>lateral controls: steering tire angle, steering tire rotation rate</li> <li>longitudinal controls: speed, acceleration, jerk</li> </ul> </li> <li> <p>Converting vehicle status information in a vehicle-specific format to Autoware messages.</p> </li> </ol> <p>Autoware publishes control commands such as:</p> <ul> <li>Velocity control</li> <li>Steering control</li> <li>Car light commands</li> <li>etc.</li> </ul> <p>Then, the vehicle interface converts these commands into actuation such like:</p> <ul> <li>Motor and brake activation</li> <li>Steering-wheel operation</li> <li>Lighting control</li> <li>etc.</li> </ul> <p>So think of the vehicle interface as a module that runs the vehicle's control device to realize the input commands provided by Autoware.</p> <p> </p>      An example of inputs and outputs for vehicle interface    <p>There are two types of interfaces for controlling your own vehicle:</p> <ol> <li>Target steering and target velocity/acceleration interface. (It will be named as Type A for this document)</li> <li>Generalized target command interface (i.e., accel/brake pedal, steering torque). (It will be named as Type B for this document)</li> </ol> <p>For Type A, where the control interface encompasses target steering and target velocity/acceleration.</p> <ul> <li>So, at this type, speed control is occurred by desired velocity or acceleration.</li> <li>Steering control is occurred by desired steering angle and/or steering angle velocity.</li> </ul> <p>On the other hand, Type B, characterized by a generalized target command interface (e.g., accel/brake pedal, steering torque), introduces a more dynamic and adaptable control scheme. In this configuration, the vehicle controlled to direct input from autoware actuation commands which output of the <code>raw_vehicle_cmd_converter</code>, allowing for a more intuitive and human-like driving experience.</p> <p>If you use your own vehicle like this way (i.e., controlling gas and brake pedal), you need to use raw_vehicle_cmd_converter package to convert autoware output control cmd to brake, gas and steer map. In order to do that, you will need brake, gas and steering calibration. So, you can get the calibration with using accel_brake_map_calibrator package. Please follow the steps for calibration your vehicle actuation.</p> <p>The choice between these control interfaces profoundly influences the design and development process. If you are planning to use Type A, then you will control velocity or acceleration over drive by-wire systems. If type B is more suitable for your implementation, then you will need to control your vehicle's brake and gas pedal.</p>"},{"location":"how-to-guides/integrating-autoware/creating-vehicle-interface-package/vehicle-interface/#communication-between-the-vehicle-interface-and-your-vehicles-control-device","title":"Communication between the vehicle interface and your vehicle's control device","text":"<ul> <li>If you are planning to drive by autoware with your vehicle, then your vehicle must satisfy some requirements:</li> </ul> Type A Type B Your vehicle can be controlled in longitudinal direction by the target velocity or acceleration. Your vehicle can be controlled in longitudinal direction by the specific target commands. (i.e., brake and gas pedal) Your vehicle can be controlled in lateral direction by the target steering angle. (Optionally, you can use steering rate as well) Your vehicle can be controlled in lateral direction by the specific target commands. (i.e., steering torque) Your vehicle must provide velocity or acceleration information and steering information which is described at the vehicle status topics above. Your vehicle must provide velocity or acceleration information and steering information which is described at the vehicle status topics above. <ul> <li>You can also use mixed Type A and Type B, for example, you want to use lateral controlling with a steering angle and longitudinal controlling with specific targets. In order to do that, you must subscribe <code>/control/command/control_cmd</code> for getting steering information, and you must subscribe <code>/control/command/actuation_cmd</code> for gas and brake pedal actuation commands. Then, you must handle these messages on your own vehicle_interface design.</li> <li>You must adopt your vehicle low-level controller to run with autoware.</li> <li>Your vehicle can be controlled by the target shift mode and also needs to provide Autoware with shift information.</li> <li>If you are using CAN communication on your vehicle, please refer to ros2_socketcan package by Autoware.</li> <li>If you are using Serial communication on your vehicle, you can look at serial-port.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-your-autoware-repositories/creating-autoware-repositories/","title":"Creating Autoware repositories","text":""},{"location":"how-to-guides/integrating-autoware/creating-your-autoware-repositories/creating-autoware-repositories/#creating-autoware-repositories","title":"Creating Autoware repositories","text":""},{"location":"how-to-guides/integrating-autoware/creating-your-autoware-repositories/creating-autoware-repositories/#what-is-a-meta-repository","title":"What is a Meta-repository?","text":"<p>A meta-repository is a repository that manages multiple repositories, and Autoware is one of them. It serves as a centralized control point for referencing, configuring, and versioning other repositories. To accomplish this, the Autoware meta-repository includes the <code>autoware.repos</code> file for managing multiple repositories. We will use the VCS tool (Version Control System) to handle the .repos file. VCS provides us with the capability to import, export, and pull from multiple repositories. VCS will be used to import all the necessary repositories to build Autoware into our workspace. Please refer to the documentation for VCS and .repos file usage.</p>"},{"location":"how-to-guides/integrating-autoware/creating-your-autoware-repositories/creating-autoware-repositories/#how-to-create-and-customize-your-autoware-meta-repository","title":"How to create and customize your autoware meta-repository","text":""},{"location":"how-to-guides/integrating-autoware/creating-your-autoware-repositories/creating-autoware-repositories/#1-create-autoware-meta-repository","title":"1. Create autoware meta-repository","text":"<p>If you want to integrate Autoware into your vehicle, the first step is to create an Autoware meta-repository.</p> <p>One easy way is to fork the Autoware repository and clone it. (For instructions on how to fork a repository, refer to GitHub Docs)</p> <ul> <li>In this guide, Autoware will be integrated into a <code>tutorial_vehicle</code>   (Note: when setting up multiple types of vehicles,   adding a suffix like <code>autoware.vehicle_A</code> or <code>autoware.vehicle_B</code> is recommended).   For the first step,   please visit the autoware repository   and click the fork button.   The fork process should look like this:</li> </ul> <p> </p>      Sample forking demonstration for tutorial_vehicle    <p>Then click \"Create fork\" button to continue. After that, we can clone our fork repository on our local system.</p> <pre><code>git clone https://github.com/YOUR_NAME/autoware.&lt;YOUR-VEHICLE&gt;.git\n</code></pre> <p>For example, it should be for our documentation:</p> <pre><code>git clone https://github.com/leo-drive/autoware.tutorial_vehicle.git\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/creating-your-autoware-repositories/creating-autoware-repositories/#11-create-vehicle-individual-repositories","title":"1.1 Create vehicle individual repositories","text":"<p>To integrate Autoware into your individual vehicles, you need to fork and modify the following repositories as well:</p> <ul> <li>sample_sensor_kit: This repository will be used for sensing launch files, their pipelines-organizations and sensor descriptions.   Please fork and rename as autoware meta-repository. At this point, our forked repository name will be <code>tutorial_vehicle_sensor_kit_launch</code>.</li> <li>sample_vehicle_launch: This repository will be used for vehicle launch files, vehicle_descriptions and vehicle_model.   Please fork and rename this repository as well. At this point, our forked repository name will be <code>tutorial_vehicle_launch</code>.</li> <li>autoware_individual_params: This repository stores parameters that change depending on each vehicle (i.e. sensor calibrations). Please fork   and rename this repository as well; our forked repository name will be <code>tutorial_vehicle_individual_params</code>.</li> <li>autoware_launch:   This repository contains node configurations and their parameters for Autoware.   Please fork and rename it as the previously forked repositories;   our forked repository name will be <code>autoware_launch.tutorial_vehicle</code>.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/creating-your-autoware-repositories/creating-autoware-repositories/#2-customize-autowarerepos-for-your-environment","title":"2. Customize autoware.repos for your environment","text":"<p>You need to customize your <code>autoware.repos</code> to import your forked repositories. The <code>autoware.repos</code> file usually includes information for all necessary Autoware repositories (except calibration and simulator repositories). Therefore, your forked repositories should also be added to this file.</p>"},{"location":"how-to-guides/integrating-autoware/creating-your-autoware-repositories/creating-autoware-repositories/#21-adding-individual-repos-to-autowarerepos","title":"2.1 Adding individual repos to autoware.repos","text":"<p>After forking all repositories, you can start adding them to your Autoware meta-repository by opening the <code>autoware.repos</code> file using any text editor and updating <code>sample_sensor_kit_launch</code>, <code>sample_vehicle_launch</code>, <code>autoware_individual_params</code> and <code>autoware launch</code> with your own individual repos. For example, in this tutorial, the necessary changes for our forked <code>tutorial_vehicle</code> repositories should be as follows:</p> <ul> <li> <p>Sensor Kit:</p> <pre><code>- sensor_kit/sample_sensor_kit_launch:\n-   type: git\n-   url: https://github.com/autowarefoundation/sample_sensor_kit_launch.git\n-   version: main\n+ sensor_kit/tutorial_vehicle_sensor_kit_launch:\n+   type: git\n+   url: https://github.com/leo-drive/tutorial_vehicle_sensor_kit_launch.git\n+   version: main\n</code></pre> </li> </ul> <ul> <li> <p>Vehicle Launch:</p> <pre><code>- vehicle/sample_vehicle_launch:\n-   type: git\n-   url: https://github.com/autowarefoundation/sample_vehicle_launch.git\n-   version: main\n+ vehicle/tutorial_vehicle_launch:\n+   type: git\n+   url: https://github.com/leo-drive/tutorial_vehicle_launch.git\n+   version: main\n</code></pre> </li> </ul> <ul> <li> <p>Individual Params:</p> <pre><code>- param/autoware_individual_params:\n-   type: git\n-   url: https://github.com/autowarefoundation/autoware_individual_params.git\n-   version: main\n+ param/tutorial_vehicle_individual_params:\n+   type: git\n+   url: https://github.com/leo-drive/tutorial_vehicle_individual_params.git\n+   version: main\n</code></pre> </li> </ul> <ul> <li> <p>Autoware Launch:</p> <pre><code>- launcher/autoware_launch:\n-   type: git\n-   url: https://github.com/autowarefoundation/autoware_launch.git\n-   version: main\n+ launcher/autoware_launch.tutorial_vehicle:\n+   type: git\n+   url: https://github.com/leo-drive/autoware_launch.tutorial_vehicle.git\n+   version: main\n</code></pre> </li> </ul> <p>Please make similar changes to your own autoware.repos file. After making these changes, you will be ready to use VCS to import all the necessary repositories into your Autoware workspace.</p> <p>First, create a src directory under your own Autoware meta-repository directory:</p> <pre><code>cd &lt;YOUR-AUTOWARE-DIR&gt;\nmkdir src\n</code></pre> <p>Then, import all necessary repositories with vcs:</p> <pre><code>cd &lt;YOUR-AUTOWARE-DIR&gt;\nvcs import src &lt; autoware.repos\n</code></pre> <p>After the running <code>vcs import</code> command, all autoware repositories will be cloned in the <code>src</code> folder under the Autoware directory.</p> <p>Now, you can build your own repository with colcon build command:</p> <pre><code>cd &lt;YOUR-AUTOWARE-DIR&gt;\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>Please refer to the following documentation links for instructions on how to create and customize each of your vehicle's packages:</p> <ul> <li>Creating vehicle and sensor models<ul> <li>Creating sensor model</li> <li>Creating individual params</li> <li>Creating vehicle model</li> </ul> </li> <li>creating-vehicle-interface-package</li> <li>customizing-for-differential-drive-model</li> </ul> <p>Please remember to add all your custom packages, such as interfaces and descriptions, to your <code>autoware.repos</code> to ensure that your packages are properly included and managed within the Autoware repository.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/","title":"Launch Autoware","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/#launch-autoware","title":"Launch Autoware","text":"<p>This section explains how to run your vehicle with Autoware. We will explain how to run and launch autoware with these modules:</p> <ul> <li>Vehicle</li> <li>System</li> <li>Map</li> <li>Sensing</li> <li>Localization</li> <li>Perception</li> <li>Planning</li> <li>Control</li> </ul>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#pre-requirements-of-launching-autoware-with-real-vehicle","title":"Pre-requirements of launching Autoware with real vehicle","text":"<p>Please complete these steps for integration Autoware on your vehicle:</p> <ul> <li>Create your Autoware meta-repository.</li> <li>Create your vehicle and sensor model.</li> <li>Calibrate your sensors.</li> <li>Create your Autoware compatible vehicle interface.</li> <li>Create your environment map.</li> </ul> <p>After the completion of these steps according to your individual vehicle, you are ready to use Autoware.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#autoware_launch-package","title":"autoware_launch package","text":"<p>The autoware_launch package starts the initiation of Autoware software stack launch files. The autoware.launch.xml launch file enables the invocation of these module launches by enabling the following launch arguments:</p> <pre><code>  &lt;arg name=\"launch_vehicle\" default=\"true\" description=\"launch vehicle\"/&gt;\n&lt;arg name=\"launch_system\" default=\"true\" description=\"launch system\"/&gt;\n&lt;arg name=\"launch_map\" default=\"true\" description=\"launch map\"/&gt;\n&lt;arg name=\"launch_sensing\" default=\"true\" description=\"launch sensing\"/&gt;\n&lt;arg name=\"launch_sensing_driver\" default=\"true\" description=\"launch sensing driver\"/&gt;\n&lt;arg name=\"launch_localization\" default=\"true\" description=\"launch localization\"/&gt;\n&lt;arg name=\"launch_perception\" default=\"true\" description=\"launch perception\"/&gt;\n&lt;arg name=\"launch_planning\" default=\"true\" description=\"launch planning\"/&gt;\n&lt;arg name=\"launch_control\" default=\"true\" description=\"launch control\"/&gt;\n</code></pre> <p>For example, if you don't need to launch perception, planning, and control for localization debug, you can disable these modules like the following:</p> <pre><code>-  &lt;arg name=\"launch_perception\" default=\"true\" description=\"launch perception\"/&gt;\n+  &lt;arg name=\"launch_perception\" default=\"false\" description=\"launch perception\"/&gt;\n-  &lt;arg name=\"launch_planning\" default=\"true\" description=\"launch planning\"/&gt;\n+  &lt;arg name=\"launch_planning\" default=\"false\" description=\"launch planning\"/&gt;\n-  &lt;arg name=\"launch_control\" default=\"true\" description=\"launch control\"/&gt;\n+  &lt;arg name=\"launch_control\" default=\"false\" description=\"launch control\"/&gt;\n</code></pre> <p>Also, it is possible to specify which components to launch using command-line arguments.</p> <pre><code>ros2 launch autoware_launch autoware.launch.xml vehicle_model:=YOUR_VEHICLE sensor_kit:=YOUR_SENSOR_KIT map_path:=/PATH/TO/YOUR/MAP \\\nlaunch_perception:=false \\\nlaunch_planning:=false \\\nlaunch_control:=false\n</code></pre> <p>Also, <code>autoware_launch</code> package includes autoware modules parameter files under the <code>config</code> directory.</p> <pre><code>&lt;YOUR-OWN-AUTOWARE-DIR&gt;/\n  \u2514\u2500 src/\n       \u2514\u2500 launcher/\n            \u2514\u2500 autoware_launch/\n                 \u251c\u2500 config/\n                 \u251c\u2500     \u251c\u2500 control/\n                 \u251c\u2500     \u251c\u2500 localization/\n                 \u251c\u2500     \u251c\u2500 map/\n                 \u251c\u2500     \u251c\u2500 perception/\n                 \u251c\u2500     \u251c\u2500 planning/\n                 \u251c\u2500     \u251c\u2500 simulator/\n                 \u251c\u2500     \u2514\u2500 system/\n                 \u251c\u2500launch/\n                 \u2514\u2500 rviz/\n</code></pre> <p>So, if we change any parameter in <code>config</code> directory, it will override the original parameter values since <code>autoware_launch</code> parameter file path is used for parameter loading.</p> <p> </p>      autoware_launch package launching and parameter migrating diagram"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#configure-autowarelaunchxml","title":"Configure <code>autoware.launch.xml</code>","text":"<p>As we mentioned above, we can enable or disable Autoware modules to launch by modifying <code>autoware.launch.xml</code> or using command-line arguments. Also, we have some arguments for specifying our Autoware configurations. Here are some basic configurations for the autoware.launch.xml launch file: (Additionally, you can use them as command-line arguments, as we mentioned before)</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#vehicle","title":"Vehicle","text":"<p>In the Vehicle section, you can choose whether the vehicle interface will be launched or not. For example, if you disable it, then <code>vehicle_interface.launch.xml</code> will not be called:</p> <pre><code>- &lt;arg name=\"launch_vehicle_interface\" default=\"true\" description=\"launch vehicle interface\"/&gt;\n+ &lt;arg name=\"launch_vehicle_interface\" default=\"false\" description=\"launch vehicle interface\"/&gt;\n</code></pre> <p>Please be sure your vehicle interface driver included in <code>vehicle_interface.launch.xml</code>, for more information you can refer the creating vehicle interface page.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#map","title":"Map","text":"<p>If your point cloud and lanelet2 map names are different from pointcloud_map.pcd and lanelet2_map.osm, you will need to update these map file name arguments:</p> <pre><code>- &lt;arg name=\"lanelet2_map_file\" default=\"lanelet2_map.osm\" description=\"lanelet2 map file name\"/&gt;\n+ &lt;arg name=\"lanelet2_map_file\" default=\"&lt;YOUR-LANELET2-MAP-FILE-NAME&gt;\" description=\"lanelet2 map file name\"/&gt;\n- &lt;arg name=\"pointcloud_map_file\" default=\"pointcloud_map.pcd\" description=\"pointcloud map file name\"/&gt;\n+ &lt;arg name=\"pointcloud_map_file\" default=\"&lt;YOUR-POINTCLOUD-MAP-FILE-NAME&gt;\" description=\"pointcloud map file name\"/&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#perception","title":"Perception","text":"<p>You can define your <code>autoware_data</code> path here. Autoware gets yabloc_pose_initializer, image_projection_based_fusion, lidar_apollo_instance_segmentation etc. models file with <code>autoware_data</code> path. If you use ansible for autoware installation, the necessary artifacts will be downloaded at <code>autoware_data</code> folder on your <code>$HOME</code> directory. If you want to download artifacts manually, please check ansible <code>artifacts</code> page for information.</p> <pre><code>- &lt;arg name=\"data_path\" default=\"$(env HOME)/autoware_data\" description=\"packages data and artifacts directory path\"/&gt;\n+ &lt;arg name=\"data_path\" default=\"&lt;YOUR-AUTOWARE-DATA-PATH&gt;\" description=\"packages data and artifacts directory path\"/&gt;\n</code></pre> <p>Also, you can change your perception method here. The Autoware provides <code>camera-lidar-radar fusion</code>, <code>camera-lidar fusion</code>, <code>lidar-radar fusion</code>, <code>lidar only</code> and <code>radar only</code> perception modes. The default perception method is <code>lidar only</code> mode, but if you want to use <code>camera-lidar fusion</code> you need to change your perception mode:</p> <pre><code>-  &lt;arg name=\"perception_mode\" default=\"lidar\" description=\"select perception mode. camera_lidar_radar_fusion, camera_lidar_fusion, lidar_radar_fusion, lidar, radar\"/&gt;\n+  &lt;arg name=\"perception_mode\" default=\"camera_lidar_fusion\" description=\"select perception mode. camera_lidar_radar_fusion, camera_lidar_fusion, lidar_radar_fusion, lidar, radar\"/&gt;\n</code></pre> <p>If you want to use traffic light recognition and visualization, you can set <code>traffic_light_recognition/enable_fine_detection</code> as true (default). Please check traffic_light_fine_detector page for more information. If you don't want to use traffic light classifier, then you can disable it:</p> <pre><code>- &lt;arg name=\"traffic_light_recognition/enable_fine_detection\" default=\"true\" description=\"enable traffic light fine detection\"/&gt;\n+ &lt;arg name=\"traffic_light_recognition/enable_fine_detection\" default=\"false\" description=\"enable traffic light fine detection\"/&gt;\n</code></pre> <p>Please look at Launch perception page for detailed information.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#launch-autoware_1","title":"Launch Autoware","text":"<p>Launch Autoware with the following command:</p> <pre><code>ros2 launch autoware_launch autoware_launch.launch.xml map_path:=&lt;YOUR-MAP-PATH&gt; vehicle_model:=&lt;YOUR-VEHICLE-MODEL&gt; sensor_model:=&lt;YOUR-SENSOR-MODEL&gt; vehicle_id:=&lt;YOUR-VEHICLE-ID&gt;\n</code></pre> <p>It is possible to specify which components to launch using command-line arguments. For example, if you don't need to launch perception, planning, and control for localization debug, you can launch the following:</p> <pre><code>ros2 launch autoware_launch autoware_launch.launch.xml map_path:=&lt;YOUR-MAP-PATH&gt; vehicle_model:=&lt;YOUR-VEHICLE-MODEL&gt; sensor_model:=&lt;YOUR-SENSOR-MODEL&gt; vehicle_id:=&lt;YOUR-VEHICLE-ID&gt; \\\nlaunch_perception:=false \\\nlaunch_planning:=false \\\nlaunch_control:=false\n</code></pre> <p>After launching Autoware, we need to initialize our vehicle on our map. If you set gnss_poser for your GNSS/INS sensor at <code>gnss.launch.xml</code>, then gnss_poser will send pose for initialization. If you don't have a GNSS sensor, then you need to set initial pose manually.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#set-initial-pose","title":"Set initial pose","text":"<p>If not or if the automatic initialization returns an incorrect position, you need to set the initial pose using the RViz GUI.</p> <ul> <li>Click the 2D Pose estimate button in the toolbar, or hit the P key</li> </ul> <p> </p>      2D Pose estimate with RViz    <ul> <li>In the 3D View panel, click and hold the left mouse button, and then drag to set the direction for the initial pose.</li> </ul> <p> </p>      Setting 2D Pose estimate with RViz    <ul> <li>After that, the vehicle will be initialized. You will then observe both your vehicle and Autoware outputs.</li> </ul> <p> </p>      Initialization of the vehicle"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#set-goal-pose","title":"Set goal pose","text":"<p>Set a goal pose for the ego vehicle.</p> <ul> <li>Click the 2D Nav Goal button in the toolbar, or hit the G key</li> </ul> <p> </p>      Initialization of the vehicle    <ul> <li>In the 3D View pane, click and hold the left mouse button,   and then drag to set the direction for the goal pose.</li> </ul> <p> </p>      Initialization of the vehicle    <ul> <li>If successful, you will see the calculated planning path on RViz.</li> </ul> <p> </p>      Planned path on RViz"},{"location":"how-to-guides/integrating-autoware/launch-autoware/#engage","title":"Engage","text":"<p>There are two options for engage:</p> <ul> <li>Firstly, you can use <code>AutowareStatePanel</code>,   it is included in Autoware RViz configuration file,   but it can be found in <code>Panels &gt; Add New Panel &gt; tier4_state_rviz_plugin &gt; AutowareStatePanel</code>.</li> </ul> <p>Once the route is computed, the \"AUTO\" button becomes active. Pressing the AUTO button engages the autonomous driving mode.</p> <p> </p>      Autoware state panel (STOP operation mode)    <ul> <li>Secondly, you can engage with ROS 2 topic. In your terminal, execute the following command.</li> </ul> <pre><code>source ~/&lt;YOUR-AUTOWARE-DIR&gt;/install/setup.bash\nros2 topic pub /&lt;YOUR-AUTOWARE-DIR&gt;/engage autoware_auto_vehicle_msgs/msg/Engage \"engage: true\" -1\n</code></pre> <p>Now the vehicle should drive along the calculated path!</p> <p>During the autonomous driving, the StatePanel appears as shown in the image below. Pressing the \"STOP\" button allows you to stop the vehicle.</p> <p> </p>      Autoware state panel (AUTO operation mode)"},{"location":"how-to-guides/integrating-autoware/launch-autoware/control/","title":"Control Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/control/#control-launch-files","title":"Control Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/control/#overview","title":"Overview","text":"<p>The Autoware control stacks start launching at <code>autoware_launch.xml</code> as mentioned on the Launch Autoware page. The <code>autoware_launch</code> package includes <code>tier4_control_component.launch.xml</code> for initiating control launch files invocation from <code>autoware_launch.xml</code>. The diagram below illustrates the flow of Autoware control launch files within the autoware_launch and autoware.universe packages.</p> <p> </p>      Autoware control launch flow diagram    <p>Note</p> <p>The Autoware project is a large project. Therefore, as we manage the Autoware project, we utilize specific arguments in the launch files. ROS 2 offers an argument-overriding feature for these launch files. Please refer to the official ROS 2 launch documentation for further information. For instance, if we define an argument at the top-level launch, it will override the value on lower-level launches.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/control/#tier4_control_componentlaunchxml","title":"tier4_control_component.launch.xml","text":"<p>The tier4_control_component.launch.xml launch file is the main control component launch in the autoware_launch package. This launch file calls control.launch.xml from the tier4_control_launch package within the autoware.universe repository. We can modify control launch arguments in tier4_control_component.launch.xml. Additionally, we can add any other necessary arguments that need adjustment since tier4_control_component.launch.xml serves as the top-level launch file for other control launch files. Here are some predefined control launch arguments:</p> <ul> <li> <p><code>lateral_controller_mode:</code> This argument determines   the lateral controller algorithm.   The default value is <code>mpc</code>.   To change it to pure pursuit,   make the following update in your <code>tier4_control_component.launch.xml</code> file:</p> <pre><code>- &lt;arg name=\"lateral_controller_mode\" default=\"mpc\"/&gt;\n+ &lt;arg name=\"lateral_controller_mode\" default=\"pure_pursuit\"/&gt;\n</code></pre> </li> </ul> <ul> <li> <p><code>enable_autonomous_emergency_braking:</code> This argument enables autonomous emergency   braking under specific conditions.   Please refer to the Autonomous emergency braking (AEB) page for   more information.   To enable it, update the value in the <code>tier4_control_component.launch.xml</code> file:</p> <pre><code>- &lt;arg name=\"enable_autonomous_emergency_braking\" default=\"false\"/&gt;\n+ &lt;arg name=\"enable_autonomous_emergency_braking\" default=\"true\"/&gt;\n</code></pre> </li> </ul> <ul> <li> <p><code>enable_predicted_path_checker:</code> This argument enables the predicted path checker module.   Please refer to the Predicted Path Checker page for   more information.   To enable it, update the value in the <code>tier4_control_component.launch.xml</code> file:</p> <pre><code>- &lt;arg name=\"enable_predicted_path_checker\" default=\"false\"/&gt;\n+ &lt;arg name=\"enable_predicted_path_checker\" default=\"true\"/&gt;\n</code></pre> </li> </ul> <p>Note</p> <p>You can also use this arguments as command line arguments: </p><pre><code>ros2 launch autoware_launch autoware.launch.xml ... enable_predicted_path_checker:=true lateral_controller_mode:=pure_pursuit ...\n</code></pre> <p>The predefined arguments in tier4_control_component.launch.xml have been explained above. However, numerous control arguments are included in the autoware_launch control config parameters.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/","title":"Localization Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/#localization-launch-files","title":"Localization Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/#overview","title":"Overview","text":"<p>The Autoware localization stacks start launching at <code>autoware_launch.xml</code> as we mentioned at Launch Autoware page. The <code>autoware_launch</code> package includes <code>tier4_localization_component.launch.xml</code> for starting localization launch files invocation from <code>autoware_launch.xml</code>. This diagram describes some of the Autoware localization launch files flow at <code>autoware_launch</code> and <code>autoware.universe</code> packages.</p> <p> </p>      Autoware localization launch flow diagram    <p>Note</p> <p>The Autoware project is a large project. Therefore, as we manage the Autoware project, we utilize specific arguments in the launch files. ROS 2 offers an argument-overriding feature for these launch files. Please refer to the official ROS 2 launch documentation for further information. For instance, if we define an argument at the top-level launch, it will override the value on lower-level launches.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/#tier4_localization_componentlaunchxml","title":"tier4_localization_component.launch.xml","text":"<p>The <code>tier4_localization_component.launch.xml</code> launch file is the main localization component launch at the <code>autoware_launch</code> package. This launch file calls <code>localization.launch.xml</code> at tier4_localization_launch package from <code>autoware.universe</code> repository. We can modify localization launch arguments at tier4_localization_component.launch.xml.</p> <p>The current localization launcher implemented by TIER IV supports multiple localization methods, both pose estimators and twist estimators. <code>tier4_localization_component.launch.xml</code> has two arguments to select which estimators to launch:</p> <ul> <li> <p><code>pose_source:</code> This argument specifies the pose_estimator, currently supporting <code>ndt</code> (default), <code>yabloc</code>, <code>artag</code> and <code>eagleye</code> for localization.   By default, Autoware launches ndt_scan_matcher for pose estimator.   You can use YabLoc as a camera-based localization method.   For more details on YabLoc,   please refer to the README of YabLoc in autoware.universe.   Also, you can use Eagleye as a GNSS &amp; IMU &amp; wheel odometry-based localization method. For more details on Eagleye, please refer to the Eagleye.</p> <p>You can set <code>pose_source</code> argument on <code>tier4_localization_component.launch.xml</code>, for example, if you want to use eagleye as pose_source, you need to update <code>tier4_localization_component.launch.xml</code> like:</p> <pre><code>- &lt;arg name=\"pose_source\" default=\"ndt\" description=\"select pose_estimator: ndt, yabloc, eagleye\"/&gt;\n+ &lt;arg name=\"pose_source\" default=\"eagleye\" description=\"select pose_estimator: ndt, yabloc, eagleye\"/&gt;\n</code></pre> <p>Also, you can use command-line for overriding launch arguments:</p> <pre><code>ros2 launch autoware_launch autoware.launch.xml ... pose_source:=eagleye\n</code></pre> </li> </ul> <ul> <li> <p><code>twist_source:</code> This argument specifies the twist_estimator, currently supporting <code>gyro_odom</code> (default), and <code>eagleye</code>.   By default,   Autoware launches gyro_odometer for twist estimator.   Also, you can use eagleye for the twist source, please refer to the Eagleye.   If you want to change your twist source to eagleye, you can update <code>tier4_localization_component.launch.xml</code> like:</p> <pre><code>- &lt;arg name=\"twist_source\" default=\"gyro_odom\" description=\"select twist_estimator. gyro_odom, eagleye\"/&gt;\n+ &lt;arg name=\"twist_source\" default=\"eagleye\" description=\"select twist_estimator. gyro_odom, eagleye\"/&gt;\n</code></pre> <p>Or you can use command-line for overriding launch arguments:</p> <pre><code>ros2 launch autoware_launch autoware.launch.xml ... twist_source:=eagleye\n</code></pre> </li> </ul> <ul> <li> <p><code>input_pointcloud:</code> This argument specifies the input pointcloud of the localization pointcloud pipeline. The default value is   <code>/sensing/lidar/top/outlier_filtered/pointcloud</code> which   is output of the pointcloud pre-processing pipeline from sensing.   You can change this value according to your LiDAR topic name,   or you can choose to use concatenated point cloud:</p> <pre><code>- &lt;arg name=\"input_pointcloud\" default=\"/sensing/lidar/top/outlier_filtered/pointcloud\" description=\"The topic will be used in the localization util module\"/&gt;\n+ &lt;arg name=\"input_pointcloud\" default=\"/sensing/lidar/concatenated/pointcloud\"/&gt;\n</code></pre> </li> </ul> <p>You can add every necessary argument to <code>tier4_localization_component.launch.xml</code> launch file like these examples. In case, if you want to change your gyro odometer twist input topic, you can add this argument on <code>tier4_localization_component.launch.xml</code> launch file:</p> <pre><code>+ &lt;arg name=\"input_vehicle_twist_with_covariance_topic\" value=\"&lt;YOUR-VEHICLE-TWIST-TOPIC-NAME&gt;\"/&gt;\n</code></pre> <p>Note: Gyro odometer input topic provided from velocity converter package. This package will be launched at sensor_kit. For more information, please check velocity converter package.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/#note-when-using-non-ndt-pose-estimator","title":"Note when using non NDT pose estimator","text":"<p>Note</p> <p>Since NDT is currently the most often used pose_estimator , the NDT diagnostics are registered for monitoring by default. When using a pose_estimator other than NDT, NDT diagnostics will always be marked as stale, causing the system to enter a safe_fault state. Depending on the parameters of emergencies, this could escalate to a full emergency, preventing autonomous driving.</p> <p>To work around this, please modify the configuration file of the system_error_monitor. In the system_error_monitor.param.yaml file, <code>/autoware/localization/performance_monitoring/matching_score</code> represents the aggregated diagnostics for NDT. To prevent emergencies even when NDT is not launched, remove this entry from the configuration. Note that the module name <code>/performance_monitoring/matching_score</code> is specified in diagnostics_aggregator/localization.param.yaml.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/","title":"Using Eagleye with Autoware","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#using-eagleye-with-autoware","title":"Using Eagleye with Autoware","text":"<p>This page will show you how to set up Eagleye in order to use it with Autoware. For the details of the integration proposal, please refer to this discussion.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#what-is-eagleye","title":"What is Eagleye?","text":"<p>Eagleye is an open-source GNSS/IMU-based localizer initially developed by MAP IV. Inc. It provides a cost-effective alternative to LiDAR and point cloud-based localization by using low-cost GNSS and IMU sensors to provide vehicle position, orientation, and altitude information.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#dependencies","title":"Dependencies","text":"<p>The below packages are automatically installed during the setup of Autoware as they are listed in autoware.repos.</p> <ol> <li>Eagleye (autoware-main branch)</li> <li>RTKLIB ROS Bridge (ros2-v0.1.0 branch)</li> <li>LLH Converter (ros2 branch)</li> </ol>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#architecture","title":"Architecture","text":"<p>Eagleye can be utilized in the Autoware localization stack in two ways:</p> <ol> <li> <p>Feed only twist into the EKF localizer.</p> <p></p> </li> <li> <p>Feed both twist and pose from Eagleye into the EKF localizer (twist can also be used with regular <code>gyro_odometry</code>).</p> <p></p> </li> </ol> <p>Note: RTK positioning is required when using Eagleye as the pose estimator. On the other hand, it is not mandatory when using it as the twist estimator.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#requirements","title":"Requirements","text":"<p>Eagleye requires GNSS, IMU and vehicle speed as inputs.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#imu-topic","title":"IMU topic","text":"<p><code>sensor_msgs/msg/Imu</code> is supported for Eagleye IMU input.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#vehicle-speed-topic","title":"Vehicle speed topic","text":"<p><code>geometry_msgs/msg/TwistStamped</code> and <code>geometry_msgs/msg/TwistWithCovarianceStamped</code> are supported for the input vehicle speed.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#gnss-topic","title":"GNSS topic","text":"<p>Eagleye requires latitude/longitude height and doppler velocity generated by the GNSS receiver. Your GNSS ROS driver must publish the following messages:</p> <ul> <li><code>sensor_msgs/msg/NavSatFix</code>: This message contains latitude, longitude, and height information.</li> <li> <p><code>geometry_msgs/msg/TwistWithCovarianceStamped</code>: This message contains gnss doppler velocity information.   </p> <p>Eagleye has been tested with the following example GNSS ROS drivers: ublox_gps and septentrio_gnss_driver. The settings needed for each of these drivers are as follows:</p> </li> </ul> GNSS ROS drivers modification ublox_gps No additional settings are required. It publishes <code>sensor_msgs/msg/NavSatFix</code> and <code>geometry_msgs/msg/TwistWithCovarianceStamped</code> required by Eagleye with default settings. septentrio_gnss_driver Set <code>publish.navsatfix</code> and <code>publish.twist</code> in the config file <code>gnss.yaml</code> to <code>true</code>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#parameter-modifications-for-integration-into-your-vehicle","title":"Parameter Modifications for Integration into Your Vehicle","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#topic-name-topic-type","title":"topic name &amp; topic type","text":"<p>The users must correctly specify input topics for GNSS latitude, longitude, and height , GNSS doppler speed , IMU , and vehicle speed in the <code>eagleye_config.yaml</code>.</p> <pre><code># Topic\ntwist:\ntwist_type: 1 # TwistStamped : 0, TwistWithCovarianceStamped: 1\ntwist_topic: /sensing/vehicle_velocity_converter/twist_with_covariance\nimu_topic: /sensing/imu/tamagawa/imu_raw\ngnss:\nvelocity_source_type: 2 # rtklib_msgs/RtklibNav: 0, nmea_msgs/Sentence: 1, ublox_msgs/NavPVT: 2, geometry_msgs/TwistWithCovarianceStamped: 3\nvelocity_source_topic: /sensing/gnss/ublox/navpvt\nllh_source_type: 2 # rtklib_msgs/RtklibNav: 0, nmea_msgs/Sentence: 1, sensor_msgs/NavSatFix: 2\nllh_source_topic: /sensing/gnss/ublox/nav_sat_fix\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#sensor-frequency","title":"sensor frequency","text":"<p>Also, the frequency of GNSS and IMU must be set in <code>eagleye_config.yaml</code></p> <pre><code>common:\nimu_rate: 50\ngnss_rate: 5\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#conversion-from-fix-to-pose","title":"Conversion from fix to pose","text":"<p>The parameters for converting <code>sensor_msgs/msg/NavSatFix</code> to <code>geometry_msgs/msg/PoseWithCovarianceStamped</code> is listed in <code>geo_pose_converter.launch.xml</code>. If you use a different geoid or projection type, change these parameters.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#other-parameters","title":"Other parameters","text":"<p>The other parameters are described here. Basically, these do not need to be changed .</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#notes-on-initialization","title":"Notes on initialization","text":"<p>Eagleye requires an initialization process for proper operation. Without initialization, the output for twist will be in the raw value, and the pose data will not be available.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#1-static-initialization","title":"1. Static Initialization","text":"<p>The first step is static initialization, which involves allowing the Eagleye to remain stationary for approximately 5 seconds after startup to estimate the yaw-rate offset.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#2-dynamic-initialization","title":"2. Dynamic initialization","text":"<p>The next step is dynamic initialization, which involves running the Eagleye in a straight line for approximately 30 seconds. This process estimates the scale factor of wheel speed and azimuth angle.</p> <p>Once dynamic initialization is complete, the Eagleye will be able to provide corrected twist and pose data.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#how-to-check-the-progress-of-initialization","title":"How to check the progress of initialization","text":"<ul> <li>TODO</li> </ul>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/localization/eagleye/#note-on-georeferenced-maps","title":"Note on georeferenced maps","text":"<p>Note that the output position might not appear to be in the point cloud maps if you are using maps that are not properly georeferenced. In the case of a single GNSS antenna, initial position estimation (dynamic initialization) can take several seconds to complete after starting to run in an environment where GNSS positioning is available.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/map/","title":"Map Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/map/#map-launch-files","title":"Map Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/map/#overview","title":"Overview","text":"<p>The Autoware map stacks start launching at <code>autoware_launch.xml</code> as we mentioned at Launch Autoware page. The <code>autoware_launch</code> package includes <code>tier4_map_component.launch.xml</code> for starting map launch files invocation from <code>autoware_launch.xml</code>. This diagram describes some of the Autoware map launch files flow at <code>autoware_launch</code> and <code>autoware.universe</code> packages.</p> <p> </p>      Autoware map launch flow diagram    <p>Note</p> <p>The Autoware project is a large project. Therefore, as we manage the Autoware project, we utilize specific arguments in the launch files. ROS 2 offers an argument-overriding feature for these launch files. Please refer to the official ROS 2 launch documentation for further information. For instance, if we define an argument at the top-level launch, it will override the value on lower-level launches.</p> <p>The map.launch.py launch file from the tier4_map_launch package directly includes the necessary node definitions for mapping. In the current design of Autoware, the <code>lanelet2_map_loader</code>, <code>lanelet2_map_visualization</code>, <code>pointcloud_map_loader</code>, and <code>vector_map_tf_generator</code> composable nodes are included in the <code>map_container</code>.</p> <p>We don't have many modification options in the map launching files (as the parameters are included in the config files). However, you can specify the names for your pointcloud and lanelet2 map during the launch (the default values are pointcloud_map.pcd and lanelet2_map.osm). For instance, if you wish to change your map file names, you can run Autoware using the following command line arguments:</p> <pre><code>ros2 launch autoware_launch autoware.launch.xml ... pointcloud_map_file:=&lt;YOUR-PCD-FILE-NAME&gt; lanelet2_map_file:=&lt;YOUR-LANELET2-MAP-NAME&gt; ...\n</code></pre> <p>Or you can change it on your <code>autoware.launch.xml</code> launch file:</p> <pre><code>- &lt;arg name=\"lanelet2_map_file\" default=\"lanelet2_map.osm\" description=\"lanelet2 map file name\"/&gt;\n+ &lt;arg name=\"lanelet2_map_file\" default=\"&lt;YOUR-LANELET2-MAP-NAME&gt;\" description=\"lanelet2 map file name\"/&gt;\n- &lt;arg name=\"pointcloud_map_file\" default=\"pointcloud_map.pcd\" description=\"pointcloud map file name\"/&gt;\n+ &lt;arg name=\"pointcloud_map_file\" default=\"&lt;YOUR-PCD-FILE-NAME&gt;\" description=\"pointcloud map file name\"/&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/perception/","title":"Perception Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/perception/#perception-launch-files","title":"Perception Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/perception/#overview","title":"Overview","text":"<p>The Autoware perception stacks start launching at <code>autoware_launch.xml</code> as we mentioned at Launch Autoware page. The <code>autoware_launch</code> package includes <code>tier4_perception_component.launch.xml</code> for starting perception launch files invocation from <code>autoware_launch.xml</code>. This diagram describes some of the Autoware perception launch files flow at <code>autoware_launch</code> and <code>autoware.universe</code> packages.</p> <p> </p>      Autoware perception launch flow diagram    <p>Note</p> <p>The Autoware project is a large project. Therefore, as we manage the Autoware project, we utilize specific arguments in the launch files. ROS 2 offers an argument-overriding feature for these launch files. Please refer to the official ROS 2 launch documentation for further information. For instance, if we define an argument at the top-level launch, it will override the value on lower-level launches.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/perception/#tier4_perception_componentlaunchxml","title":"tier4_perception_component.launch.xml","text":"<p>The <code>tier4_perception_component.launch.xml</code> launch file is the main perception component launch at the <code>autoware_launch</code> package. This launch file calls <code>perception.launch.xml</code> at tier4_perception_launch package from <code>autoware.universe</code> repository. We can modify perception launch arguments at tier4_perception_component.launch.xml. Also, we can add any other necessary arguments that we want to change it since <code>tier4_perception_component.launch.xml</code> is the top-level launch file of other perception launch files. Here are some predefined perception launch arguments:</p> <ul> <li> <p><code>occupancy_grid_map_method:</code> This argument determines the occupancy grid map method for perception stack. Please check probabilistic_occupancy_grid_map package for detailed information.   The default probabilistic occupancy grid map method is <code>pointcloud_based_occupancy_grid_map</code>.   If you want to change it to the <code>laserscan_based_occupancy_grid_map</code>, you can change it here:</p> <pre><code>- &lt;arg name=\"occupancy_grid_map_method\" default=\"pointcloud_based_occupancy_grid_map\" description=\"options: pointcloud_based_occupancy_grid_map, laserscan_based_occupancy_grid_map\"/&gt;\n+ &lt;arg name=\"occupancy_grid_map_method\" default=\"laserscan_based_occupancy_grid_map\" description=\"options: pointcloud_based_occupancy_grid_map, laserscan_based_occupancy_grid_map\"/&gt;\n</code></pre> </li> </ul> <ul> <li> <p><code>detected_objects_filter_method:</code> This argument determines the filter method for detected objects.   Please check detected_object_validation package for detailed information about lanelet and position filter.   The default detected object filter method is <code>lanelet_filter</code>.   If you want to change it to the <code>position_filter</code>, you can change it here:</p> <pre><code>- &lt;arg name=\"detected_objects_filter_method\" default=\"lanelet_filter\" description=\"options: lanelet_filter, position_filter\"/&gt;\n+ &lt;arg name=\"detected_objects_filter_method\" default=\"position_filter\" description=\"options: lanelet_filter, position_filter\"/&gt;\n</code></pre> </li> </ul> <ul> <li> <p><code>detected_objects_validation_method:</code> This argument determines the validation method for detected objects.   Please check detected_object_validation package for detailed information about validation methods.   The default detected object filter method is <code>obstacle_pointcloud</code>.   If you want to change it to the <code>occupancy_grid</code>, you can change it here,   but remember it requires <code>laserscan_based_occupancy_grid_map</code> method as <code>occupancy_grid_map_method</code>:</p> <pre><code>- &lt;arg name=\"occupancy_grid_map_method\" default=\"pointcloud_based_occupancy_grid_map\" description=\"options: pointcloud_based_occupancy_grid_map, laserscan_based_occupancy_grid_map\"/&gt;\n+ &lt;arg name=\"occupancy_grid_map_method\" default=\"laserscan_based_occupancy_grid_map\" description=\"options: pointcloud_based_occupancy_grid_map, laserscan_based_occupancy_grid_map\"/&gt;\n &lt;arg\n  name=\"detected_objects_validation_method\"\n- default=\"obstacle_pointcloud\"\n+ default=\"occupancy_grid\"\n description=\"options: obstacle_pointcloud, occupancy_grid (occupancy_grid_map_method must be laserscan_based_occupancy_grid_map)\"\n  /&gt;\n</code></pre> </li> </ul> <p>Note</p> <p>You can also use this arguments as command line arguments: </p><pre><code>ros2 launch autoware_launch autoware.launch.xml ... detected_objects_filter_method:=lanelet_filter occupancy_grid_map_method:=laserscan_based_occupancy_grid_map ...\n</code></pre> <p>The predefined <code>tier4_perception_component.launch.xml</code> arguments explained above, but there is the lot of perception arguments included in <code>perception.launch.xml</code> launch file at tier4_perception_launch. Since we didn't fork <code>autoware.universe</code> repository, we can add the necessary launch argument to tier4_perception_component.launch.xml file. Please follow the guidelines for some examples.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/perception/#perceptionlaunchxml","title":"perception.launch.xml","text":"<p>The <code>perception.launch.xml</code> launch file is the main perception launch at the <code>autoware.universe</code>. This launch file calls necessary perception launch files as we mentioned <code>Autoware perception launch flow diagram</code> above. The top-level launch file of <code>perception.launch.xml</code> is <code>tier4_perception_component.launch.xml</code>, so if we want to change anything on <code>perception.launch.xml</code>, we will apply these changes <code>tier4_perception_component.launch.xml</code> instead of <code>perception.launch.xml</code>.</p> <p>Here are some example changes for the perception pipeline:</p> <ul> <li> <p><code>remove_unknown:</code> This parameter determines the remove unknown objects at camera-lidar fusion.   Please check roi_cluster_fusion node for detailed information.   The default value is <code>true</code>.   If you want to change it to the <code>false</code>,   you can add this argument to <code>tier4_perception_component.launch.xml</code>,   so it will override the <code>perception.launch.xml</code>'s <code>argument</code>:</p> <pre><code>+ &lt;arg name=\"remove_unknown\" default=\"false\"/&gt;\n</code></pre> </li> </ul> <ul> <li> <p><code>camera topics:</code> If you are using camera-lidar fusion or camera-lidar-radar fusion as a perception_mode,   you can add your camera and info topics on <code>tier4_perception_component.launch.xml</code> as well,   it will override the <code>perception.launch.xml</code> launch file arguments:</p> <pre><code>+ &lt;arg name=\"image_raw0\" default=\"/sensing/camera/camera0/image_rect_color\" description=\"image raw topic name\"/&gt;\n+ &lt;arg name=\"camera_info0\" default=\"/sensing/camera/camera0/camera_info\" description=\"camera info topic name\"/&gt;\n+ &lt;arg name=\"detection_rois0\" default=\"/perception/object_recognition/detection/rois0\" description=\"detection rois output topic name\"/&gt;\n...\n</code></pre> </li> </ul> <p>You can add every necessary argument to <code>tier4_perception_component.launch.xml</code> launch file like these examples.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/planning/","title":"Planning Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/planning/#planning-launch-files","title":"Planning Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/planning/#overview","title":"Overview","text":"<p>The Autoware planning stacks start launching at <code>autoware_launch.xml</code> as mentioned on the Launch Autoware page. The <code>autoware_launch</code> package includes <code>tier4_planning_component.launch.xml</code> for initiating planning launch files invocation from <code>autoware_launch.xml</code>. The diagram below illustrates the flow of Autoware planning launch files within the autoware_launch and autoware.universe packages.</p> <p> </p>      Autoware planning launch flow diagram    <p>Note</p> <p>The Autoware project is a large project. Therefore, as we manage the Autoware project, we utilize specific arguments in the launch files. ROS 2 offers an argument-overriding feature for these launch files. Please refer to the official ROS 2 launch documentation for further information. For instance, if we define an argument at the top-level launch, it will override the value on lower-level launches.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/planning/#tier4_planning_componentlaunchxml","title":"tier4_planning_component.launch.xml","text":"<p>The <code>tier4_planning_component.launch.xml</code> launch file is the main planning component launch at the <code>autoware_launch</code> package. This launch file calls <code>planning.launch.xml</code> at tier4_planning_launch package from <code>autoware.universe</code> repository. We can modify planning launch arguments at tier4_planning_component.launch.xml. Also, we can add any other necessary arguments that we want to change it since <code>tier4_planning_component.launch.xml</code> is the top-level launch file of other planning launch files. Here are some predefined planning launch arguments:</p> <ul> <li> <p><code>use_experimental_lane_change_function:</code> This argument enables   <code>enable_collision_check_at_prepare_phase</code>, <code>use_predicted_path_outside_lanelet</code>,   and <code>use_all_predicted_path</code> options for Autoware for experimental lane changing   (for more information, please refer to lane_change documentation).   The default value is True.   To set it to False, make the following change in the <code>tier4_planning_component.launch.xml</code> file:</p> <pre><code>- &lt;arg name=\"use_experimental_lane_change_function\" default=\"true\"/&gt;\n+ &lt;arg name=\"use_experimental_lane_change_function\" default=\"false\"/&gt;\n</code></pre> </li> </ul> <ul> <li> <p><code>cruise_planner_type:</code> There are two types of cruise planners in Autoware: obstacle_stop_planner   and obstacle_cruise_planner. For specifications on these cruise planner types,   please refer to the package documentation. The default cruise planner is <code>obstacle_stop_planner</code>.   To change it to obstacle_cruise_planner, update the argument value in the <code>tier4_planning_component.launch.xml</code> file:</p> <pre><code>- &lt;arg name=\"cruise_planner_type\" default=\"obstacle_stop_planner\" description=\"options: obstacle_stop_planner, obstacle_cruise_planner, none\"/&gt;\n+ &lt;arg name=\"cruise_planner_type\" default=\"obstacle_cruise_planner\" description=\"options: obstacle_stop_planner, obstacle_cruise_planner, none\"/&gt;\n</code></pre> </li> </ul> <ul> <li> <p><code>use_surround_obstacle_check:</code> This argument enables the surround_obstacle_checker   for Autoware. If you want to disable it, you can do in the   <code>tier4_planning_component.launch.xml</code> file:</p> <pre><code>- &lt;arg name=\"use_surround_obstacle_check\" default=\"true\"/&gt;\n+ &lt;arg name=\"use_surround_obstacle_check\" default=\"false\"/&gt;\n</code></pre> </li> </ul> <ul> <li> <p><code>velocity_smoother_type:</code> This argument specifies the type of smoother   for the motion_velocity_smoother package. Please consult the documentation   for detailed information about available smoother types. For instance, if   you wish to change your smoother type from JerkFiltered to L2, you can do   in the tier4_planning_component.launch.xml file.:</p> <pre><code>- &lt;arg name=\"velocity_smoother_type\" default=\"JerkFiltered\" description=\"options: JerkFiltered, L2, Analytical, Linf(Unstable)\"/&gt;\n+ &lt;arg name=\"velocity_smoother_type\" default=\"L2\" description=\"options: JerkFiltered, L2, Analytical, Linf(Unstable)\"/&gt;\n</code></pre> </li> </ul> <p>Note</p> <p>You can also use this arguments as command line arguments: </p><pre><code>ros2 launch autoware_launch autoware.launch.xml ... use_surround_obstacle_check:=false velocity_smoother_type:=L2 ...\n</code></pre> <p>The predefined arguments in tier4_planning_component.launch.xml have been explained above. However, numerous planning arguments are included in the autoware_launch planning config parameters.</p>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/sensing/","title":"Sensing Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/sensing/#sensing-launch-files","title":"Sensing Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/sensing/#overview","title":"Overview","text":"<p>The Autoware sensing stacks start launching at <code>autoware_launch.xml</code> as we mentioned at Launch Autoware page. The <code>autoware_launch</code> package includes <code>tier4_sensing_component.launch.xml</code> for starting sensing launch files invocation from <code>autoware_launch.xml</code>. This diagram describes some of the Autoware sensing launch files flow at <code>autoware_launch</code> and <code>autoware.universe</code> packages.</p> <p> </p>      Autoware sensing launch flow diagram    <p>Note</p> <p>The Autoware project is a large project. Therefore, as we manage the Autoware project, we utilize specific arguments in the launch files. ROS 2 offers an argument-overriding feature for these launch files. Please refer to the official ROS 2 launch documentation for further information. For instance, if we define an argument at the top-level launch, it will override the value on lower-level launches.</p> <p>The sensing launch is more related to your sensor kit, so if you want to modify your launch, we recommend applying these modifications to the  packages. Please look at creating sensor and vehicle model pages for more information but there is are some modifications on which can you done at top-level launch files.</p> <p>For example, if you do not want to launch the sensor driver with Autoware, you can disable it with a command-line argument:</p> <pre><code>ros2 launch autoware_launch autoware.launch.xml ... launch_sensing_driver:=false ...\n</code></pre> <p>Or you can change it on your <code>autoware.launch.xml</code> launch file:</p> <pre><code>- &lt;arg name=\"launch_sensing_driver\" default=\"true\" description=\"launch sensing driver\"/&gt;\n+ &lt;arg name=\"launch_sensing_driver\" default=\"false\" description=\"launch sensing driver\"/&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/system/","title":"System Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/system/#system-launch-files","title":"System Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/system/#overview","title":"Overview","text":"<p>The Autoware system stacks start launching at <code>autoware_launch.xml</code> as we mentioned at Launch Autoware page. The <code>autoware_launch</code> package includes <code>tier4_system_component.launch.xml</code> for starting system launch files invocation from <code>autoware_launch.xml</code>. This diagram describes some of the Autoware system launch files flow at <code>autoware_launch</code> and <code>autoware.universe</code> packages.</p> <p> </p>      Autoware system launch flow diagram    <p>Note</p> <p>The Autoware project is a large project. Therefore, as we manage the Autoware project, we utilize specific arguments in the launch files. ROS 2 offers an argument-overriding feature for these launch files. Please refer to the official ROS 2 launch documentation for further information. For instance, if we define an argument at the top-level launch, it will override the value on lower-level launches.</p> <p>As described in the flow diagram of the system launch pipeline, the <code>system.launch.xml</code> from the <code>tier4_system_launch</code> package directly launches the following packages:</p> <ul> <li>system_monitor</li> <li>component_interface_tools</li> <li>component_state_monitor</li> <li>system_error_monitor</li> <li>emergency_handler</li> <li>duplicated_node_checker</li> <li>mrm_comfortable_stop_operator</li> <li>mrm_emergency_stop_operator</li> <li>dummy_diag_publisher</li> </ul> <p>We don't have many modification options in the system launching files (as the parameters are included in config files), but you can modify the file path for the system_error_monitor parameter. For instance, if you want to change the path for your system_error_monitor.param.yaml file, you can run Autoware with the following command line argument:</p> <pre><code>ros2 launch autoware_launch autoware.launch.xml ... system_error_monitor_param_path:=&lt;YOUR-SYSTEM-ERROR-PARAM-PATH&gt; ...\n</code></pre> <p>Or you can change it on your <code>tier4_system_component.launch.xml</code> launch file:</p> <pre><code>- &lt;arg name=\"system_error_monitor_param_path\" default=\"$(find-pkg-share autoware_launch)/config/...\"/&gt;\n+ &lt;arg name=\"system_error_monitor_param_path\" default=\"&lt;YOUR-SYSTEM-ERROR-PARAM-PATH&gt;\"/&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/launch-autoware/vehicle/","title":"Vehicle Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/vehicle/#vehicle-launch-files","title":"Vehicle Launch Files","text":""},{"location":"how-to-guides/integrating-autoware/launch-autoware/vehicle/#overview","title":"Overview","text":"<p>The Autoware vehicle stacks begin launching with autoware_launch.xml as mentioned on the Launch Autoware page, and the tier4_vehicle.launch.xml is called in this context. The following diagram describes some of the Autoware vehicle launch file flow within the <code>autoware_launch</code> and <code>autoware.universe</code> packages.</p> <p> </p>      Autoware vehicle launch flow diagram    <p>Note</p> <p>The Autoware project is a large project. Therefore, as we manage the Autoware project, we utilize specific arguments in the launch files. ROS 2 offers an argument-overriding feature for these launch files. Please refer to the official ROS 2 launch documentation for further information. For instance, if we define an argument at the top-level launch, it will override the value on lower-level launches.</p> <p>We don't have many modification options in the vehicle launching files (as the parameters are included in the vehicle_launch repository), but you can choose to disable the vehicle_interface launch. For instance, if you want to run robot_state_publisher but not vehicle_interface, you can launch Autoware with the following command line arguments:</p> <pre><code>ros2 launch autoware_launch autoware.launch.xml ... launch_vehicle_interface:=false ...\n</code></pre> <p>Or you can change it on your <code>autoware.launch.xml</code> launch file:</p> <pre><code>- &lt;arg name=\"launch_vehicle_interface\" default=\"true\" description=\"launch vehicle interface\"/&gt;\n+ &lt;arg name=\"launch_vehicle_interface\" default=\"false\" description=\"launch vehicle interface\"/&gt;\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/","title":"Evaluating the controller performance","text":""},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#evaluating-the-controller-performance","title":"Evaluating the controller performance","text":"<p>This page shows how to use <code>control_performance_analysis</code> package to evaluate the controllers.</p> <p><code>control_performance_analysis</code> is the package to analyze the tracking performance of a control module and monitor the driving status of the vehicle.</p> <p>If you need more detailed information about package, refer to the control_performance_analysis.</p>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#how-to-use","title":"How to use","text":""},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#before-driving","title":"Before Driving","text":""},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#1-firstly-you-need-to-launch-autoware-you-can-also-use-this-tool-with-real-vehicle-driving","title":"1. Firstly you need to launch Autoware. You can also use this tool with real vehicle driving","text":""},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#2-initialize-the-vehicle-and-send-goal-position-to-create-route","title":"2. Initialize the vehicle and send goal position to create route","text":"<ul> <li>If you have any problem with launching Autoware, please see the tutorials page.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#3-launch-the-control_performance_analysis-package","title":"3. Launch the control_performance_analysis package","text":"<pre><code>ros2 launch control_performance_analysis control_performance_analysis.launch.xml\n</code></pre> <ul> <li>After this command, you should be able to see the driving monitor and error variables in topics.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#4-run-the-plotjuggler-in-sourced-terminal","title":"4. Run the PlotJuggler in sourced terminal","text":"<pre><code>source ~/autoware/install/setup.bash\n</code></pre> <pre><code>ros2 run plotjuggler plotjuggler\n</code></pre> <ul> <li>If you do not have PlotJuggler in your computer, please refer here for installation guideline.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#5-increase-the-buffer-size-maximum-is-100-and-import-the-layout-from-autowareuniversecontrolcontrol_performance_analysisconfigcontroller_monitorxml","title":"5. Increase the buffer size (maximum is 100), and import the layout from <code>/autoware.universe/control/control_performance_analysis/config/controller_monitor.xml</code>","text":"<ul> <li>After import the layout, please specify the topics that are listed below.</li> </ul> <ul> <li>/localization/kinematic_state</li> <li>/vehicle/status/steering_status</li> <li>/control_performance/driving_status</li> <li>/control_performance/performance_vars</li> </ul> <ul> <li>Please mark the <code>If present, use the timestamp in the field [header.stamp]</code> box, then select the OK.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#6-now-you-can-start-to-driving-you-should-see-all-the-performance-and-driving-variables-in-plotjuggler","title":"6. Now, you can start to driving. You should see all the performance and driving variables in PlotJuggler","text":""},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#after-driving","title":"After Driving","text":""},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#1-you-can-export-the-statistical-output-and-all-data-to-compare-and-later-usage","title":"1. You can export the statistical output and all data to compare and later usage","text":"<ul> <li>With statistical data, you can export the all statistical values like (min, max, average) to compare the controllers.</li> </ul> <ul> <li>You can also export all data to later use. To investigate them again, after launch PlotJuggler, import the <code>.cvs</code> file from data section.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-controller-performance/#tips","title":"Tips","text":"<ul> <li>You can plot the vehicle position. Select the two curve (keeping CTRL key pressed) and Drag &amp; Drop them using the RIGHT Mouse button. Please visit the <code>Help -&gt; Cheatsheet</code> in PlotJuggler to see more tips about it.</li> </ul> <ul> <li>If you see too much noised curve in plots, you can adjust the <code>odom_interval</code> and <code>low_pass_filter_gain</code> from here to avoid noised data.</li> </ul>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/","title":"Evaluating real-time performance","text":""},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#evaluating-real-time-performance","title":"Evaluating real-time performance","text":""},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#introduction","title":"Introduction","text":"<p>Autoware should be real-time system when integrated to a service. Therefore, the response time of each callback should be as small as possible. If Autoware appears to be slow, it is imperative to conduct performance measurements and implement improvements based on the analysis. However, Autoware is a complex software system comprising numerous ROS 2 nodes, potentially complicating the process of identifying bottlenecks. To address this challenge, we will discuss methods for conducting detailed performance measurements for Autoware and provide case studies. It is worth noting that multiple factors can contribute to poor performance, such as scheduling and memory allocation in the OS layer, but our focus in this page will be on user code bottlenecks. The outline of this section is as follows:</p> <ul> <li>Performance measurement<ul> <li>Single node execution</li> <li>Prepare separated cores</li> <li>Run single node separately</li> <li>Measurement and visualization</li> </ul> </li> <li>Case studies<ul> <li>Sensing component</li> <li>Planning component</li> </ul> </li> </ul>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#performance-measurement","title":"Performance measurement","text":"<p>Improvement is impossible without precise measurements. To measure the performance of the application code, it is essential to eliminate any external influences. Such influences include interference from the operating system and CPU frequency fluctuations. Scheduling effects also occur when core resources are shared by multiple threads. This section outlines a technique for accurately measuring the performance of the application code for a specific node. Though this section only discusses the case of Linux on Intel CPUs, similar considerations should be made in other environments.</p>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#single-node-execution","title":"Single node execution","text":"<p>To eliminate the influence of scheduling, the node being measured should operate independently, using the same logic as when the entire Autoware system is running. To accomplish this, record all input topics of the node to be measured while the whole Autoware system is running. To achieve this objective, a tool called <code>ros2_single_node_replayer</code> has been prepared.</p> <p>Details on how to use the tool can be found in the README. This tool records the input topics of a specific node during the entire Autoware operation and replays it in a single node with the same logic. The tool relies on the <code>ros2 bag record</code> command, and the recording of service/action is not supported as of ROS 2 Humble, so nodes that use service/action as their main logic may not work well.</p>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#prepare-separated-cores","title":"Prepare separated cores","text":"<p>Isolated cores running the node to be measured must meet the following conditions.</p> <ul> <li>Fix CPU frequency and disable turbo boost</li> <li>Minimize timer interruptions</li> <li>Offload RCU (Read Copy Update) callback</li> <li>Isolate the paired core if hyper-threading enabled</li> </ul> <p>To fulfill these conditions on Linux, a custom kernel build with the following kernel configurations is required. You can find many resources to instruct you on how to build a custom Linux kernel (like this one). Note that even if full tickless is enabled, timer interrupts are generated for scheduling if more than two tasks exist in one core.</p> <pre><code># Enable CONFIG_NO_HZ_FULL\n-&gt; General setup\n-&gt; Timers subsystem\n-&gt; Timer tick handling (Full dynticks system (tickless))\n(X) Full dynticks system (tickless)\n\n# Allows RCU callback processing to be offloaded from selected CPUs\n# (CONFIG_RCU_NOCB_CPU=y)\n-&gt; General setup\n-&gt; RCU Subsystem\n-*- Offload RCU callback processing from boot-selected CPUs\n</code></pre> <p>Additionally, the kernel boot parameters need to be set as follows.</p> <pre><code>GRUB_CMDLINE_LINUX_DEFAULT=\n  \"... isolcpus=2,8 rcu_nocbs=2,8 rcu_nocb_poll nohz_full=2,8 intel_pstate=disable\u201d\n</code></pre> <p>In the above configuration, for example, the node to be measured is assumed to run on core 2, and core 8, which is a hyper-threading pair, is also being isolated. Appropriate decisions on which cores to run the measurement target and which nodes to isolate need to be made based on the cache and core layout of the measurement machine. You can easily check if it is properly configured by running <code>cat /proc/softirqs</code>. Since <code>intel_pstate=disable</code> is specified in the kernel boot parameter, <code>userspace</code> can be specified in the scaling governor.</p> <pre><code>cat /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor // ondemand\nsudo sh -c \"echo userspace &gt; /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor\"\n</code></pre> <p>This allows you to freely set the desired frequency within a defined range.</p> <pre><code>sudo sh -c \"echo &lt;freq(kz)&gt; &gt; /sys/devices/system/cpu/cpu2/cpufreq/scaling_setspeed\"\n</code></pre> <p>Turbo Boost needs to be switched off on Intel CPUs, which is often overlooked.</p> <pre><code>sudo sh -c \"echo 0 &gt; /sys/devices/system/cpu/cpufreq/boost\"\n</code></pre>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#run-single-node-separately","title":"Run single node separately","text":"<p>Following the instructions in the <code>ros2_single_node_replayer</code> README, start the node and play the dedicated rosbag created by the tool. Before playing the rosbag, appropriately set the CPU affinity of the thread on which the node runs, so it is placed on the isolated core prepared.</p> <pre><code>taskset --cpu-list -p &lt;target cpu&gt; &lt;pid&gt;\n</code></pre> <p>To avoid interference in the last level cache, minimize the number of other applications running during the measurement.</p>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#measurement-and-visualization","title":"Measurement and visualization","text":"<p>To visualize the performance of the measurement target, embed code for logging timestamps and performance counter values in the target source code. To achieve this objective, a tool called <code>pmu_analyzer</code> has been prepared.</p> <p>Details on how to use the tool can be found in the README. This tool can measure the turnaround time of any section in the source code, as well as various performance counters.</p>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#case-studies","title":"Case studies","text":"<p>In this section, we will present several case studies that demonstrate the performance improvements. These examples not only showcase our commitment to enhancing the system's efficiency but also serve as a valuable resource for developers who may face similar challenges in their own projects. The performance improvements discussed here span various components of the Autoware system, including sensing modules and planning modules. There are tendencies for each component regarding which points are becoming bottlenecks. By examining the methods, techniques, and tools employed in these case studies, readers can gain a better understanding of the practical aspects of optimizing complex software systems like Autoware.</p>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#sensing-component","title":"Sensing component","text":"<p>First, we will explain the procedure for performance improvement, taking the node <code>ring_outlier_filter</code> as an example. Refer to the Pull Request for details.</p> <p>The following figure is a time-series plot of the turnaround time of the main processing part of <code>ring_outlier_filter</code>, analyzed as described in the \"Performance Measurement\" section above.</p> <p></p> <p>The horizontal axis indicates the number of callbacks called (i.e., callback index), and the vertical axis indicates the turnaround time.</p> <p>When analyzing the performance of the sensing module from the viewpoint of performance counter, pay attention to <code>instructions</code>, <code>LLC-load-misses</code>, <code>LLC-store-misses</code>, <code>cache-misses</code>, and <code>minor-faults</code>.</p> <p>Analysis of the performance counter shows that the largest fluctuations come from <code>minor-faults</code> (i.e., soft page faults), the second largest from <code>LLC-store-misses</code> and <code>LLC-load-misses</code> (i.e., cache misses in the last level cache), and the slowest fluctuations come from instructions (i.e., message data size fluctuations). For example, when we plot <code>minor-faults</code> on the horizontal axis and turnaround time on the vertical axis, we can see the following dominant proportional relationship.</p> <p></p> <p>To achieve zero soft page faults, heap allocations must only be made from areas that have been first touched in advance. We have developed a library called <code>heaphook</code> to avoid soft page faults while running Autoware callback. If you are interested, refer to the GitHub discussion and the issue.</p> <p>To reduce LLC misses, it is necessary to reduce the working set and to use cache-efficient access patterns.</p> <p>In the sensing component, which handles large message data such as LiDAR point cloud data, minimizing copying is important. A callback that takes sensor data message types as input and output should be written in an in-place algorithm as much as possible. This means that in the following pseudocode, when generating <code>output_msg</code> from <code>input_msg</code>, it is crucial to avoid using buffers as much as possible to reduce the number of memory copies.</p> <pre><code>void callback(const PointCloudMsg &amp;input_msg) {\nauto output_msg = allocate_msg&lt;PointCloudMsg&gt;(output_size);\nfill(input_msg, output_msg);\npublish(std::move(output_msg));\n}\n</code></pre> <p>To improve cache efficiency, implement an in-place style as much as possible, instead of touching memory areas sporadically. In ROS applications using PCL, the code shown below is often seen.</p> <pre><code>void callback(const sensor_msgs::PointCloud2ConstPtr &amp;input_msg) {\npcl::PointCloud&lt;PointT&gt;::Ptr input_pcl(new pcl::PointCloud&lt;PointT&gt;);\npcl::fromROSMsg(*input_msg, *input_pcl);\n\n// Algorithm is described for point cloud type of pcl\npcl::PointCloud&lt;PointT&gt;::Ptr output_pcl(new pcl::PointCloud&lt;PointT&gt;);\nfill_pcl(*input_pcl, *output_pcl);\n\nauto output_msg = allocate_msg&lt;sensor_msgs::PointCloud2&gt;(output_size);\npcl::toROSMsg(*output_pcl, *output_msg);\npublish(std::move(output_msg));\n}\n</code></pre> <p>To use the PCL library, <code>fromROSMsg()</code> and <code>toROSMsg()</code> are used to perform message type conversion at the beginning and end of the callback. This is a wasteful copying process and should be avoided. We should eliminate unnecessary type conversions by removing dependencies on PCL (e.g., https://github.com/tier4/velodyne_vls/pull/39). For large message types such as map data, there should be only one instance in the entire system in terms of physical memory.</p>"},{"location":"how-to-guides/integrating-autoware/tuning-parameters-and-performance/evaluating-real-time-performance/#planning-component","title":"Planning component","text":"<p>First, we will pick up <code>detection_area</code> module in <code>behavior_velocity_planner</code> node, which tends to have long turnaround time. We have followed the performance analysis steps above to obtain the following graph. Axises are the same as the graphs in the sensing case study.</p> <p></p> <p>Using <code>pmu_analyzer</code> tool to further identify the bottleneck, we have found that the following multiple loops were taking up a lot of processing time:</p> <pre><code>for ( area : detection_areas )\nfor ( point : point_clouds )\nif ( boost::geometry::within(point, area) )\n// do something with O(1)\n</code></pre> <p>It checks whether each point cloud is contained in each detection area. Let <code>N</code> be the size of <code>point_clouds</code> and <code>M</code> be the size of <code>detection_areas</code>, then the computational complexity of this program is O(N^2 * M), since the complexity of <code>within</code> is O(N). Here, given that most of the point clouds are located far away from a certain detection area, a certain optimization can be achieved. First, calculate the minimum enclosing circle that completely covers the detection area, and then check whether the points are contained in that circle. Most of the point clouds can be quickly ruled out by this method, we don\u2019t have to call the <code>within</code> function in most cases. Below is the pseudocode after optimization.</p> <pre><code>for ( area : detection_areas )\ncircle = calc_minimum_enclosing_circle(area)\nfor ( point : point_clouds )\nif ( point is in circle )\nif ( boost::geometry::within(point, area) )\n// do something with O(1)\n</code></pre> <p>By using O(N) algorithm for minimum enclosing circle, the computational complexity of this program is reduced to almost O(N * (N + M)) (note that the exact computational complexity does not really change). If you are interested, refer to the Pull Request.</p> <p>Similar to this example, in the planning component, we take into consideration thousands to tens of thousands of point clouds, thousands of points in a path representing our own route, and polygons representing obstacles and detection areas in the surroundings, and we repeatedly create paths based on them. Therefore, we access the contents of the point clouds and paths multiple times using for-loops. In most cases, the bottleneck lies in these naive for-loops. Here, understanding Big O notation and reducing the order of computational complexity directly leads to performance improvements.</p>"},{"location":"how-to-guides/others/add-a-custom-ros-message/","title":"Add a custom ROS message","text":""},{"location":"how-to-guides/others/add-a-custom-ros-message/#add-a-custom-ros-message","title":"Add a custom ROS message","text":""},{"location":"how-to-guides/others/add-a-custom-ros-message/#overview","title":"Overview","text":"<p>During the Autoware development, you will probably need to define your own messages. Read the following instructions before adding a custom message.</p> <ol> <li> <p>Message in autoware_msgs define interfaces of <code>Autoware Core</code>.</p> <ul> <li>If a contributor wishes to make changes or add new messages to <code>autoware_msgs</code>, they should first create a new discussion post under the Design category.</li> </ul> </li> <li> <p>Any other minor or proposal messages used for internal communication within a component(such as planning) should be defined in another repository.</p> <ul> <li>tier4_autoware_msgs is an example of that.</li> </ul> </li> </ol> <p>The following is a simple tutorial of adding a message package to <code>autoware_msgs</code>. For the general ROS 2 tutorial, see Create custom msg and srv files.</p>"},{"location":"how-to-guides/others/add-a-custom-ros-message/#how-to-create-custom-message","title":"How to create custom message","text":"<p>Make sure you are in the Autoware workspace, and then run the following command to create a new package. As an example, let's create a package to define sensor messages.</p> <ol> <li> <p>Create a package</p> <pre><code>cd ./src/core/autoware_msgs\nros2 pkg create --build-type ament_cmake autoware_sensing_msgs\n</code></pre> </li> <li> <p>Create custom messages</p> <p>You should create <code>.msg</code> files and place them in the <code>msg</code> directory.</p> <p>NOTE: The initial letters of the <code>.msg</code> and <code>.srv</code> files must be capitalized.</p> <p>As an example, let's make <code>.msg</code> files <code>GnssInsOrientation.msg</code> and <code>GnssInsOrientationStamped.msg</code> to define GNSS/INS orientation messages:</p> <pre><code>mkdir msg\ncd msg\ntouch GnssInsOrientation.msg\ntouch GnssInsOrientationStamped.msg\n</code></pre> <p>Edit <code>GnssInsOrientation.msg</code> with your editor to be the following content:</p> <pre><code>geometry_msgs/Quaternion orientation\nfloat32 rmse_rotation_x\nfloat32 rmse_rotation_y\nfloat32 rmse_rotation_z\n</code></pre> <p>In this case, the custom message uses a message from another message package <code>geometry_msgs/Quaternion</code>.</p> <p>Edit <code>GnssInsOrientationStamped.msg</code> with your editor to be the following content:</p> <pre><code>std_msgs/Header header\nGnssInsOrientation orientation\n</code></pre> <p>In this case, the custom message uses a message from another message package <code>std_msgs/Header</code>.</p> </li> <li> <p>Edit CMakeLists.txt</p> <p>In order to use this custom message in <code>C++</code> or <code>Python</code> languages, we need to add the following lines to <code>CMakeList.txt</code>:</p> <pre><code>rosidl_generate_interfaces(${PROJECT_NAME}\n\"msg/GnssInsOrientation.msg\"\n\"msg/GnssInsOrientationStamped.msg\"\nDEPENDENCIES\ngeometry_msgs\nstd_msgs\nADD_LINTER_TESTS\n)\n</code></pre> <p> The <code>ament_cmake_auto</code> tool is very useful and is more widely used in Autoware, so we recommend using <code>ament_cmake_auto</code> instead of <code>ament_cmake</code>.</p> <p>We need to replace</p> <pre><code>find_package(ament_cmake REQUIRED)\n\nament_package()\n</code></pre> <p>with</p> <pre><code>find_package(ament_cmake_auto REQUIRED)\n\nament_auto_package()\n</code></pre> </li> <li> <p>Edit package.xml</p> <p>We need to declare relevant dependencies in <code>package.xml</code>. For the above example we need to add the following content:</p> <pre><code>&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;\n\n&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;\n\n&lt;depend&gt;geometry_msgs&lt;/depend&gt;\n&lt;depend&gt;std_msgs&lt;/depend&gt;\n\n&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;\n</code></pre> <p>We need to replace <code>&lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;</code> with <code>&lt;buildtool_depend&gt;ament_cmake_auto&lt;/buildtool_depend&gt;</code> in the <code>package.xml</code> file.</p> </li> <li> <p>Build the custom message package</p> <p>You can build the package in the root of your workspace, for example by running the following command:</p> <pre><code>colcon build --packages-select autoware_sensing_msgs\n</code></pre> <p>Now the <code>GnssInsOrientationStamped</code> message will be discoverable by other packages in Autoware.</p> </li> </ol>"},{"location":"how-to-guides/others/add-a-custom-ros-message/#how-to-use-custom-messages-in-autoware","title":"How to use custom messages in Autoware","text":"<p>You can use the custom messages in Autoware by following these steps:</p> <ul> <li>Add dependency in <code>package.xml</code>.<ul> <li>For example, <code>&lt;depend&gt;autoware_sensing_msgs&lt;/depend&gt;</code>.</li> </ul> </li> <li>Include the <code>.hpp</code> file of the relevant message in the code.<ul> <li>For example, <code>#include &lt;autoware_sensing_msgs/msg/gnss_ins_orientation_stamped.hpp&gt;</code>.</li> </ul> </li> </ul>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/","title":"Advanced usage of colcon","text":""},{"location":"how-to-guides/others/advanced-usage-of-colcon/#advanced-usage-of-colcon","title":"Advanced usage of colcon","text":"<p>This page shows some advanced and useful usage of <code>colcon</code>. If you need more detailed information, refer to the colcon documentation.</p>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#common-mistakes","title":"Common mistakes","text":""},{"location":"how-to-guides/others/advanced-usage-of-colcon/#do-not-run-from-other-than-the-workspace-root","title":"Do not run from other than the workspace root","text":"<p>It is important that you always run <code>colcon build</code> from the workspace root because <code>colcon</code> builds only under the current directory. If you have mistakenly built in a wrong directory, run <code>rm -rf build/ install/ log/</code> to clean the generated files.</p>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#do-not-unnecessarily-overlay-workspaces","title":"Do not unnecessarily overlay workspaces","text":"<p><code>colcon</code> overlays workspaces if you have sourced the <code>setup.bash</code> of other workspaces before building a workspace. You should take care of this especially when you have multiple workspaces.</p> <p>Run <code>echo $COLCON_PREFIX_PATH</code> to check whether workspaces are overlaid. If you find some workspaces are unnecessarily overlaid, remove all built files, restart the terminal to clean environment variables, and re-build the workspace.</p> <p>For more details about <code>workspace overlaying</code>, refer to the ROS 2 documentation.</p>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#cleaning-up-the-build-artifacts","title":"Cleaning up the build artifacts","text":"<p><code>colcon</code> sometimes causes errors of because of the old cache. To remove the cache and rebuild the workspace, run the following command:</p> <pre><code>rm -rf build/ install/\n</code></pre> <p>In case you know what packages to remove:</p> <pre><code>rm -rf {build,install}/{package_a,package_b}\n</code></pre>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#selecting-packages-to-build","title":"Selecting packages to build","text":"<p>To just build specified packages:</p> <pre><code>colcon build --packages-select &lt;package_name1&gt; &lt;package_name2&gt; ...\n</code></pre> <p>To build specified packages and their dependencies recursively:</p> <pre><code>colcon build --packages-up-to &lt;package_name1&gt; &lt;package_name2&gt; ...\n</code></pre> <p>You can also use these options for <code>colcon test</code>.</p>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#changing-the-optimization-level","title":"Changing the optimization level","text":"<p>Set <code>DCMAKE_BUILD_TYPE</code> to change the optimization level.</p> <p>Warning</p> <p>If you specify <code>DCMAKE_BUILD_TYPE=Debug</code> or no <code>DCMAKE_BUILD_TYPE</code> is given for building the entire Autoware, it may be too slow to use.</p> <pre><code>colcon build --cmake-args -DCMAKE_BUILD_TYPE=Debug\n</code></pre> <pre><code>colcon build --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo\n</code></pre> <pre><code>colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#changing-the-default-configuration-of-colcon","title":"Changing the default configuration of colcon","text":"<p>Create <code>$COLCON_HOME/defaults.yaml</code> to change the default configuration.</p> <pre><code>mkdir -p ~/.colcon\ncat &lt;&lt; EOS &gt; ~/.colcon/defaults.yaml\n{\n\"build\": {\n\"symlink-install\": true\n}\n}\n</code></pre> <p>For more details, see here.</p>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#generating-compile_commandsjson","title":"Generating compile_commands.json","text":"<p>compile_commands.json is used by IDEs/tools to analyze the build dependencies and symbol relationships.</p> <p>You can generate it with the flag <code>DCMAKE_EXPORT_COMPILE_COMMANDS=1</code>:</p> <pre><code>colcon build --cmake-args -DCMAKE_EXPORT_COMPILE_COMMANDS=1\n</code></pre>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#seeing-compiler-commands","title":"Seeing compiler commands","text":"<p>To see the compiler and linker invocations for a package, use <code>VERBOSE=1</code> and <code>--event-handlers console_cohesion+</code>:</p> <pre><code>VERBOSE=1 colcon build --packages-up-to &lt;package_name&gt; --event-handlers console_cohesion+\n</code></pre> <p>For other options, see here.</p>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#using-ccache-to-speed-up-recompilation","title":"Using Ccache to speed up recompilation","text":"<p>Ccache is a compiler cache that can significantly speed up recompilation by caching previous compilations and reusing them when the same compilation is being done again. It's highly recommended for developers looking to optimize their build times, unless there's a specific reason to avoid it.</p>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#step-1-install-ccache","title":"Step 1: Install Ccache","text":"<pre><code>sudo apt update &amp;&amp; sudo apt install ccache\n</code></pre>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#step-2-configure-ccache","title":"Step 2: Configure Ccache","text":"<ol> <li> <p>Create the Ccache configuration folder and file:</p> <pre><code>mkdir -p ~/.cache/ccache\ntouch ~/.cache/ccache/ccache.conf\n</code></pre> </li> <li> <p>Set the maximum cache size. The default size is <code>5GB</code>, but you can increase it depending on your needs. Here,    we're setting it to <code>60GB</code>:</p> <pre><code>echo \"max_size = 60G\" &gt;&gt; ~/.cache/ccache/ccache.conf\n</code></pre> </li> </ol>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#step-3-integrate-ccache-with-your-environment","title":"Step 3: Integrate Ccache with Your Environment","text":"<p>To ensure Ccache is used for compilation, add the following lines to your <code>.bashrc</code> file. This will redirect GCC and G++ calls through Ccache.</p> <pre><code>export CC=\"/usr/lib/ccache/gcc\"\nexport CXX=\"/usr/lib/ccache/g++\"\nexport CCACHE_DIR=\"$HOME/.cache/ccache/\"\n</code></pre> <p>After adding these lines, reload your <code>.bashrc</code> or restart your terminal session to apply the changes.</p>"},{"location":"how-to-guides/others/advanced-usage-of-colcon/#step-4-verify-ccache-is-working","title":"Step 4: Verify Ccache is Working","text":"<p>To confirm Ccache is correctly set up and being used, you can check the statistics of cache usage:</p> <pre><code>ccache -s\n</code></pre> <p>This command displays the cache hit rate and other relevant statistics, helping you gauge the effectiveness of Ccache in your development workflow.</p>"},{"location":"how-to-guides/others/an-example-procedure-for-adding-and-evaluating-a-new-node/","title":"An example procedure for adding and evaluating a new node","text":""},{"location":"how-to-guides/others/an-example-procedure-for-adding-and-evaluating-a-new-node/#an-example-procedure-for-adding-and-evaluating-a-new-node","title":"An example procedure for adding and evaluating a new node","text":""},{"location":"how-to-guides/others/an-example-procedure-for-adding-and-evaluating-a-new-node/#overview","title":"Overview","text":"<p>This page provides a guide for evaluating Autoware when a new node is implemented, especially about developing a novel localization node.</p> <p>The workflow involves initial testing and rosbag recording using a real vehicle or AWSIM, implementing the new node, subsequent testing using the recorded rosbag, and finally evaluating with a real vehicle or AWSIM.</p> <p>It is assumed that the method intended for addition has already been verified well with public datasets and so on.</p>"},{"location":"how-to-guides/others/an-example-procedure-for-adding-and-evaluating-a-new-node/#1-running-autoware-in-its-standard-configuration","title":"1. Running Autoware in its standard configuration","text":"<p>First of all, it is important to be able to run the standard Autoware to establish a basis for performance and behavior comparison.</p> <p>Autoware constantly incorporates new features. It is crucial to initially confirm that it operates as expected with the current version, which helps in problem troubleshooting.</p> <p>In this context, AWSIM is presumed. Therefore, AWSIM simulator can be useful. If you are using actual hardware, please refer to the How-to guides.</p>"},{"location":"how-to-guides/others/an-example-procedure-for-adding-and-evaluating-a-new-node/#2-recording-a-rosbag-using-autoware","title":"2. Recording a rosbag using Autoware","text":"<p>Before developing a new node, it is recommended to record a rosbag in order to evaluate. If you need a new sensor, you should add it to your vehicle or AWSIM.</p> <p>In this case, it is recommended to save all topics regardless of whether they are necessary or not. For example, in Localization, since the initial position estimation service is triggered by the input to rviz and the GNSS topic, the initial position estimation does not start when playing back data unless those topics are saved.</p> <p>Consider the use of the mcap format if data capacity becomes a concern.</p> <p>It is worth noting that using <code>ros2 bag record</code> increases computational load and might affect performance. After data recording, verifying the smooth flow of sensor data and unchanged time series is advised. This verification can be accomplished, for example, by inspecting the image data with <code>rqt_image_view</code> during <code>ros2 bag play</code>.</p>"},{"location":"how-to-guides/others/an-example-procedure-for-adding-and-evaluating-a-new-node/#3-developing-the-new-node","title":"3. Developing the new node","text":"<p>When developing a new node, it could be beneficial to reference a package that is similar to the one you intend to create.</p> <p>It is advisable to thoroughly read the Design page, contemplate the addition or replacement of nodes in Autoware, and then implement your solution.</p> <p>For example, a node doing NDT, a LiDAR-based localization method, is ndt_scan_matcher. If you want to replace this with a different approach, implement a node which produces the same topics and provides the same services.</p> <p><code>ndt_scan_matcher</code> is launched as pose_estimator, so it is necessary to replace the launch file as well.</p>"},{"location":"how-to-guides/others/an-example-procedure-for-adding-and-evaluating-a-new-node/#4-evaluating-by-a-rosbag-based-simulator","title":"4. Evaluating by a rosbag-based simulator","text":"<p>Once the new node is implemented, it is time to evaluate it. logging_simulator is a tool of how to evaluate the new node using the rosbag captured in step 2.</p> <p>When you run the logging_simulator, you can set <code>planning:=false</code> or <code>control:=false</code> to disable the launch of specific component nodes.</p> <p><code>ros2 launch autoware_launch logging_simulator.launch.xml ... planning:=false control:=false</code></p> <p>After launching logging_simulator, the rosbag file obtained in step 2 should be replayed using <code>ros2 bag play &lt;rosbag_file&gt;</code>.</p> <p>If you remap the topics related to the localization that you want to verify this time, Autoware will use the data it is calculating this time instead of the data it recorded. Also, using the <code>--topics</code> option of <code>ros2 bag play</code>, you can publish only specific topics in rosbag.</p> <p>There is ros2bag_extensions available to filter the rosbag file and create a new rosbag file that contains only the topics you need.</p>"},{"location":"how-to-guides/others/an-example-procedure-for-adding-and-evaluating-a-new-node/#5-evaluating-in-a-realtime-environment","title":"5. Evaluating in a realtime environment","text":"<p>Once you have sufficiently verified the behavior in the logging_simulator, let's run it as Autoware with new nodes added in the realtime environment.</p> <p>To debug Autoware, the method described at debug-autoware is useful.</p> <p>For reproducibility, you may want to fix the GoalPose. In such cases, consider using the tier4_automatic_goal_rviz_plugin.</p>"},{"location":"how-to-guides/others/an-example-procedure-for-adding-and-evaluating-a-new-node/#6-sharing-the-results","title":"6. Sharing the results","text":"<p>If your implementation works successfully, please consider a pull request to Autoware.</p> <p>It is also a good idea to start by presenting your ideas in Discussion at Show and tell.</p> <p>For localization, YabLoc's Proposal may provide valuable insights.</p>"},{"location":"how-to-guides/others/applying-clang-tidy-to-ros-packages/","title":"Applying Clang-Tidy to ROS packages","text":""},{"location":"how-to-guides/others/applying-clang-tidy-to-ros-packages/#applying-clang-tidy-to-ros-packages","title":"Applying Clang-Tidy to ROS packages","text":"<p>Clang-Tidy is a powerful C++ linter.</p>"},{"location":"how-to-guides/others/applying-clang-tidy-to-ros-packages/#preparation","title":"Preparation","text":"<p>You need to generate <code>build/compile_commands.json</code> before using Clang-Tidy.</p> <pre><code>colcon build --cmake-args -DCMAKE_EXPORT_COMPILE_COMMANDS=1\n</code></pre>"},{"location":"how-to-guides/others/applying-clang-tidy-to-ros-packages/#usage","title":"Usage","text":"<pre><code>clang-tidy -p build/ path/to/file1 path/to/file2 ...\n</code></pre> <p>If you want to apply Clang-Tidy to all files in a package, using the fd command is useful. To install <code>fd</code>, see the installation manual.</p> <pre><code>clang-tidy -p build/ $(fd -e cpp -e hpp --full-path \"/autoware_utils/\")\n</code></pre>"},{"location":"how-to-guides/others/applying-clang-tidy-to-ros-packages/#ide-integration","title":"IDE integration","text":""},{"location":"how-to-guides/others/applying-clang-tidy-to-ros-packages/#clion","title":"CLion","text":"<p>Refer to the CLion Documentation.</p>"},{"location":"how-to-guides/others/applying-clang-tidy-to-ros-packages/#visual-studio-code","title":"Visual Studio Code","text":"<p>Use either one of the following extensions:</p> <ul> <li>C/C++</li> <li>clangd</li> </ul>"},{"location":"how-to-guides/others/applying-clang-tidy-to-ros-packages/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter <code>clang-diagnostic-error</code>, try installing <code>libomp-dev</code>.</p> <p>Related: https://github.com/autowarefoundation/autoware-github-actions/pull/172</p>"},{"location":"how-to-guides/others/debug-autoware/","title":"Debug Autoware","text":""},{"location":"how-to-guides/others/debug-autoware/#debug-autoware","title":"Debug Autoware","text":"<p>This page provides some methods for debugging Autoware.</p>"},{"location":"how-to-guides/others/debug-autoware/#print-debug-messages","title":"Print debug messages","text":"<p>The essential thing for debug is to print the program information clearly, which can quickly judge the program operation and locate the problem. Autoware uses ROS 2 logging tool to print debug messages, how to design console logging refer to tutorial Console logging.</p>"},{"location":"how-to-guides/others/debug-autoware/#using-ros-tools-debug-autoware","title":"Using ROS tools debug Autoware","text":""},{"location":"how-to-guides/others/debug-autoware/#using-command-line-tools","title":"Using command line tools","text":"<p>ROS 2 includes a suite of command-line tools for introspecting a ROS 2 system. The main entry point for the tools is the command <code>ros2</code>, which itself has various sub-commands for introspecting and working with nodes, topics, services, and more. How to use the ROS 2 command line tool refer to tutorial CLI tools.</p>"},{"location":"how-to-guides/others/debug-autoware/#using-rviz2","title":"Using rviz2","text":"<p>Rviz2 is a port of Rviz to ROS 2. It provides a graphical interface for users to view their robot, sensor data, maps, and more. You can run Rviz2 tool easily by:</p> <pre><code>rviz2\n</code></pre> <p>When Autoware launch the simulators, the Rviz2 tool is opened by default to visualize the autopilot graphic information.</p>"},{"location":"how-to-guides/others/debug-autoware/#using-rqt-tools","title":"Using rqt tools","text":"<p>RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins. You can run any RQt tools/plugins easily by:</p> <pre><code>rqt\n</code></pre> <p>This GUI allows you to choose any available plugins on your system. You can also run plugins in standalone windows. For example, RQt Console:</p> <pre><code>ros2 run rqt_console rqt_console\n</code></pre>"},{"location":"how-to-guides/others/debug-autoware/#common-rqt-tools","title":"Common RQt tools","text":"<ol> <li> <p>rqt_graph: view node interaction</p> <p>In complex applications, it may be helpful to get a visual representation of the ROS node interactions.</p> <pre><code>ros2 run rqt_graph rqt_graph\n</code></pre> </li> <li> <p>rqt_console: view messages</p> <p>rqt_console is a great gui for viewing ROS topics.</p> <pre><code>ros2 run rqt_console rqt_console\n</code></pre> </li> <li> <p>rqt_plot: view data plots</p> <p>rqt_plot is an easy way to plot ROS data in real time.</p> <pre><code>ros2 run rqt_plot rqt_plot\n</code></pre> </li> </ol>"},{"location":"how-to-guides/others/debug-autoware/#using-ros2_graph","title":"Using ros2_graph","text":"<p><code>ros2_graph</code> can be used to generate mermaid description of ROS 2 graphs to add on your markdown files.</p> <p>It can also be used as a colorful alternative to <code>rqt_graph</code> even though it would require some tool to render the generated mermaid diagram.</p> <p>It can be installed with:</p> <pre><code>pip install ros2-graph\n</code></pre> <p>Then you can generate a mermaid description of the graph with:</p> <pre><code>ros2_graph your_node\n\n# or like with an output file\nros2_graph /turtlesim -o turtle_diagram.md\n\n# or multiple nodes\nros2_graph /turtlesim /teleop_turtle\n</code></pre> <p>You can then visualize these graphs with:</p> <ul> <li>Mermaid Live Editor</li> <li>Visual Studio Code extension mermaid preview</li> <li>JetBrains IDEs with native support</li> </ul>"},{"location":"how-to-guides/others/debug-autoware/#using-ros2doctor","title":"Using ros2doctor","text":"<p>When your ROS 2 setup is not running as expected, you can check its settings with the <code>ros2doctor</code> tool.</p> <p><code>ros2doctor</code> checks all aspects of ROS 2, including platform, version, network, environment, running systems and more, and warns you about possible errors and reasons for issues.</p> <p>It's as simple as just running <code>ros2 doctor</code> in your terminal.</p> <p>It has the ability to list \"Subscribers without publishers\" for all topics in the system.</p> <p>And this information can help you find if a necessary node isn't running.</p> <p>For more details, see the following official documentation for Using ros2doctor to identify issues.</p>"},{"location":"how-to-guides/others/debug-autoware/#using-a-debugger-with-breakpoints","title":"Using a debugger with breakpoints","text":"<p>Many IDE(e.g. Visual Studio Code, CLion) supports debugging C/C++ executable with GBD on linux platform. The following lists some references for using the debugger:</p> <ul> <li>https://code.visualstudio.com/docs/cpp/cpp-debug</li> <li>https://www.jetbrains.com/help/clion/debugging-code.html#useful-debugger-shortcuts</li> </ul>"},{"location":"how-to-guides/others/defining-temporal-performance-metrics/","title":"Defining temporal performance metrics on components","text":""},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#defining-temporal-performance-metrics-on-components","title":"Defining temporal performance metrics on components","text":""},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#motivation-to-defining-temporal-performance-metrics","title":"Motivation to defining temporal performance metrics","text":""},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#objective-of-the-page","title":"Objective of the page","text":"<p>This page introduces policies to define metrics to evaluate temporal performance on components of Autoware. The term \"temporal performance\" is often used throughout the page in order to distinguish between functional performance, which referred to as accuracy as well, and time-related performance.</p> <p>It is expected that most algorithms employed for Autoware are executed with as high frequency and short response time as possible. In order to achieve safe autonomous driving, one of the desired outcomes is no time gap between perceived and actual situation. The time gap is commonly referred to as delay. If the delay is significant, the system may determine trajectory and maneuver based on outdated situation. Consequently, if the actual situation differs from the perceived one due to the delay, the system may make unexpected decisions.</p> <p>As mentioned above, this page presents the policies to define metrics. Besides, the page contains lists of sample metrics that are crucial for the main functionalities of Autoware: Localization, Perception, Planning, and Control.</p> <p>Note</p> <p>Other functionalities, such as system components for diagnosis, are excluded currently. However they will be taken into account in the near future.</p>"},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#contribution-of-the-temporal-performance-metrics","title":"Contribution of the temporal performance metrics","text":"<p>Temporal performance metrics are important for evaluating Autoware. These metrics are particularly useful for assessing delays caused by new algorithms and logic. They can be employed when comparing the temporal performance of software on a desktop computer with that on a vehicle during the vehicle integration phase.</p> <p>In addition, these metrics are useful for designers and evaluators of middleware, operating systems, and computers. They are selected based on user and product requirements. One of these requirements is to provide sufficient temporal performance for executing Autoware. \"Sufficient temporal performance\" is defined as a temporal performance requirement, but it can be challenging to define the requirement because it varies depending on the product type, Operational Design Domain (ODD), and other factors. Then, this page specifically focuses on temporal performance metrics rather than requirements.</p> <p>Temporal performance metrics are important for evaluating the reliability of Autoware. However, ensuring the reliability of Autoware requires consideration of not only temporal performance metrics but also other metrics.</p>"},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#tools-for-evaluating-the-metrics","title":"Tools for evaluating the metrics","text":"<p>There are several tools available for evaluating Autoware according to the metrics listed in the page. For example, both CARET and ros2_tracing are recommended options when evaluating Autoware on Linux and ROS 2. If you want to measure the metrics with either of these tools, refer to the corresponding user guide for instructions. It's important to note that if you import Autoware to a platform other than Linux and ROS 2, you will need to choose a supported tool for evaluation.</p> <p>Note</p> <p>TIER IV plans to measure Autoware, which is running according to the tutorial, and provide a performance evaluation report periodically. An example of such a report can be found here, although it may not include all of the metrics listed.</p> <p>The page does not aim to provide instructions on how to use these tools or measure the metrics. Its primary focus is on the metrics themselves, as they are more important than the specific tools used. These metrics retain their relevance regardless of the employed platform.</p>"},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#policies-to-define-temporal-performance-metrics","title":"Policies to define temporal performance metrics","text":"<p>As mentioned above, the configuration of Autoware varies by the product type, ODD, and other factors. The variety of configurations makes it difficult to define the uniform metrics for evaluating Autoware. However, the policies used to define them are basically reused even when the configuration changes. Each of temporal performance metrics is categorized into two types: execution frequency and response time. Although there are many types of metrics, such as communication latency, the only two types are considered for simplicity. Execution frequency is observed using rate of Inter-Process Communication (IPC) messages. You will find an enormous number of messages in Autoware, but you don't have to take care of all. Some messages might be critical to functionality and they should be chosen for evaluation. Response time is duration elapsed through a series of processing. A series of processing is referred to as a path. Response time is calculated from timestamps of start and end of a path. Although many paths can be defined in Autoware, you have to choose significant paths.</p> <p>As a hint, here are some characteristics of message and path in order to choose metrics.</p> <ol> <li>Messages and paths on boundaries where observed values from sensors are consumed</li> <li>Messages and paths on boundaries of functions, e.g., a boundary of perception and planning</li> <li>Messages and paths on boundaries where timer-based frequency is switched</li> <li>Messages and paths on boundaries where two different messages are synchronized and merged</li> <li>Messages that must be transmitted at expected frequency, e.g., vehicle command messages</li> </ol> <p>Those hints would be helpful for most configurations but there may be exclusions. Defining metrics precisely requires an understanding of configuration.</p> <p>In addition, it is recommended that metrics be determined incrementally from the architectural level to the detailed design and implementation level. Mixing metrics at different levels of granularity can be confusing.</p>"},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#list-of-sample-metrics","title":"List of sample metrics","text":"<p>This section demonstrates how to define metrics according to the policies explained and has lists of the metrics for Autoware launched according to the tutorial. The section is divided into multiple subsections, each containing a model diagram and an accompanying list that explains the important temporal performance metrics. Each model is equipped with checkpoints that serve as indicators for these metrics.</p> <p>The first subsection presents the top-level temporal performance metrics, which are depicted in the abstract structure of Autoware as a whole. The detailed metrics are not included in the model as they would add complexity to it. Instead, the subsequent section introduces the detailed metrics. The detailed metrics are subject to more frequent updates compared to the top-level ones, which is another reason for categorizing them separately.</p> <p>Each list includes a column for the reference value. The reference value represents the observed value of each metric when Autoware is running according to the tutorial. It is important to note that the reference value is not a required value, meaning that Autoware does not necessarily fail in the tutorial execution if certain metrics do not fulfill the reference value.</p>"},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#top-level-temporal-performance-metrics-for-autoware","title":"Top-level temporal performance metrics for Autoware","text":"<p>The diagram below introduces the model for top-level temporal performance metrics.</p> <p></p> <p>The following three policies assist in selecting the top-level performance metrics:</p> <ul> <li>Splitting Autoware based on components that consume observed values, such as sensor data, and considering the processing frequency and response time around these components</li> <li>Dividing Autoware based on the entry point of Planning and Control and considering the processing frequency and response time around these components</li> <li>Showing the minimum metrics for the Vehicle Interface, as they may vary depending on the target vehicle</li> </ul> <p>Additionally, it is assumed that algorithms are implemented as multiple nodes and function as a pipeline processing system.</p> ID Representation in the model Metric meaning Related functionality Reference value Reason to choose it as a metric Note AWOV-001 Message rate from CPA #9 to CPA #18 Update rate of result from Prediction to Planning. Perception 10 Hz Planning relies on fresh and up-to-date perceived data from Perception for creating accurate trajectory. AWOV-002 Response time from CPA #0 to CPA #20 via CPA #18 Response time in main body of Perception. Perception N/A Planning relies on fresh and up-to-date perceived data from Perception for creating accurate trajectory. The metric is used if delay compensation is disabled in Tracking. AWOV-003 Response time from CPA #7 to CPA #20 Response time from Tracking output of Tracking to its data consumption in Planning. Perception N/A Planning relies on fresh and up-to-date perceived data from Perception for creating accurate trajectory. The metric is used if delay compensation is enabled in Tracking. AWOV-004 Response time from CPA #0 to CPA #6 Duration to process pointcloud data in Sensing and Detection. Perception N/A Tracking relies on detection to provide real-time and up-to-date sensed data for accurate tracking. The metric is used if delay compensation is enabled in Tracking. AWOV-005 Message rate from CPA #4 to CPA #5 Update rate of Detection result received by Tracking. Perception 10 Hz Tracking relies on detection to provide real-time and up-to-date sensed data for accurate tracking. AWOV-006 Response time from CPA #0 to CPA #14 Response time from output of observed data from LiDARs to its consumption in EKF Localizer via NDT Scan Matcher. Localization N/A EKF Localizer relies on fresh and up-to-date observed data from sensors for accurate estimation of self pose. AWOV-007 Message rate from CPA #11 to CPA #13 Update rate of pose estimated by NDT Scan Matcher. Localization 10 Hz EKF Localizer relies on fresh and up-to-date observed data from sensors for accurate estimation of self pose. AWOV-008 Message rate from CPA #15 to CPA #12 Update rate of feed backed pose estimated by EKF Localizer. Localization 50 Hz NDT Scan Matcher relies on receiving estimated pose from EKF Localizer smoothly for linear interpolation. AWOV-009 Message rate from CPA #17 to CPA #19 Update rate of Localization result received by Planning. Localization 50 Hz Planning relies on Localization to update the estimated pose frequently. AWOV-010 Response time from CPA #20 to CPA #23 Processing time from beginning of Planning to consumption of Trajectory message in Control. Planning N/A A vehicle relies on Planning to update trajectory within a short time frame to achieve safe driving behavior. AWOV-011 Message rate from CPA #21 to CPA #22 Update rate of Trajectory message from Planning. Planning 10 Hz A vehicle relies on Planning to update trajectory frequently to achieve safe driving behavior. AWOV-012 Message rate from CPA #24 to CPA #25 Update rate of Control command. Control 33 Hz Control stability and comfort relies on sampling frequency of Control. AWOV-013 Message rate between CPA #26 and Vehicle Communication rate between Autoware and Vehicle. Vehicle Interface N/A A vehicle requires Autoware to communicate with each other at predetermined frequency. Temporal performance requirement varies depending on vehicle type. <p>Note</p> <p>There is an assumption that each of sensors, such as LiDARs and cameras, outputs a set of pointcloud with a timestamp. CPA #0 is observed with the timestamp. If the sensors are not configured to output the timestamp, the time when Autoware receives the pointcloud is used instead. That is represented by CPA #1 in the model. The detailed metrics employs the idea as well.</p>"},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#detailed-temporal-performance-metrics-for-perception","title":"Detailed temporal performance metrics for Perception","text":"<p>The diagram below introduces the model for temporal performance metrics for Perception.</p> <p></p> <p>The following two policies assist in selecting the performance metrics:</p> <ul> <li>Regarding the frequency and response time at which Recognition results from Object Recognition and Traffic Light Recognition are consumed in Planning</li> <li>Splitting Perception component on merging points of data from multiple processing paths and considering the frequency and response time around that point</li> </ul> <p>The following list shows the temporal performance metrics for Perception.</p> ID Representation in the model Metric meaning Related functionality Reference value Reason to choose it as a metric Note APER-001 Message rate from CPP #2 to CPP #26 Update rate of Traffic Light Recognition. Traffic Light Recognition 10 Hz Planning relies on fresh and up-to-date perceived data from Traffic Light Recognition for making precise decisions. APER-002 Response time from CPP #0 to CPP #30 Response time from camera input to consumption of the result in Planning. Traffic Light Recognition N/A Planning relies on fresh and up-to-date perceived data from Traffic Light Recognition for making precise decisions. APER-003 Message rate from CPP #25 to CPP #28 Update rate of result from Prediction (Object Recognition) to Planning. Object Recognition 10 Hz Planning relies on fresh and up-to-date perceived data from Perception for creating accurate trajectory. The metric is same as AWOV-001. APER-004 Response time from CPP #6 to CPP #30 Response time from Tracking output of Tracking to its data consumption in Planning. Object Recognition N/A Planning relies on fresh and up-to-date perceived data from Perception for creating accurate trajectory. The metric is same as AWOV-002 and used if delay compensation is disabled in Tracking. APER-005 Response time from CPP #23 to CPP #30 Response time from Tracking output of Tracking to its data consumption in Planning. Object Recognition N/A Planning relies on fresh and up-to-date perceived data from Perception for creating accurate trajectory. The metric is same as AWOV-003 and used if delay compensation is enabled in Tracking. APER-006 Response time from CPP #6 to CPP #21 Duration to process pointcloud data in Sensing and Detection. Object Recognition N/A Tracking relies on Detection to provide real-time and up-to-date perceived data. The metrics is same as AWOV-004 and used if delay compensation is enabled in Tracking. APER-007 Message rate from CPP #20 to CPP #21 Update rate of Detection result received by Tracking. Object Recognition 10 Hz Tracking relies on detection to provide real-time and up-to-date sensed data for accurate tracking. The metric is same as AWOV-005 APER-008 Message rate from CPP #14 to CPP #19 Update rate of data sent from Sensor Fusion. Object Recognition 10 Hz Association Merger relies on the data to be updated at expected frequency for data synchronization. APER-009 Message rate from CPP #16 to CPP #19 Update rate of data sent from Detection by Tracker. Object Recognition 10 Hz Association Merger relies on the data to be updated at expected frequency for data synchronization. APER-010 Message rate from CPP #18 to CPP #19 Update rate of data sent from Validation Object Recognition. 10 Hz Association Merger relies on the data to be updated at expected frequency for data synchronization. APER-011 Response time from CPP #6 to CPP #19 via CPP #14 Response time to consume data sent from Sensor Fusion after LiDARs output pointcloud. Object Recognition N/A Association Merger relies on fresh and up-to-date data for data synchronization. APER-012 Response time from CPP #6 to CPP #19 via CPP #16 Response time to consume data sent from Detection by Tracker after LiDARs output pointcloud. Object Recognition N/A Association Merger relies on fresh and up-to-date data for data synchronization. APER-013 Response time from CPP #6 to CPP #19 via CPP #18 Response time to consume data sent from Validator after LiDARs output pointcloud. Object Recognition N/A Association Merger relies on fresh and up-to-date data for data synchronization. APER-014 Message rate from CPP #10 to CPP #13 Update rate of data sent from Clustering. Object Recognition 10 Hz Sensor Fusion relies on the data to be updated at expected frequency for data synchronization. APER-015 Message rate from CPP #5 to CPP #13 Update rate of data sent from Camera-based Object detection. Object Recognition 10 Hz Sensor Fusion relies on the data to be updated at expected frequency for data synchronization. APER-016 Response time from CPP #6 to CPP #13 Response time to consume data sent from Clustering after LiDARs output pointcloud. Object Recognition N/A Sensor Fusion relies on fresh and up-to-date data for data synchronization. APER-017 Response time from CPP #3 to CPP #13 Response time to consume data sent from Camera-based Object detection after Cameras output images. Object Recognition N/A Sensor Fusion relies on fresh and up-to-date data for data synchronization. APER-018 Message rate from CPP #10 to CPP #17 Update rate of data sent from Clustering. Object Recognition 10 Hz Validator relies on the data to be updated at expected frequency for data synchronization. It seems similar to APER-014, but the topic message is different. APER-019 Message rate from CPP #12 to CPP #17 Update rate of data sent from DNN-based Object Recognition. Object Recognition 10 Hz Validator relies on the data to be updated at expected frequency for data synchronization. APER-020 Response time from CPP #6 to CPP #17 via CPP #10 Response time to consume data sent from Clustering after LiDARs output pointcloud. Object Recognition N/A Validator relies on fresh and update-date data for data synchronization. It seems similar to APER-015, but the topic message is different. APER-021 Response time from CPP #6 to CPP #17 via CPP #12 Response time to consume data sent from DNN-based Object Recognition after LiDARs output pointcloud. Object Recognition N/A Validator relies on fresh and update-date data for data synchronization."},{"location":"how-to-guides/others/defining-temporal-performance-metrics/#detailed-temporal-performance-metrics-for-paths-between-obstacle-segmentation-and-planning","title":"Detailed temporal performance metrics for Paths between Obstacle segmentation and Planning","text":"<p>Obstacle segmentation, which is a crucial part of Perception, transmits data to Planning. The figure below illustrates the model that takes into account performance metrics related to Obstacle segmentation and Planning.</p> <p></p> <p>Note</p> <p>Both the Obstacle grid map and Obstacle segmentation transmit data to multiple sub-components of Planning. However, not all of these sub-components are described in the model. This is because our primary focus is on the paths from LiDAR to Planning via Obstacle segmentation.</p> <p>The following list shows the temporal performance metrics around Obstacle segmentation and Planning.</p> ID Representation in the model Metric meaning Related functionality Reference value Reason to choose it as a metric Note OSEG-001 Message rate from CPS #4 to CPS #7 Update rate of Occupancy grid map received by Planning (<code>behavior_path_planner</code>) Obstacle segmentation 10 Hz Planning relies on Occupancy grid map to be updated frequently and smoothly for creating accurate trajectory. OSEG-002 Response time from CPS #0 to CPS #9 via CPS #7 Response time to consume Occupancy grid map after LiDARs output sensing data. Obstacle segmentation N/A Planning relies on fresh and up-to-date perceived data from Occupancy grid map for creating accurate trajectory.. OSEG-003 Message rate from CPS #6 to CPS #11 Update rate of obstacle segmentation received by Planning (<code>behavior_velocity_planner</code>). Obstacle segmentation 10 Hz Planning relies on Obstacle segmentation to be updated frequently and smoothly for creating accurate trajectory. OSEG-004 Response time from CPS #0 to CPS #13 via CPS #11 Response time to consume Obstacle segmentation after LiDARs output sensing data. Obstacle segmentation N/A Planning relies on fresh and up-to-date perceived data from Obstacle segmentation for creating accurate trajectory.."},{"location":"how-to-guides/others/determining-component-dependencies/","title":"Determining component dependencies","text":""},{"location":"how-to-guides/others/determining-component-dependencies/#determining-component-dependencies","title":"Determining component dependencies","text":"<p>For any developers who wish to try and deploy Autoware as a microservices architecture, it is necessary to understand the software dependencies, communication, and implemented features of each ROS package/node.</p> <p>As an example, the commands necessary to determine the dependencies for the Perception component are shown below.</p>"},{"location":"how-to-guides/others/determining-component-dependencies/#perception-component-dependencies","title":"Perception component dependencies","text":"<p>To generate a graph of package dependencies, use the following <code>colcon</code> command:</p> <pre><code>colcon graph --dot --packages-up-to tier4_perception_launch | dot -Tpng -o graph.png\n</code></pre> <p></p> <p>To generate a list of dependencies, use:</p> <pre><code>colcon list --packages-up-to tier4_perception_launch --names-only\n</code></pre> colcon list output <pre><code>autoware_auto_geometry_msgs\nautoware_auto_mapping_msgs\nautoware_auto_perception_msgs\nautoware_auto_planning_msgs\nautoware_auto_vehicle_msgs\nautoware_cmake\nautoware_lint_common\nautoware_point_types\ncompare_map_segmentation\ndetected_object_feature_remover\ndetected_object_validation\ndetection_by_tracker\neuclidean_cluster\ngrid_map_cmake_helpers\ngrid_map_core\ngrid_map_cv\ngrid_map_msgs\ngrid_map_pcl\ngrid_map_ros\nground_segmentation\nimage_projection_based_fusion\nimage_transport_decompressor\ninterpolation\nkalman_filter\nlanelet2_extension\nlidar_apollo_instance_segmentation\nmap_based_prediction\nmulti_object_tracker\nmussp\nobject_merger\nobject_range_splitter\noccupancy_grid_map_outlier_filter\npointcloud_preprocessor\npointcloud_to_laserscan\nshape_estimation\ntensorrt_yolo\ntier4_autoware_utils\ntier4_debug_msgs\ntier4_pcl_extensions\ntier4_perception_launch\ntier4_perception_msgs\ntraffic_light_classifier\ntraffic_light_map_based_detector\ntraffic_light_ssd_fine_detector\ntraffic_light_visualization\nvehicle_info_util\n</code></pre> <p>Tip</p> <p>To output a list of modules with their respective paths, run the command above without the <code>--names-only</code> parameter.</p> <p>To see which ROS topics are being subscribed and published to, use <code>rqt_graph</code> as follows:</p> <pre><code>ros2 launch tier4_perception_launch perception.launch.xml mode:=lidar\nros2 run rqt_graph rqt_graph\n</code></pre>"},{"location":"how-to-guides/others/fixing-dependent-package-versions/","title":"Fixing dependent package versions","text":""},{"location":"how-to-guides/others/fixing-dependent-package-versions/#fixing-dependent-package-versions","title":"Fixing dependent package versions","text":"<p>Autoware manages dependent package versions in autoware.repos. For example, let's say you make a branch in autoware.universe and add new features. Suppose you update other dependencies with <code>vcs pull</code> after cutting a branch from autoware.universe. Then the version of autoware.universe you are developing and other dependencies will become inconsistent, and the entire Autoware build will fail. We recommend saving the dependent package versions by executing the following command when starting the development.</p> <pre><code>vcs export src --exact &gt; my_autoware.repos\n</code></pre>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/","title":"Planning Evaluation Using Scenarios","text":""},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#planning-evaluation-using-scenarios","title":"Planning Evaluation Using Scenarios","text":""},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#introduction","title":"Introduction","text":"<p>The performance of Autoware's planning stack is evaluated through a series of defined scenarios that outline the behaviors of other road users and specify the success and failure conditions for the autonomous vehicle, referred to as \"Ego.\" These scenarios are specified in a machine-readable format and executed using the Scenario Simulator tool. Below, brief definitions of the three primary tools used to create, execute, and analyze these scenarios are provided.</p> <ul> <li>Scenario Editor: A web-based GUI tool used to create and edit   scenario files easily.</li> </ul> <ul> <li>Scenario Simulator: A tool designed to simulate these   machine-readable scenarios. It configures the environment, dictates the behavior of other road users, and sets both   success and failure conditions.</li> </ul> <ul> <li>Autoware Evaluator: A web-based CI/CD platform that facilitates the uploading,   categorization, and execution of scenarios along with their corresponding map files. It allows for parallel scenario   executions and provides detailed results.</li> </ul>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#creating-scenarios","title":"Creating Scenarios","text":"<p>Scenarios are created using the Scenario Editor tool, which provides a user-friendly interface to define road users, their behaviors, and the success and failure conditions for the ego vehicle.</p> <p>To demonstrate the scenario creation process, we will create a simple scenario.</p>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#scenario-definition","title":"Scenario Definition","text":"<ul> <li>Initial condition: The ego vehicle is driving in a straight lane, and a bicycle is stopped in the same lane.</li> <li>Action: When the longitudinal distance between the ego vehicle and the bicycle is less than 10 meters, the bicycle   starts moving at a speed of 2 m/s.</li> <li>Success condition: The ego vehicle reaches the goal point.</li> <li>Failure condition: The ego vehicle collides with the bicycle.</li> </ul>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#scenario-creation","title":"Scenario Creation","text":"<ol> <li>Open the Scenario Editor tool.</li> <li>Load the map from the MAP tab. For this tutorial, we will use the <code>LEO-VM-00001</code> map, which can be downloaded    from the Autoware Evaluators' <code>Maps</code> section.</li> <li> <p>In the <code>Edit</code> tab, add both the ego vehicle and the bicycle from the <code>Add Entity</code> section. After adding them, select    the ego vehicle and set its destination from the <code>Edit</code> tab.</p> <p></p> </li> <li> <p>After setting the positions of the bicycle, ego vehicle, and ego vehicle's destination, set the initial velocity of    the bicycle to 0 m/s as shown below. Then, click the <code>Scenario</code> tab and click on the <code>Add new act</code> button. Using    this, define an action that starts the bicycle moving when the distance condition is satisfied.</p> <p></p> </li> <li> <p>As shown below, define a start condition for an action named <code>act_start_bicycle</code>. This condition checks the distance    between the ego vehicle and the bicycle. If the distance is less than or equal to 10 meters, the action is triggered.</p> <p></p> </li> <li> <p>After the start condition, define an event for this action. Since there are no other conditions for this event,    set a dummy condition where SimulationTime is greater than 0, as shown below.</p> <p></p> </li> <li> <p>Define an action for this event. This action will set the velocity of the actor, Bicycle0, to 2 m/s.</p> <p></p> </li> <li> <p>The scenario is now ready to be tested. You can export the scenario from the <code>Scenario</code> tab by clicking the <code>Export</code>    button.</p> <p></p> </li> </ol>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#important-notes-for-scenario-creation","title":"Important Notes for Scenario Creation","text":"<ul> <li>The tutorial we made is a simple scenario implementation for more complex definitions and other road user actions,   please refer to   the Scenario Simulator documentation.</li> <li>Due to the complexity of the scenario format, support for editing in the GUI is not yet complete for all scenario   features. Therefore, if there are any items that cannot be supported or are difficult to edit using the GUI, you can   edit and adjust the scenario directly using a text editor. In that case, the schema of the scenario format is checked   before saving, so you can edit with confidence.</li> <li>Best way to understand other complex scenario implementations is to look at the existing scenarios. You can check the   scenarios in the   Autoware Evaluator to see other implementations.</li> </ul>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#running-scenarios-using-scenario-simulator","title":"Running Scenarios using Scenario Simulator","text":""},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#creating-the-scenario-simulator-environment","title":"Creating the Scenario Simulator Environment","text":"<ul> <li>Clone the Autoware main repository.</li> </ul> <pre><code>git clone https://github.com/autowarefoundation/autoware.git\n</code></pre> <ul> <li>Create source directory.</li> </ul> <pre><code>cd autoware\nmkdir src\n</code></pre> <ul> <li>Import the necessary repositories both for the Autoware and Scenario Simulator.</li> </ul> <pre><code>vcs import src &lt; autoware.repos\nvcs import src &lt; simulator.repos\n</code></pre> <ul> <li>If you are installing Autoware for the first time, you can automatically install the dependencies by using the   provided Ansible script. Please refer to   the Autoware source installation page   for more information.</li> </ul> <pre><code>./setup-dev-env.sh\n</code></pre> <ul> <li>Install dependent ROS packages.</li> </ul> <p>Autoware and Scenario Simulator require some ROS 2 packages in addition to the core components. The tool rosdep allows an automatic search and installation of such dependencies. You might need to run rosdep update before rosdep install.</p> <pre><code>source /opt/ros/humble/setup.bash\nrosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO\n</code></pre> <ul> <li>Build the workspace.</li> </ul> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> <ul> <li>If you have any issues with the installation, or if you need more detailed instructions, please refer to the   Autoware source installation page.</li> </ul>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#execute-the-scenario-by-using-scenario-simulator","title":"Execute the scenario by using Scenario Simulator","text":"<p>We created an example scenario above and exported it into our local machine. Now, we will execute this scenario using Scenario Simulator.</p> <ul> <li>Firstly, we should define the <code>lanelet2_map.osm</code> and <code>pointcloud_map.pcd</code> files in the scenario file. In default, the   configuration is below:</li> </ul> <pre><code>RoadNetwork:\nLogicFile:\nfilepath: lanelet2_map.osm\nSceneGraphFile:\nfilepath: lanelet2_map.pcd\n</code></pre> <p>User should change the <code>filepath</code> field according to the map file we downloaded before. You can find both <code>lanelet2_map.osm</code> and <code>pointcloud_map.pcd</code> files in the <code>Maps</code> section of the Autoware Evaluator.</p> <p>Note: Although the <code>pointcloud_map.pcd</code> file is mandatory, it is not used in the simulation. Therefore, you can define a dummy file for this field.</p> <ul> <li>After defining the map files, we can execute the scenario by using the Scenario Simulator. The command is below:</li> </ul> <pre><code>ros2 launch scenario_test_runner scenario_test_runner.launch.py \\\nrecord:=false \\\nscenario:='/path/to/scenario/sample.yaml' \\\nsensor_model:=sample_sensor_kit \\\nvehicle_model:=sample_vehicle\n</code></pre> <ul> <li>Now, the scenario will be executed in the Scenario Simulator. You can see the simulation in the RViz window.</li> </ul> <ul> <li>To see the condition details in the scenario while playing it in RViz, you should enable the <code>Condition Group</code> marker,   it is not enabled by default.</li> </ul> <p></p> <ul> <li>By using the <code>Condition Group</code> marker, you can see the conditions that are satisfied and not satisfied in the   scenario. So it would be helpful to investigate the scenario.</li> </ul> <p></p>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#understanding-the-autoware-evaluator","title":"Understanding the Autoware Evaluator","text":"<p>Autoware Evaluator is a web-based CI/CD platform that facilitates the uploading, categorization, and execution of scenarios along with their corresponding map files. It allows for parallel scenario executions and provides detailed results.</p> <p>Note: The Autoware Evaluator is a private tool. Currently, you should be invited to the AWF project to access it. However, the AWF project will be public, it is under development.</p> <ul> <li>Firstly, you should create a free TIER IV account to access the Autoware Evaluator. You can create an account by using   the TIER IV account creation page.</li> </ul> <ul> <li>After you created an account, please reach out to Hiroshi IGATA (hiroshi.igata@tier4.jp), the AWF ODD WG leader, for   an invitation to AWF project of the Autoware Evaluator. It is advised to join the ODD WG meeting once to briefly   introduce yourself and your interest. The ODD WG information   is here.</li> </ul> <p>Let's explore the Autoware Evaluator interface page by page.</p>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#scenarios","title":"Scenarios","text":"<p>In <code>Scenarios</code> tab, user can view, search, and filter all the uploaded scenarios. If you are looking for a specific scenario, you can use this page's search bar to find it. If the scenario labeled ticked, it means that the scenario is reviewed and approved by manager, otherwise, it waits for a review.</p>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#catalogs","title":"Catalogs","text":"<p>The <code>Catalogs</code> tab displays scenario catalogs which means a group of suites that were created for a specific use case. In Evaluator, user can execute a test for all scenarios in a catalog.</p> <p></p>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#suites","title":"Suites","text":"<p><code>Suites</code> mean a group of scenarios that were created for a specific testing purposes, it is the smallest unit of the scenario group. It can be assigned to any catalog to be tested for a use case.</p>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#maps","title":"Maps","text":"<p>The <code>Maps</code> tab displays a list of maps that are used in the scenarios. Developers can find the map that they need to execute the scenario.</p>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#reports","title":"Reports","text":"<p>The <code>Reports</code> tab displays a list of results from scenario tests. Here, users can view the most recent test executions.</p> <p></p> <p>The screenshot above illustrates the latest test execution for the public road bus catalog. In the source column, the default Autoware repository with the latest commit is displayed. For a deeper analysis, users can click on the title to view comprehensive results.</p> <p></p> <p>Clicking on the title of a test execution leads to a page displaying build logs and individual test results for each suite. By selecting links in the <code>ID</code> column, users can access detailed results for each suits.</p> <p></p> <p>After clicking the <code>ID</code> link, users can view detailed test results for the scenarios within the suite. For instance, in our case, 183 out of 198 scenarios succeeded. This page is a useful resource for developers to further investigate scenarios that failed.</p> <p></p> <ul> <li><code>ID</code> links to a page which shows detailed test results for the scenario.</li> <li><code>Scenario Name</code> links to a page displaying the scenario's definition.</li> <li><code>Labels</code> indicate the conditions under which the scenario failed; if successful, this field remains empty.</li> <li><code>Status</code> shows the count of failed and succeeded cases within a scenario.</li> </ul> <p>To investigate deeper for this specific scenario, we should click into <code>ID</code> link.</p> <p></p> <p>For this scenario, three of the four cases failed. Each case represents changing the <code>ego_speed</code> parameter. To deep dive into the failed cases, click on the <code>ID</code> link.</p> <p></p> <p>This page show us the detailed information of the failed case. We can understand why the case failing by looking into the <code>Message</code>. For our case, the message is <code>Simulation failure: CustomCommandAction typed \"exitFailure\" was triggered by the anonymous Condition (OpenSCENARIO.Storyboard.Story[0].Act[\"_EndCondition\"].ManeuverGroup[0].Maneuver[0].Event[1].StartTrigger.ConditionGroup[1].Condition[0]): The state of StoryboardElement \"act_ego_nostop_check\" (= completeState) is given state completeState?</code></p> <p>From this message, we can understand that an action which is used for checking the vehicle is not stopped is in complete state. And, the scenario author set this condition as a failure condition. Therefore, the scenario failed.</p> <ul> <li>To test the scenario in local, you can download the scenario and its map by using links which are marked image above.   Running scenario on local machine was explained in the previous section.</li> </ul> <ul> <li>To compare the test executions to analyze when the scenarios were successfully running, you can use <code>Compare Reports</code>   button in the page which shows result of previous test executions.</li> </ul> <p></p> <ul> <li>To see how the scenario failed, you can replay the scenario by clicking the <code>Play</code> button. It shows the executed test.</li> </ul> <p></p> <ul> <li>a) The bar that assists us in rewinding or fast-forwarding</li> <li>b) Shows the success and failing conditions are satisfied or not</li> <li>c) Shows the state of the actions and events and their start conditions</li> </ul>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#for-further-support","title":"For Further Support","text":"<p>Creating scenarios, analyzing them using Autoware Evaluator would be complicated for new users. If you need further help or support, you can reach out to the Autoware community through the Autoware Discord server, and you can ask questions about scenario creation process or Autoware Evaluator in <code>odd</code> channel. Also, you can attend the weekly ODD Working Group meeting to get support from the community. You can join the ODD WG invitation group to get the meeting invitations.</p> <ul> <li>ODD WG meetings are held weekly in the single time slot which is 2:00pm, Monday (UTC).</li> </ul>"},{"location":"how-to-guides/others/planning-evaluation-using-scenarios/#other-useful-pages","title":"Other Useful Pages","text":"<ul> <li>https://docs.web.auto/en/user-manuals/</li> <li>https://tier4.github.io/scenario_simulator_v2-docs/</li> </ul>"},{"location":"how-to-guides/others/reducing-start-delays/","title":"Reducing start delays on real vehicles","text":""},{"location":"how-to-guides/others/reducing-start-delays/#reducing-start-delays-on-real-vehicles","title":"Reducing start delays on real vehicles","text":"<p>In simulation, the ego vehicle reacts nearly instantly to the control commands generated by Autoware. However, with a real vehicle, some delays occur that may make ego feel less responsive.</p> <p>This page presents start delays experienced when using Autoware on a real vehicle. We define the start delay as the time between (a) when Autoware decides to make the ego vehicle start and (b) when the vehicle actually starts moving. More precisely:</p> <ul> <li>(a) is the time when the speed or acceleration command output by Autoware switches to a non-zero value.</li> <li>(b) is the time when the measured velocity of the ego vehicle switches to a positive value.</li> </ul>"},{"location":"how-to-guides/others/reducing-start-delays/#start-delay-with-manual-driving","title":"Start delay with manual driving","text":"<p>First, let us look at the start delay when a human is driving.</p> <p>The following figure shows the start delay when a human driver switches the gear from parked to drive and instantly releases the brake to push the throttle pedal and make the velocity of the vehicle increase.</p> <p></p> <p>There are multiple things to note from this figure.</p> <ul> <li>Brake (red): despite the driver instantly releasing the brake pedal,   we see that the measured brake takes around <code>150ms</code> to go from <code>100%</code> to <code>0%</code>.</li> <li>Gear (orange): the driver switches gear before releasing the brake pedal, but the gear is measured to switch after   the brake is released.</li> <li>Throttle (green) and velocity (blue): the driver pushes the throttle pedal and the vehicle is measured to start moving around <code>500ms</code> later.</li> </ul>"},{"location":"how-to-guides/others/reducing-start-delays/#filter-delay","title":"Filter delay","text":"<p>To guarantee passenger comfort, some Autoware modules implement filters on the jerk of the vehicle, preventing sudden changes in acceleration.</p> <p>For example, the <code>vehicle_cmd_gate</code> filters the acceleration command generated by the controller and was previously introducing significant delays when transitioning between a stop command where the acceleration is negative, and a move command where the acceleration is positive. Because of the jerk filter, the transition between negative and positive was not instantaneous and would take several hundreds of milliseconds.</p>"},{"location":"how-to-guides/others/reducing-start-delays/#gear-delay","title":"Gear delay","text":"<p>In many vehicles, it is necessary to change gear before first starting to move the vehicle. When performed autonomously, this gear change can take some significant time. Moreover, as seen from the data recorded with manual driving, the measured gear value may be delayed.</p> <p>In Autoware, the controller sends a stopping control command until the gear is changed to the drive state. This means that delays in the gear change and its reported value can greatly impact the start delay. Note that this is only an issue when the vehicle is initially in the parked gear.</p> <p>The only way to reduce this delay is by tuning the vehicle to increase the gear change speed or to reduce the delay in the gear change report.</p>"},{"location":"how-to-guides/others/reducing-start-delays/#brake-delay","title":"Brake delay","text":"<p>In vehicles with a brake pedal, the braking system will often be made of several moving parts which cannot move instantly. Thus, when Autoware sends brake commands to a vehicle, some delays should be expected in the actual brake applied to the wheels.</p> <p>This lingering brake may prevent or delay the initial motion of the ego vehicle.</p> <p>This delay can be reduced by tuning the vehicle.</p>"},{"location":"how-to-guides/others/reducing-start-delays/#throttle-response","title":"Throttle response","text":"<p>For vehicles with throttle control, one of the main cause of start delays is due to the throttle response of the vehicle. When pushing the throttle pedal, the wheels of the vehicle do not instantly start rotating. This is partly due to the inertia of the vehicle, but also to the motor which may take a significant time to start applying some torque to the wheels.</p> <p>It may be possible to tune some vehicle side parameters to reduce this delay, but it is often done at the cost of reduced energy efficiency.</p> <p>On the Autoware side, the only way to decrease this delay is to increase the initial throttle but this can cause uncomfortably high initial accelerations.</p>"},{"location":"how-to-guides/others/reducing-start-delays/#initial-acceleration-and-throttle","title":"Initial acceleration and throttle","text":"<p>As we just discussed, for vehicles with throttle control, an increased initial throttle value can reduce the start delay.</p> <p>Since Autoware outputs an acceleration value, the conversion module <code>raw_vehicle_cmd_converter</code> is used to map the acceleration value from Autoware to a throttle value to be sent to the vehicle. Such mapping is usually calibrated automatically using the <code>accel_brake_map_calibrator</code> module, but it may produce a low initial throttle which leads to high start delays.</p> <p>In order to increase the initial throttle, there are two options: increase the initial acceleration output by Autoware, or modify the acceleration to throttle mapping.</p> <p>The initial acceleration output by Autoware can be tuned in the <code>motion_velocity_smoother</code> with parameters <code>engage_velocity</code> and <code>engage_acceleration</code>. However, the <code>vehicle_cmd_gate</code> applies a filter on the control command to prevent too sudden changes in jerk and acceleration, limiting the maximum allowed acceleration while the ego vehicle is stopped.</p> <p>Alternatively, the mapping of acceleration can be tuned to increase the throttle corresponding to the initial acceleration. If we look at an example acceleration map, it does the following conversion: when the ego velocity is <code>0</code> (first column), acceleration values between <code>0.631</code> (first row) and <code>0.836</code> (second row) are converted to a throttle between <code>0%</code> and <code>10%</code>. This means that any initial acceleration bellow <code>0.631m/s\u00b2</code> will not produce any throttle. Keep in mind that after tuning the acceleration map, it may be necessary to also update the <code>brake map</code>.</p> default 0 1.39 2.78 4.17 5.56 6.94 8.33 9.72 11.11 12.5 13.89 0 0.631 0.11 -0.04 -0.04 -0.041 -0.096 -0.137 -0.178 -0.234 -0.322 -0.456 0.1 0.836 0.57 0.379 0.17 0.08 0.07 0.068 0.027 -0.03 -0.117 -0.251 0.2 1.129 0.863 0.672 0.542 0.4 0.38 0.361 0.32 0.263 0.176 0.042 0.3 1.559 1.293 1.102 0.972 0.887 0.832 0.791 0.75 0.694 0.606 0.472 0.4 2.176 1.909 1.718 1.588 1.503 1.448 1.408 1.367 1.31 1.222 1.089 0.5 3.027 2.76 2.57 2.439 2.354 2.299 2.259 2.218 2.161 2.074 1.94"},{"location":"how-to-guides/others/running-autoware-without-cuda/","title":"Running Autoware without CUDA","text":""},{"location":"how-to-guides/others/running-autoware-without-cuda/#running-autoware-without-cuda","title":"Running Autoware without CUDA","text":"<p>Although CUDA installation is recommended to achieve better performance for object detection and traffic light recognition in Autoware Universe, it is possible to run these algorithms without CUDA. The following subsections briefly explain how to run each algorithm in such an environment.</p>"},{"location":"how-to-guides/others/running-autoware-without-cuda/#running-2d3d-object-detection-without-cuda","title":"Running 2D/3D object detection without CUDA","text":"<p>Autoware Universe's object detection can be run using one of five possible configurations:</p> <ul> <li><code>lidar_centerpoint</code></li> <li><code>lidar_apollo_instance_segmentation</code></li> <li><code>lidar-apollo</code> + <code>tensorrt_yolo</code></li> <li><code>lidar-centerpoint</code> + <code>tensorrt_yolo</code></li> <li><code>euclidean_cluster</code></li> </ul> <p>Of these five configurations, only the last one (<code>euclidean_cluster</code>) can be run without CUDA. For more details, refer to the <code>euclidean_cluster</code> module's README file.</p>"},{"location":"how-to-guides/others/running-autoware-without-cuda/#running-traffic-light-detection-without-cuda","title":"Running traffic light detection without CUDA","text":"<p>For traffic light recognition (both detection and classification), there are two modules that require CUDA:</p> <ul> <li><code>traffic_light_ssd_fine_detector</code></li> <li><code>traffic_light_classifier</code></li> </ul> <p>To run traffic light detection without CUDA, set <code>enable_fine_detection</code> to <code>false</code> in the traffic light launch file. Doing so disables the <code>traffic_light_ssd_fine_detector</code> such that traffic light detection is handled by the <code>map_based_traffic_light_detector</code> module instead.</p> <p>To run traffic light classification without CUDA, set <code>use_gpu</code> to <code>false</code> in the traffic light classifier launch file. Doing so will force the <code>traffic_light_classifier</code> to use a different classification algorithm that does not require CUDA or a GPU.</p>"},{"location":"how-to-guides/others/using-divided-map/","title":"Using divided pointcloud map","text":""},{"location":"how-to-guides/others/using-divided-map/#using-divided-pointcloud-map","title":"Using divided pointcloud map","text":"<p>Divided pointcloud map is necessary when handling large pointcloud map, in which case Autoware may not be capable of sending the whole map via ROS 2 topic or loading the whole map into memory. By using the pre-divided map, Autoware will dynamically load the pointcloud map according to the vehicle's position.</p>"},{"location":"how-to-guides/others/using-divided-map/#tutorial","title":"Tutorial","text":"<p>Download the sample-map-rosbag_split and locate the map under <code>$HOME/autoware_map/</code>.</p> <pre><code>gdown -O ~/autoware_map/ 'https://docs.google.com/uc?export=download&amp;id=11tLC9T4MS8fnZ9Wo0D8-Ext7hEDl2YJ4'\nunzip -d ~/autoware_map/ ~/autoware_map/sample-rosbag_split.zip\n</code></pre> <p>Then, you may launch logging_simulator with the following command to load the divided map. Note that you need to specify the <code>map_path</code> and <code>pointcloud_map_file</code> arguments.</p> <pre><code>source ~/autoware/install/setup.bash\nros2 launch autoware_launch logging_simulator.launch.xml \\\nmap_path:=$HOME/autoware_map/sample-map-rosbag pointcloud_map_file:=pointcloud_map \\\nvehicle_model:=sample_vehicle_split sensor_model:=sample_sensor_kit\n</code></pre> <p>For playing rosbag to simulate Autoware, please refer to the instruction in the tutorial for rosbag replay simulation.</p>"},{"location":"how-to-guides/others/using-divided-map/#related-links","title":"Related links","text":"<ul> <li>For specific format definition of the divided map, please refer to Map component design page</li> <li>The Readme of map_loader may be useful specific instructions for dividing maps</li> <li>When dividing your own pointcloud map, you may use pointcloud_divider, which can divide the map as well as generating the compatible metadata</li> </ul>"},{"location":"how-to-guides/training-machine-learning-models/training-models/","title":"Training and Deploying Models","text":""},{"location":"how-to-guides/training-machine-learning-models/training-models/#training-and-deploying-models","title":"Training and Deploying Models","text":""},{"location":"how-to-guides/training-machine-learning-models/training-models/#overview","title":"Overview","text":"<p>The Autoware offers a comprehensive array of machine learning models, tailored for a wide range of tasks including 2D and 3D object detection, traffic light recognition and more. These models have been meticulously trained utilizing open-mmlab's extensive repositories. By leveraging the provided scripts and following the training steps, you have the capability to train these models using your own dataset, tailoring them to your specific needs.</p> <p>Furthermore, you will find the essential conversion scripts to deploy your trained models into Autoware using the mmdeploy repository.</p>"},{"location":"how-to-guides/training-machine-learning-models/training-models/#training-traffic-light-classifier-model","title":"Training traffic light classifier model","text":"<p>The traffic light classifier model within the Autoware has been trained using the mmlab/pretrained repository. The Autoware offers pretrained models based on EfficientNet-b1 and MobileNet-v2 architectures. To fine-tune these models, a total of 83,400 images were employed, comprising 58,600 for training, 14,800 for evaluation, and 10,000 for testing. These images represent Japanese traffic lights and were trained using TIER IV's internal dataset.</p> Name Input Size Test Accuracy EfficientNet-b1 128 x 128 99.76% MobileNet-v2 224 x 224 99.81% <p>Comprehensive training instructions for the traffic light classifier model are detailed within the readme file accompanying \"traffic_light_classifier\" package. These instructions will guide you through the process of training the model using your own dataset. To facilitate your training, we have also provided an example dataset containing three distinct classes (green, yellow, red), which you can leverage during the training process.</p> <p>Detailed instructions for training the traffic light classifier model can be found here.</p>"},{"location":"how-to-guides/training-machine-learning-models/training-models/#training-centerpoint-3d-object-detection-model","title":"Training CenterPoint 3D object detection model","text":"<p>The CenterPoint 3D object detection model within the Autoware has been trained using the autowarefoundation/mmdetection3d repository.</p> <p>To train custom CenterPoint models and convert them into ONNX format for deployment in Autoware, please refer to the instructions provided in the README file included with Autoware's lidar_centerpoint package. These instructions will provide a step-by-step guide for training the CenterPoint model.</p> <p>In order to assist you with your training process, we have also included an example dataset in the TIER IV dataset format.</p> <p>This dataset contains 600 lidar frames and covers 5 classes, including 6905 cars, 3951 pedestrians, 75 cyclists, 162 buses, and 326 trucks.</p> <p>You can utilize this example dataset to facilitate your training efforts.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#target-platforms","title":"Target platforms","text":"<p>Autoware targets the platforms listed below. It may change in future versions of Autoware.</p> <p>The Autoware Foundation provides no support on other platforms than those listed below.</p>"},{"location":"installation/#architecture","title":"Architecture","text":"<ul> <li>amd64</li> <li>arm64</li> </ul>"},{"location":"installation/#minimum-hardware-requirements","title":"Minimum hardware requirements","text":"<p>Info</p> <p>Autoware is scalable and can be customized to work with distributed or less powerful hardware. The minimum hardware requirements given below are just a general recommendation. However, performance will be improved with more cores, RAM and a higher-spec graphics card or GPU core.</p> <p>Although GPU is not required to run basic functionality, it is mandatory to enable the following neural network related functions:     - LiDAR based object detection     - Camera based object detection     - Traffic light detection and classification</p> <ul> <li>CPU with 8 cores</li> <li>16GB RAM</li> <li>[Optional] NVIDIA GPU (4GB RAM)</li> </ul> <p>For details of how to enable object detection and traffic light detection/classification without a GPU, refer to the Running Autoware without CUDA.</p>"},{"location":"installation/#installing-autoware","title":"Installing Autoware","text":"<p>There are two ways to set up Autoware. Choose one according to your preference.</p> <p>If any issues occur during installation, refer to the Support page.</p>"},{"location":"installation/#1-docker-installation","title":"1. Docker installation","text":"<p>Autoware's Open AD Kit containers enables you to run Autoware easily on your host machine ensuring same environment for all deployments without installing any dependencies. Full Guide on Docker Installation Setup.</p> <p>Open AD Kit is also the First SOAFEE Blueprint for autonomous driving that offers extensible modular containers for making it easier to run Autoware's AD stack on distributed systems. Full Guide on Open AD Kit Setup.</p> <p>Developer containers are also available for developers making it easier to build Autoware from source and ensuring same environment for all developers.</p>"},{"location":"installation/#2-source-installation","title":"2. Source installation","text":"<p>Source installation is for the cases where more granular control of the installation environment is needed. It is recommended for experienced users or people who want to customize their environment. Note that some problems may occur depending on your local environment.</p> <p>For more information, refer to the source installation guide.</p>"},{"location":"installation/#installing-related-tools","title":"Installing related tools","text":"<p>Some other tools are required depending on the evaluation you want to do. For example, to run an end-to-end simulation you need to install an appropriate simulator.</p> <p>For more information, see here.</p>"},{"location":"installation/#additional-settings-for-developers","title":"Additional settings for developers","text":"<p>There are also tools and settings for developers, such as Shells or IDEs.</p> <p>For more information, see here.</p>"},{"location":"installation/additional-settings-for-developers/","title":"Additional settings for developers","text":""},{"location":"installation/additional-settings-for-developers/#additional-settings-for-developers","title":"Additional settings for developers","text":"<ul> <li>Console settings for ROS 2</li> <li>Network configuration for ROS 2</li> </ul>"},{"location":"installation/additional-settings-for-developers/console-settings/","title":"Console settings for ROS 2","text":""},{"location":"installation/additional-settings-for-developers/console-settings/#console-settings-for-ros-2","title":"Console settings for ROS 2","text":""},{"location":"installation/additional-settings-for-developers/console-settings/#colorizing-logger-output","title":"Colorizing logger output","text":"<p>By default, ROS 2 logger doesn't colorize the output. To colorize it, add the following to your <code>~/.bashrc</code>:</p> <pre><code>export RCUTILS_COLORIZED_OUTPUT=1\n</code></pre>"},{"location":"installation/additional-settings-for-developers/console-settings/#customizing-the-format-of-logger-output","title":"Customizing the format of logger output","text":"<p>By default, ROS 2 logger doesn't output detailed information such as file name, function name, or line number. To customize it, add the following to your <code>~/.bashrc</code>:</p> <pre><code>export RCUTILS_CONSOLE_OUTPUT_FORMAT=\"[{severity} {time}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})\"\n</code></pre> <p>For more options, see here.</p>"},{"location":"installation/additional-settings-for-developers/console-settings/#colorized-googletest-output","title":"Colorized GoogleTest output","text":"<p>Add <code>export GTEST_COLOR=1</code> to your <code>~/.bashrc</code>.</p> <p>For more details, refer to Advanced GoogleTest Topics: Colored Terminal Output.</p> <p>This is useful when running tests with <code>colcon test</code>.</p>"},{"location":"installation/additional-settings-for-developers/network-configuration/","title":"Network settings for ROS 2 and Autoware","text":""},{"location":"installation/additional-settings-for-developers/network-configuration/#network-settings-for-ros-2-and-autoware","title":"Network settings for ROS 2 and Autoware","text":""},{"location":"installation/additional-settings-for-developers/network-configuration/#single-computer-setup","title":"Single computer setup","text":"<ul> <li>DDS settings for ROS 2 and Autoware</li> </ul>"},{"location":"installation/additional-settings-for-developers/network-configuration/#multi-computer-setup","title":"Multi computer setup","text":"<ul> <li>Communicating across multiple computers with CycloneDDS</li> </ul>"},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/","title":"DDS settings for ROS 2 and Autoware","text":""},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/#dds-settings-for-ros-2-and-autoware","title":"DDS settings for ROS 2 and Autoware","text":""},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/#enable-localhost-only-communication","title":"Enable localhost-only communication","text":"<ol> <li>Enable <code>multicast</code> for <code>lo</code></li> <li>Make sure <code>export ROS_LOCALHOST_ONLY=1</code> is NOT present in <code>.bashrc</code>.<ul> <li>See About <code>ROS_LOCALHOST_ONLY</code> environment variable for more information.</li> </ul> </li> </ol>"},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/#tune-dds-settings","title":"Tune DDS settings","text":"<p>Autoware uses DDS for internode communication. ROS 2 documentation recommends users to tune DDS to utilize its capability.</p> <p>Note</p> <p>CycloneDDS is the recommended and most tested DDS implementation for Autoware.</p> <p>Warning</p> <p>If you don't tune these settings, Autoware will fail to receive large data like point clouds or images.</p>"},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/#tune-system-wide-network-settings","title":"Tune system-wide network settings","text":"<p>Set the config file path and enlarge the Linux kernel maximum buffer size before launching Autoware.</p> <pre><code># Increase the maximum receive buffer size for network packets\nsudo sysctl -w net.core.rmem_max=2147483647  # 2 GiB, default is 208 KiB\n\n# IP fragmentation settings\nsudo sysctl -w net.ipv4.ipfrag_time=3  # in seconds, default is 30 s\nsudo sysctl -w net.ipv4.ipfrag_high_thresh=134217728  # 128 MiB, default is 256 KiB\n</code></pre> <p>To make it permanent,</p> <pre><code>sudo nano /etc/sysctl.d/10-cyclone-max.conf\n</code></pre> <p>Paste the following into the file:</p> <pre><code># Increase the maximum receive buffer size for network packets\nnet.core.rmem_max=2147483647  # 2 GiB, default is 208 KiB\n\n# IP fragmentation settings\nnet.ipv4.ipfrag_time=3  # in seconds, default is 30 s\nnet.ipv4.ipfrag_high_thresh=134217728  # 128 MiB, default is 256 KiB\n</code></pre> <p>Details of each parameter here is explained in the ROS 2 documentation.</p>"},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/#validate-the-sysctl-settings","title":"Validate the sysctl settings","text":"<pre><code>user@pc$ sysctl net.core.rmem_max net.ipv4.ipfrag_time net.ipv4.ipfrag_high_thresh\nnet.core.rmem_max = 2147483647\nnet.ipv4.ipfrag_time = 3\nnet.ipv4.ipfrag_high_thresh = 134217728\n</code></pre>"},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/#cyclonedds-configuration","title":"CycloneDDS Configuration","text":"<p>Save the following file as <code>~/cyclonedds.xml</code>.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;CycloneDDS xmlns=\"https://cdds.io/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"https://cdds.io/config https://raw.githubusercontent.com/eclipse-cyclonedds/cyclonedds/master/etc/cyclonedds.xsd\"&gt;\n&lt;Domain Id=\"any\"&gt;\n&lt;General&gt;\n&lt;Interfaces&gt;\n&lt;NetworkInterface autodetermine=\"false\" name=\"lo\" priority=\"default\" multicast=\"default\" /&gt;\n&lt;/Interfaces&gt;\n&lt;AllowMulticast&gt;default&lt;/AllowMulticast&gt;\n&lt;MaxMessageSize&gt;65500B&lt;/MaxMessageSize&gt;\n&lt;/General&gt;\n&lt;Internal&gt;\n&lt;SocketReceiveBufferSize min=\"10MB\"/&gt;\n&lt;Watermarks&gt;\n&lt;WhcHigh&gt;500kB&lt;/WhcHigh&gt;\n&lt;/Watermarks&gt;\n&lt;/Internal&gt;\n&lt;/Domain&gt;\n&lt;/CycloneDDS&gt;\n</code></pre> <p>Then add the following lines to your <code>~/.bashrc</code> file.</p> <pre><code>export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp\n\nexport CYCLONEDDS_URI=file:///absolute/path/to/cyclonedds.xml\n# Replace `/absolute/path/to/cyclonedds.xml` with the actual path to the file.\n# Example: export CYCLONEDDS_URI=file:///home/user/cyclonedds.xml\n</code></pre> <p>You can refer to Eclipse Cyclone DDS: Run-time configuration documentation for more details.</p> <p>Warning</p> <p><code>RMW_IMPLEMENTATION</code> variable might be already set with Ansible/RMW Implementation.</p> <p>Check and remove the duplicate line if necessary.</p>"},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/#additional-information","title":"Additional information","text":""},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/#about-ros_localhost_only-environment-variable","title":"About <code>ROS_LOCALHOST_ONLY</code> environment variable","text":"<p>Previously, we used to set <code>export ROS_LOCALHOST_ONLY=1</code> to enable localhost-only communication. But because of an ongoing issue, this method doesn't work.</p> <p>Warning</p> <p>Do not set <code>export ROS_LOCALHOST_ONLY=1</code> in <code>~/.bashrc</code>.</p> <p>If you do so, it will cause an error with RMW.</p> <p>Remove it from <code>~/.bashrc</code> if you have set it.</p>"},{"location":"installation/additional-settings-for-developers/network-configuration/dds-settings/#about-ros_domain_id-environment-variable","title":"About <code>ROS_DOMAIN_ID</code> environment variable","text":"<p>We can also set <code>export ROS_DOMAIN_ID=3(or any number 1 to 255)</code> (<code>0</code> by default) to avoid interference with other ROS 2 nodes on the same network.</p> <p>But since <code>255</code> is a very small number, it might interfere with other computers on the same network unless you make sure everyone has a unique domain ID.</p> <p>Another problem is that if someone runs a test that uses ROS 2 launch_testing framework, by default it will use a random domain ID to isolate between tests even on the same machine. See this PR for more details.</p>"},{"location":"installation/additional-settings-for-developers/network-configuration/enable-multicast-for-lo/","title":"Enable `multicast` on `lo`","text":""},{"location":"installation/additional-settings-for-developers/network-configuration/enable-multicast-for-lo/#enable-multicast-on-lo","title":"Enable <code>multicast</code> on <code>lo</code>","text":""},{"location":"installation/additional-settings-for-developers/network-configuration/enable-multicast-for-lo/#manually-temporary-solution","title":"Manually (temporary solution)","text":"<p>You may just call the following command to enable multicast on the loopback interface.</p> <pre><code>sudo ip link set lo multicast on\n</code></pre> <p>Warning</p> <p>This will be reverted once the computer restarts. To make it permanent, follow the steps below.</p> <p>Note</p> <p>Here, <code>lo</code> is the loopback interface.</p> <p>You can check the interfaces with <code>ip link show</code>.</p> <p>You may change <code>lo</code> with the interface you want to enable multicast on.</p>"},{"location":"installation/additional-settings-for-developers/network-configuration/enable-multicast-for-lo/#on-startup-with-a-service-permanent-solution","title":"On startup with a service (permanent solution)","text":"<pre><code>sudo nano /etc/systemd/system/multicast-lo.service\n</code></pre> <p>Paste the following into the file:</p> <pre><code>[Unit]\nDescription=Enable Multicast on Loopback\n\n[Service]\nType=oneshot\nExecStart=/usr/sbin/ip link set lo multicast on\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Press following in order to save with nano:</p> <ol> <li><code>Ctrl+X</code></li> <li><code>Y</code></li> <li><code>Enter</code></li> </ol> <pre><code># Make it recognized\nsudo systemctl daemon-reload\n\n# Make it run on startup\nsudo systemctl enable multicast-lo.service\n\n# Start it now\nsudo systemctl start multicast-lo.service\n</code></pre>"},{"location":"installation/additional-settings-for-developers/network-configuration/enable-multicast-for-lo/#validate","title":"Validate","text":"<pre><code>you@pc:~$ sudo systemctl status multicast-lo.service\n\u25cb multicast-lo.service - Enable Multicast on Loopback\n     Loaded: loaded (/etc/systemd/system/multicast-lo.service; enabled; vendor preset: enabled)\n     Active: inactive (dead) since Mon 2024-07-08 12:54:17 +03; 4s ago\n    Process: 22588 ExecStart=/usr/bin/ip link set lo multicast on (code=exited, status=0/SUCCESS)\n   Main PID: 22588 (code=exited, status=0/SUCCESS)\n        CPU: 1ms\n\nTem 08 12:54:17 mfc-leo systemd[1]: Starting Enable Multicast on Loopback...\nTem 08 12:54:17 mfc-leo systemd[1]: multicast-lo.service: Deactivated successfully.\nTem 08 12:54:17 mfc-leo systemd[1]: Finished Enable Multicast on Loopback.\n</code></pre> <pre><code>you@pc:~$ ip link show lo\n1: lo: &lt;LOOPBACK,MULTICAST,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n</code></pre>"},{"location":"installation/additional-settings-for-developers/network-configuration/enable-multicast-for-lo/#uninstalling-the-service","title":"Uninstalling the service","text":"<p>If for some reason you want to uninstall the service, you can do so by following these steps:</p> <pre><code># Stop the service\nsudo systemctl stop multicast-lo.service\n\n# Disable the service from running on startup\nsudo systemctl disable multicast-lo.service\n\n# Remove the service file\nsudo rm /etc/systemd/system/multicast-lo.service\n\n# Reload systemd to apply the changes\nsudo systemctl daemon-reload\n</code></pre>"},{"location":"installation/additional-settings-for-developers/network-configuration/multiple-computers/","title":"Communicating across multiple computers with CycloneDDS","text":""},{"location":"installation/additional-settings-for-developers/network-configuration/multiple-computers/#communicating-across-multiple-computers-with-cyclonedds","title":"Communicating across multiple computers with CycloneDDS","text":""},{"location":"installation/additional-settings-for-developers/network-configuration/multiple-computers/#configuring-cyclonedds","title":"Configuring CycloneDDS","text":"<p>Within the <code>~/cyclonedds.xml</code> file, Interfaces section can be set in various ways to communicate across multiple computers within a network.</p>"},{"location":"installation/additional-settings-for-developers/network-configuration/multiple-computers/#automatically-determine-the-network-interface-convenient","title":"Automatically determine the network interface (convenient)","text":"<p>With this setting, CycloneDDS will automatically determine the most suitable network interface to use.</p> <pre><code>&lt;Interfaces&gt;\n&lt;NetworkInterface autodetermine=\"true\" priority=\"default\" multicast=\"default\" /&gt;\n&lt;/Interfaces&gt;\n</code></pre>"},{"location":"installation/additional-settings-for-developers/network-configuration/multiple-computers/#manually-set-the-network-interface-recommended","title":"Manually set the network interface (recommended)","text":"<p>With this setting, you can manually set the network interface to use.</p> <pre><code>&lt;Interfaces&gt;\n&lt;NetworkInterface autodetermine=\"false\" name=\"enp38s0\" priority=\"default\" multicast=\"default\" /&gt;\n&lt;/Interfaces&gt;\n</code></pre> <p>Warning</p> <p>You should replace <code>enp38s0</code> with the actual network interface name.</p> <p>Note</p> <p><code>ifconfig</code> command can be used to find the network interface name.</p>"},{"location":"installation/additional-settings-for-developers/network-configuration/multiple-computers/#time-synchronization","title":"Time synchronization","text":"<p>To ensure that the nodes on different computers are synchronized, you should synchronize the time between the computers.</p> <p>You can use the <code>chrony</code> to synchronize the time between computers.</p> <p>Please refer to this post for more information: Multi PC AWSIM + Autoware Tests #3813</p> <p>Warning</p> <p>Under Construction</p>"},{"location":"installation/autoware/docker-installation/","title":"Open AD Kit: containerized workloads for Autoware","text":""},{"location":"installation/autoware/docker-installation/#open-ad-kit-containerized-workloads-for-autoware","title":"Open AD Kit: containerized workloads for Autoware","text":"<p>Open AD Kit offers two types of Docker image to let you get started with Autoware quickly: <code>devel</code> and <code>runtime</code>.</p> <ol> <li>The <code>devel</code> image enables you to develop Autoware without setting up the local development environment.</li> <li>The <code>runtime</code> image contains only runtime executables and enables you to try out Autoware quickly.</li> </ol> <p>Info</p> <p>Before proceeding, confirm and agree with the NVIDIA Deep Learning Container license. By pulling and using the Autoware Open AD Kit images, you accept the terms and conditions of the license.</p>"},{"location":"installation/autoware/docker-installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker</li> <li>NVIDIA Container Toolkit (preferred)</li> <li>NVIDIA CUDA 12 compatible GPU Driver (preferred)</li> </ul> <ol> <li> <p>Clone <code>autowarefoundation/autoware</code> and move to the directory.</p> <pre><code>git clone https://github.com/autowarefoundation/autoware.git\ncd autoware\n</code></pre> </li> <li> <p>The setup script will install all required dependencies with:</p> <pre><code>./setup-dev-env.sh -y docker\n</code></pre> <p>To install without NVIDIA GPU support:</p> <pre><code>./setup-dev-env.sh -y --no-nvidia docker\n</code></pre> </li> </ol> <p>Info</p> <p>GPU acceleration is required for some features such as object detection and traffic light detection/classification. For details of how to enable these features without a GPU, refer to the Running Autoware without CUDA.</p>"},{"location":"installation/autoware/docker-installation/#usage","title":"Usage","text":""},{"location":"installation/autoware/docker-installation/#runtime","title":"Runtime","text":"<p>You can use <code>run.sh</code> to run the Autoware runtime container with the map data:</p> <pre><code>./docker/run.sh --map-path path_to_map_data\n</code></pre> <p>For more launch options, you can append a custom launch command instead of using the default launch command which is <code>ros2 launch autoware_launch autoware.launch.xml</code>.</p> <p>Here is an example of running the runtime container with a custom launch command:</p> <pre><code>./docker/run.sh --map-path ~/autoware_map/sample-map-rosbag ros2 launch autoware_launch planning_simulator.launch.xml map_path:=/autoware_map vehicle_model:=sample_vehicle sensor_model:=sample_sensor_kit\n</code></pre> <p>Info</p> <p>You can use <code>--no-nvidia</code> to run without NVIDIA GPU support, and <code>--headless</code> to run without display that means no RViz visualization.</p>"},{"location":"installation/autoware/docker-installation/#run-the-autoware-tutorials","title":"Run the Autoware tutorials","text":"<p>Inside the container, you can run the Autoware tutorials by following these links:</p> <p>Planning Simulation</p> <p>Rosbag Replay Simulation.</p>"},{"location":"installation/autoware/docker-installation/#development-environment","title":"Development environment","text":"<pre><code>./docker/run.sh --devel\n</code></pre> <p>Info</p> <p>By default workspace mounted on the container will be current directory(pwd), you can change the workspace path by <code>--workspace path_to_workspace</code>. For development environments without NVIDIA GPU support use <code>--no-nvidia</code>.</p>"},{"location":"installation/autoware/docker-installation/#how-to-set-up-a-workspace","title":"How to set up a workspace","text":"<ol> <li> <p>Create the <code>src</code> directory and clone repositories into it.</p> <pre><code>mkdir src\nvcs import src &lt; autoware.repos\n</code></pre> </li> <li> <p>Update dependent ROS packages.</p> <p>The dependency of Autoware may change after the Docker image was created.  In that case, you need to run the following commands to update the dependency.</p> <pre><code>sudo apt update\nrosdep update\nrosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO\n</code></pre> </li> <li> <p>Build the workspace.</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>If there is any build issue, refer to Troubleshooting.</p> </li> </ol> <p>To Update the Workspace</p> <pre><code>cd autoware\ngit pull\nvcs import src &lt; autoware.repos\nvcs pull src\n</code></pre>"},{"location":"installation/autoware/docker-installation/#using-vs-code-remote-containers-for-development","title":"Using VS Code remote containers for development","text":"<p>Using the Visual Studio Code with the Remote - Containers extension, you can develop Autoware in the containerized environment with ease.</p> <p>Get the Visual Studio Code's Remote - Containers extension. And reopen the workspace in the container by selecting <code>Remote-Containers: Reopen in Container</code> from the Command Palette (<code>F1</code>).</p> <p>You can choose Autoware or Autoware-cuda image to develop with or without CUDA support.</p>"},{"location":"installation/autoware/docker-installation/#building-docker-images-from-scratch","title":"Building Docker images from scratch","text":"<p>If you want to build these images locally for development purposes, run the following command:</p> <pre><code>cd autoware/\n./docker/build.sh\n</code></pre> <p>To build without CUDA, use the <code>--no-cuda</code> option:</p> <pre><code>./docker/build.sh --no-cuda\n</code></pre> <p>To build only development image, use the <code>--devel-only</code> option:</p> <pre><code>./docker/build.sh --devel-only\n</code></pre> <p>To specify the platform, use the <code>--platform</code> option:</p> <pre><code>./docker/build.sh --platform linux/amd64\n./docker/build.sh --platform linux/arm64\n</code></pre>"},{"location":"installation/autoware/docker-installation/#using-docker-images-other-than-latest","title":"Using Docker images other than <code>latest</code>","text":"<p>There are also images versioned based on the <code>date</code> or <code>release tag</code>. Use them when you need a fixed version of the image.</p> <p>The list of versions can be found here.</p>"},{"location":"installation/autoware/source-installation/","title":"Source installation","text":""},{"location":"installation/autoware/source-installation/#source-installation","title":"Source installation","text":""},{"location":"installation/autoware/source-installation/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>OS</p> <ul> <li>Ubuntu 22.04</li> </ul> </li> </ul> <ul> <li> <p>ROS</p> <ul> <li>ROS 2 Humble</li> </ul> <p>For ROS 2 system dependencies, refer to REP-2000.</p> </li> </ul> <ul> <li>Git<ul> <li>Registering SSH keys to GitHub is preferable.</li> </ul> </li> </ul> <pre><code>sudo apt-get -y update\nsudo apt-get -y install git\n</code></pre> <p>Note: If you wish to use ROS 2 Galactic on Ubuntu 20.04, refer to installation instruction from galactic branch, but be aware that Galactic version of Autoware might not have the latest features.</p>"},{"location":"installation/autoware/source-installation/#how-to-set-up-a-development-environment","title":"How to set up a development environment","text":"<ol> <li> <p>Clone <code>autowarefoundation/autoware</code> and move to the directory.</p> <pre><code>git clone https://github.com/autowarefoundation/autoware.git\ncd autoware\n</code></pre> </li> <li> <p>If you are installing Autoware for the first time, you can automatically install the dependencies by using the provided Ansible script.</p> <pre><code>./setup-dev-env.sh\n</code></pre> <p>If you encounter any build issues, please consult the Troubleshooting section for assistance.</p> </li> </ol> <p>Info</p> <p>Before installing NVIDIA libraries, please ensure that you have reviewed and agreed to the licenses.</p> <ul> <li>CUDA</li> <li>cuDNN</li> <li>TensorRT</li> </ul> <p>Note</p> <p>The following items will be automatically installed. If the ansible script doesn't work or if you already have different versions of dependent libraries installed, please install the following items manually.</p> <ul> <li>Install Ansible</li> <li>Install Build Tools</li> <li>Install Dev Tools</li> <li>Install gdown</li> <li>Install geographiclib</li> <li>Install pacmod</li> <li>Install the RMW Implementation</li> <li>Install ROS 2</li> <li>Install ROS 2 Dev Tools</li> <li>Install Nvidia CUDA</li> <li>Install Nvidia cuDNN and TensorRT</li> <li>Download the Artifacts (for perception inference)</li> </ul>"},{"location":"installation/autoware/source-installation/#how-to-set-up-a-workspace","title":"How to set up a workspace","text":"<p>Using Autoware Build GUI</p> <p>If you prefer a graphical user interface (GUI) over the command line for launching and managing your simulations, refer to the <code>Using Autoware Build GUI</code> section at the end of this document for a step-by-step guide.</p> <ol> <li> <p>Create the <code>src</code> directory and clone repositories into it.</p> <p>Autoware uses vcstool to construct workspaces.</p> <pre><code>cd autoware\nmkdir src\nvcs import src &lt; autoware.repos\n</code></pre> </li> <li> <p>Install dependent ROS packages.</p> <p>Autoware requires some ROS 2 packages in addition to the core components.  The tool <code>rosdep</code> allows an automatic search and installation of such dependencies.  You might need to run <code>rosdep update</code> before <code>rosdep install</code>.</p> <pre><code>source /opt/ros/humble/setup.bash\nrosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO\n</code></pre> </li> <li> <p>Install and set up ccache to speed up consecutive builds. (optional but highly recommended)</p> </li> <li> <p>Build the workspace.</p> <p>Autoware uses colcon to build workspaces.  For more advanced options, refer to the documentation.</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>If there is any build issue, refer to Troubleshooting.</p> </li> <li> <p>Follow the steps in Network Configuration before running Autoware.</p> </li> <li> <p>Apply the settings recommended in Console settings for ROS 2 for a better development experience. (optional)</p> </li> </ol>"},{"location":"installation/autoware/source-installation/#how-to-update-a-workspace","title":"How to update a workspace","text":"<ol> <li> <p>Update the <code>.repos</code> file.</p> <pre><code>cd autoware\ngit pull &lt;remote&gt; &lt;your branch&gt;\n</code></pre> <p><code>&lt;remote&gt;</code> is usually <code>git@github.com:autowarefoundation/autoware.git</code></p> </li> <li> <p>Update the repositories.</p> <pre><code>vcs import src &lt; autoware.repos\nvcs pull src\n</code></pre> <p>For Git users:</p> <ul> <li><code>vcs import</code> is similar to <code>git checkout</code>.<ul> <li>Note that it doesn't pull from the remote.</li> </ul> </li> <li><code>vcs pull</code> is similar to <code>git pull</code>.<ul> <li>Note that it doesn't switch branches.</li> </ul> </li> </ul> <p>For more information, refer to the official documentation.</p> </li> <li> <p>Install dependent ROS packages.</p> <pre><code>source /opt/ros/humble/setup.bash\nrosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO\n</code></pre> </li> <li> <p>Build the workspace.</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> </li> </ol>"},{"location":"installation/autoware/source-installation/#using-autoware-build-gui","title":"Using Autoware Build GUI","text":"<p>In addition to the traditional command-line methods of building Autoware packages, developers and users can leverage the Autoware Build GUI for a more streamlined and user-friendly experience. This GUI application simplifies the process of building and managing Autoware packages.</p>"},{"location":"installation/autoware/source-installation/#integration-with-autoware-source-installation","title":"Integration with Autoware source installation","text":"<p>When using the Autoware Build GUI in conjunction with the traditional source installation process:</p> <ul> <li>Initial Setup: Follow the standard Autoware source installation guide to set up your environment and workspace.</li> <li>Using the GUI: Once the initial setup is complete, you can use the Autoware Build GUI to manage subsequent builds and package updates.</li> </ul> <p>This integration offers a more accessible approach to building and managing Autoware packages, catering to both new users and experienced developers.</p>"},{"location":"installation/autoware/source-installation/#getting-started-with-autoware-build-gui","title":"Getting started with Autoware Build GUI","text":"<ol> <li>Installation: Ensure you have installed the Autoware Build GUI. Installation instructions.</li> <li>Launching the App: Once installed, launch the Autoware Build GUI.    </li> <li>Setting Up: Set the path to your Autoware folder within the GUI.    </li> <li> <p>Building Packages: Select the Autoware packages you wish to build and manage the build process through the GUI.    </p> <p>4.1. Build Configuration: Choose from a list of default build configurations, or select the packages you wish to build manually.  </p> <p>4.2. Build Options: Choose which build type you wish to use, with ability to specify additional build options.  </p> </li> <li> <p>Save and Load: Save your build configurations for future use, or load a previously saved configuration if you don't wish to build all packages or use one of the default configurations provided.    </p> </li> <li>Updating Workspace: Update your Autoware workspace's packages to the latest version using the GUI or adding Calibration tools to the workspace.    </li> </ol>"},{"location":"installation/related-tools/","title":"Installation of related tools","text":""},{"location":"installation/related-tools/#installation-of-related-tools","title":"Installation of related tools","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"models/","title":"Machine learning models","text":""},{"location":"models/#machine-learning-models","title":"Machine learning models","text":"<p>The Autoware perception stack uses models for inference. These models are automatically downloaded as part of the <code>setup-dev-env.sh</code> script.</p> <p>The models are hosted by Web.Auto.</p> <p>Default models directory (<code>data_dir</code>) is <code>~/autoware_data</code>.</p>"},{"location":"models/#download-instructions","title":"Download instructions","text":"<p>Please follow the download instruction in autoware download instructions for updated models downloading.</p> <p>The models can be also downloaded manually using download tools such as <code>wget</code> or <code>curl</code>. The latest urls of weight files and param files for each model can be found at autoware main.yaml file</p> <p>The example of downloading <code>lidar_centerpoint</code> model:</p> <pre><code># lidar_centerpoint\n\n$ mkdir -p ~/autoware_data/lidar_centerpoint/\n$ wget -P ~/autoware_data/lidar_centerpoint/ \\\nhttps://awf.ml.dev.web.auto/perception/models/centerpoint/v2/pts_voxel_encoder_centerpoint.onnx \\\nhttps://awf.ml.dev.web.auto/perception/models/centerpoint/v2/pts_backbone_neck_head_centerpoint.onnx \\\nhttps://awf.ml.dev.web.auto/perception/models/centerpoint/v2/pts_voxel_encoder_centerpoint_tiny.onnx \\\nhttps://awf.ml.dev.web.auto/perception/models/centerpoint/v2/pts_backbone_neck_head_centerpoint_tiny.onnx \\\nhttps://awf.ml.dev.web.auto/perception/models/centerpoint/v2/centerpoint_ml_package.param.yaml \\\nhttps://awf.ml.dev.web.auto/perception/models/centerpoint/v2/centerpoint_tiny_ml_package.param.yaml \\\nhttps://awf.ml.dev.web.auto/perception/models/centerpoint/v2/centerpoint_sigma_ml_package.param.yaml \\\nhttps://awf.ml.dev.web.auto/perception/models/centerpoint/v2/detection_class_remapper.param.yaml \\\nhttps://awf.ml.dev.web.auto/perception/models/centerpoint/v2/deploy_metadata.yaml\n</code></pre>"},{"location":"reference-hw/","title":"Reference HW Design","text":""},{"location":"reference-hw/#reference-hw-design","title":"Reference HW Design","text":"<p>This document is created to describe and give additional information of the sensors and systems supported by Autoware.Universe software.</p> <p>All equipment listed in this document has available ROS 2 drivers and has been tested by one or more of the community members on field in autonomous vehicle and robotics applications.</p> <p>The listed sensors and systems are not sold, developed or given direct technical support by the Autoware community. Having said that any ROS 2 and Autoware related issue regarding the hardware usage could be asked using the community guidelines which found here.</p> <p>The documents consists of the sections listed below:</p> <ul> <li> <p>AD COMPUTERs</p> <ul> <li>ADLINK In-Vehicle Computers<ul> <li>NXP In-Vehicle Computers</li> <li>Neousys In-Vehicle Computers</li> <li>Crystal Rugged In-Vehicle Computers</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p>LiDARs</p> <ul> <li>Velodyne 3D LiDAR Sensors</li> <li>Robosense 3D LiDAR Sensors</li> <li>HESAI 3D LiDAR Sensors</li> <li>Leishen 3D LiDAR Sensors</li> <li>Livox 3D LiDAR Sensors</li> <li>Ouster 3D LiDAR Sensors</li> </ul> </li> </ul> <ul> <li> <p>RADARs</p> <ul> <li>Smartmicro Automotive Radars</li> <li>Aptiv Automotive Radars</li> <li>Continental Engineering Radars</li> </ul> </li> </ul> <ul> <li> <p>CAMERAs</p> <ul> <li>FLIR Machine Vision Cameras</li> <li>Lucid Vision Cameras</li> <li>Allied Vision Cameras</li> <li>Tier IV Cameras</li> <li>Neousys Technology Cameras</li> </ul> </li> </ul> <ul> <li> <p>Thermal CAMERAs</p> <ul> <li>FLIR Thermal Automotive Dev. Kit</li> </ul> </li> </ul> <ul> <li> <p>IMU, AHRS &amp; GNSS/INS</p> <ul> <li>NovAtel GNSS/INS Sensors</li> <li>XSens GNSS/INS &amp; IMU Sensors</li> <li>SBG GNSS/INS &amp; IMU Sensors</li> <li>Applanix GNSS/INS Sensors</li> <li>PolyExplore GNSS/INS Sensors</li> <li>Fix Position GNSS/INS Sensors</li> </ul> </li> </ul> <ul> <li> <p>Vehicle Drive By Wire Suppliers    </p> <ul> <li>Dataspeed DBW Solutions</li> <li>AStuff Pacmod DBW Solutions</li> <li>Schaeffler-Paravan Space Drive DBW Solutions</li> </ul> </li> </ul> <ul> <li> <p>Vehicle Platform Suppliers</p> <ul> <li>PIX MOVING Autonomous Vehicle Solutions</li> <li>Autonomoustuff AV Solutions</li> <li>NAVYA AV Solutions</li> </ul> </li> </ul> <ul> <li> <p>Remote Drive</p> <ul> <li>FORT ROBOTICS</li> <li>LOGITECH</li> </ul> </li> </ul> <ul> <li>Full Drivers List</li> </ul> <ul> <li> <p>AD Sensor Kit Suppliers</p> <ul> <li>LEO Drive AD Sensor Kit</li> <li>TIER IV AD Kit</li> <li>RoboSense AD Sensor Kit</li> </ul> </li> </ul>"},{"location":"reference-hw/ad-computers/","title":"AD Computers","text":""},{"location":"reference-hw/ad-computers/#ad-computers","title":"AD Computers","text":""},{"location":"reference-hw/ad-computers/#adlink-in-vehicle-computers","title":"ADLINK In-Vehicle Computers","text":"<p>ADLINK solutions which is used for autonomous driving and tested by one or more community members are listed below:</p> Supported Products List CPU GPU RAM, Interfaces Environmental Autoware Tested (Y/N) AVA-3510 Intel\u00ae Xeon\u00ae E-2278GE Dual MXM RTX 5000 64GB RAM,CAN, USB, 10G Ethernet, DIO, Hot-Swap SSD, USIM 9~36 VDC, MIL-STD-810H,ISO 7637-2 Y SOAFEE\u2019s AVA Developer Platform Ampere Altra ARMv8 optional USB, Ethernet, DIO, M.2 NVMe SSDs 110/220 AC Y RQX-58G 8-core Arm Nvidia Jetson AGX Xavier USB, Ethernet, M.2 NVME SSD, CAN, USIM, GMSL2 Camera support 9~36VDC, IEC 60068-2-64: Operating 3Grms, 5-500 Hz, 3 axes Y RQX-59G 8-core Arm Nvidia Jetson AGX Orin USB, Ethernet, M.2 NVME SSD, CAN, USIM, GMSL2 Camera support 9~36VDC, IEC 60068-2-64: Operating 3Grms, 5-500 Hz, 3 axes - <p>Link to company website is here.</p>"},{"location":"reference-hw/ad-computers/#nxp-in-vehicle-computers","title":"NXP In-Vehicle Computers","text":"<p>NXP solutions which is used for autonomous driving and tested by one or more community members are listed below:</p> Supported Products List CPU GPU RAM, Interfaces Environmental Autoware Tested (Y/N) BLUEBOX 3.0 16 x Arm\u00ae Cortex\u00ae-A72 Dual RTX 8000 or RTX A6000 16 GB RAM CAN, FlexRay, USB, Ethernet, DIO, SSD ASIL-D - <p>Link to company website is here.</p>"},{"location":"reference-hw/ad-computers/#neousys-in-vehicle-computers","title":"Neousys In-Vehicle Computers","text":"<p>Neousys solutions which is used for autonomous driving and tested by one or more community members are listed below:</p> Supported Products List CPU GPU RAM, Interfaces Environmental Autoware Tested (Y/N) 8805-GC AMD\u00ae EPYC\u2122 7003 NVIDIA\u00ae RTX A6000/ A4500 512GB CAN, USB, Ethernet, Serial, Easy-Swap SSD 8-48 Volt, Vibration:MIL-STD810G, Method 514.6, Category 4 Y 10208-GC Intel\u00ae 13th/12th-Gen Core\u2122 Dual 350W NVIDIA\u00ae RTX GPU 64GB CAN, USB, Ethernet, Serial, M2 NVMe SSD 8~48 Volt, Vibration: MIL-STD-810H, Method 514.8, Category 4 Y 9160-GC Intel\u00ae 13th/12th-Gen Core\u2122 NVIDIA\u00ae RTX series up to 130W TDP 64GB CAN, USB, Ethernet, PoE, Serial, two 2.5\" SATA HDD/SSD with RAID, M2 NVMe SSD 8~48, Vibration: Volt,MIL-STD-810G, Method 514.6, Category 4 - <p>Link to company website is here.</p>"},{"location":"reference-hw/ad-computers/#crystal-rugged-in-vehicle-computers","title":"Crystal Rugged In-Vehicle Computers","text":"<p>Crystal Rugged solutions which is used for autonomous driving and tested by one or more community members are listed below:</p> Supported Products List CPU GPU RAM, Interfaces Environmental Autoware Tested (Y/N) AVC 0161-AC Intel\u00ae Xeon\u00ae Scalable Dual GPU RTX Series 2TB RAM,CAN, USB, Ethernet, Serial, Hot-Swap SSD 10-32 VoltVibration:2 G RMS 10-1000 Hz, 3 axes - AVC0403 Intel\u00ae Xeon\u00ae Scalable or AMD EPYC\u2122 Optional (5 GPU) 2TB RAM, CAN, USB, Ethernet, Serial, Hot-Swap SSD 10-32 Volt, Vibration: 2 G RMS 10-1000 Hz, 3 axes - AVC1322 Intel\u00ae Xeon\u00ae D-1718T or Gen 12/13 Core\u2122 i3/i5/i7 NVIDIA\u00ae Jetson AGX Orin 128 GB DDR4 RAM, USB, Ethernet, Serial, SATA 2.5\u201d SSD 10-36 Volt, Vibration: 5.5g, 5-2,000Hz, 60 min/axis, 3 axis - AVC1753 10th Generation Intel\u00ae Core\u2122 and Xeon\u00ae Optional (1 GPU) 128 GB DDR4 RAM, USB, Ethernet, NVMe U.2 SSD/ 3 SATA SSD 8-36 VDC/ 120-240VAC 50/60Hz, Vibration: 5.5g, 5-2,000Hz, 60 min/axis, 3 axis - <p>Link to company website is here.</p>"},{"location":"reference-hw/ad-computers/#vecow-in-vehicle-computers","title":"Vecow In-Vehicle Computers","text":"<p>Vecow solutions which is used for autonomous driving and tested by one or more community members are listed below:</p> Supported Products List CPU GPU RAM, Interfaces Environmental Autoware Tested (Y/N) ECX-3800 PEG Intel\u00ae 13th/12th-Gen Core\u2122 200W power of NVIDIA\u00ae or AMD graphics 64GB RAM, CAN, USB, Ethernet, PoE, Serial, M.2/SATA SSD, SIM Card 12-50 Volt, Vibration:MIL-STD810G, Procedure I, 20\u00b0C to 45\u00b0C - IVX-1000 Intel\u00ae 13th/12th-Gen Core\u2122 NVIDIA Quadro\u00ae MXM Graphics 64GB RAM, Ethernet, PoE, Serial, M.2/SATA/mSATA SSD, SIM Card 16-160 Volt, Vibration: IEC 61373 : 2010, 40\u00b0C to 85\u00b0C - <p>Link to company website is here.</p>"},{"location":"reference-hw/ad_sensor_kit_suppliers/","title":"AD Sensor Kit Suppliers","text":""},{"location":"reference-hw/ad_sensor_kit_suppliers/#ad-sensor-kit-suppliers","title":"AD Sensor Kit Suppliers","text":""},{"location":"reference-hw/ad_sensor_kit_suppliers/#leo-drive-ad-sensor-kit","title":"LEO Drive AD Sensor Kit","text":"<p>LEO Drive Autonomy Essentials Kit contents are listed below:</p> Supported Products List Camera Lidar GNSS/INS ROS 2 Support Autoware Tested (Y/N) Autonomy Essentials Kit 8x Lucid Vision TRI054S 4x Velodyne Puck1x Velodyne Alpha Prime1x RoboSense Bpearl 1x SBG Ellipse-D Y Y <p>Link to company website: https://leodrive.ai/</p>"},{"location":"reference-hw/ad_sensor_kit_suppliers/#tier-iv-ad-kit","title":"TIER IV AD Kit","text":"<p>TIER IV sensor fusion system contents are listed below:</p> Supported Products List Camera Lidar ECU ROS 2 Support Autoware Tested (Y/N) TIER IV ADK TIER IV C1, C2 HESAI (AT-128,XT-32)Velodyne ADLINK (RQX-58G, AVA-3510) Y Y <p>Link to company website: https://sensor.tier4.jp/sensor-fusion-system</p>"},{"location":"reference-hw/ad_sensor_kit_suppliers/#robosense-ad-sensor-kit","title":"RoboSense AD Sensor Kit","text":"<p>RoboSense L4 sensor fusion solution system contents are listed below:</p> Supported Products List Camera Lidar ECU ROS 2 Support Autoware Tested (Y/N) P6 - 4x Automotive Grade Solid-state Lidar Optional - - <p>Link to company website: https://www.robosense.ai/en/rslidar/RS-Fusion-P6</p>"},{"location":"reference-hw/cameras/","title":"CAMERAs","text":""},{"location":"reference-hw/cameras/#cameras","title":"CAMERAs","text":""},{"location":"reference-hw/cameras/#tier-iv-automotive-hdr-cameras","title":"TIER IV Automotive HDR Cameras","text":"<p>TIER IV's Automotive HDR cameras which have ROS 2 driver and tested by TIER IV are listed below:</p> Supported Products List MP FPS Interface HDR LFM Trigger  /Synchronization Ingress  Protection ROS 2 Driver Autoware  Tested (Y/N) C1 2.5 30 GMSL2  / USB3 Y (120dB) Y Y IP69K Y Y C2 5.4 30 GMSL2  / USB3 Y (120dB) Y Y IP69K Y Y C3  (to be released in 2024) 8.3 30 GMSL2  / TBD Y (120dB) Y Y IP69K Y Y <p>Link to ROS 2 driver: https://github.com/tier4/ros2_v4l2_camera</p> <p>Link to product support site: TIER IV Edge.Auto documentation</p> <p>Link to product web site: TIER IV Automotive Camera Solution</p>"},{"location":"reference-hw/cameras/#flir-machine-vision-cameras","title":"FLIR Machine Vision Cameras","text":"<p>FLIR Machine Vision cameras which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List MP FPS Interface HDR LFM Trigger  /Synchronization Ingress  Protection ROS 2 Driver Autoware Tested (Y/N) Blackfly S 2.0  5.0 22  95 USB-GigE N/A N/A Y N/A Y - Grasshopper3 2.3  5.0 26  90 USB-GigE N/A N/A Y N/A Y - <p>Link to ROS 2 driver: https://github.com/berndpfrommer/flir_spinnaker_ros2</p> <p>Link to company website: https://www.flir.eu/iis/machine-vision/</p>"},{"location":"reference-hw/cameras/#lucid-vision-cameras","title":"Lucid Vision Cameras","text":"<p>Lucid Vision cameras which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List MP FPS Interface HDR LFM Trigger  /Synchronization Ingress  Protection ROS 2 Driver Autoware Tested (Y/N) TRITON 054S 5.4 22 GigE Y Y Y up to IP67 Y Y TRITON 032S 3.2 35.4 GigE N/A N/A Y up to IP67 Y Y <p>Link to ROS 2 driver: https://gitlab.com/leo-drive/Drivers/arena_camera Link to company website: https://thinklucid.com/triton-gige-machine-vision/</p>"},{"location":"reference-hw/cameras/#allied-vision-cameras","title":"Allied Vision Cameras","text":"<p>Allied Vision cameras which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List MP FPS Interface HDR LFM Trigger  /Synchronization Ingress  Protection ROS 2 Driver Autoware Tested (Y/N) Mako G319 3.2 37.6 GigE N/A N/A Y N/A Y - <p>Link to ROS 2 driver: https://github.com/neil-rti/avt_vimba_camera</p> <p>Link to company website: https://www.alliedvision.com/en/products/camera-series/mako-g</p>"},{"location":"reference-hw/cameras/#neousys-technology-camera","title":"Neousys Technology Camera","text":"<p>Neousys Technology cameras which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List MP FPS Interface Sensor Format Lens ROS 2 Driver Autoware Tested (Y/N) AC-IMX390 2.0 30 GMSL2  (over PCIe-GL26 Grabber Card) 1/2.7\u201d 5-axis active adjustment with adhesive dispense Y Y <p>Link to ROS 2 driver: https://github.com/ros-drivers/gscam</p> <p>Link to company website: https://www.neousys-tech.com/en/</p>"},{"location":"reference-hw/full_drivers_list/","title":"Drivers List","text":""},{"location":"reference-hw/full_drivers_list/#drivers-list","title":"Drivers List","text":"<p>The list of all drivers listed above for easy access as a table with additional information:</p> Type Maker Driver links License Maintainer Lidar VelodyneHesai Link Apache 2 david.wong@tier4.jpabraham.monrroy@map4.jp Lidar Velodyne Link BSD jwhitley@autonomoustuff.com Lidar Robosense Link BSD zdxiao@robosense.cn Lidar Hesai Link Apache 2 wuxiaozhou@hesaitech.com Lidar Leishen Link - - Lidar Livox Link MIT dev@livoxtech.com Lidar Ouster Link Apache 2 stevenmacenski@gmail.comtom@boxrobotics.ai Radar smartmicro Link Apache 2 opensource@smartmicro.de Radar Continental Engineering Link Apache 2 abraham.monrroy@tier4.jpsatoshi.tanaka@tier4.jp Camera Flir Link Apache 2 bernd.pfrommer@gmail.com Camera Lucid Vision Link - kcolak@leodrive.ai Camera Allied Vision Link Apache 2 at@email.com Camera Tier IV Link GPL - Camera Neousys Technology Link BSD jbo@jhu.edu GNSS NovAtel Link BSD preed@swri.org GNSS SBG Systems Link MIT support@sbg-systems.com GNSS PolyExplore Link - support@polyexplore.com"},{"location":"reference-hw/imu_ahrs_gnss_ins/","title":"IMU, AHRS & GNSS/INS","text":""},{"location":"reference-hw/imu_ahrs_gnss_ins/#imu-ahrs-gnssins","title":"IMU, AHRS &amp; GNSS/INS","text":""},{"location":"reference-hw/imu_ahrs_gnss_ins/#novatel-gnssins-sensors","title":"NovAtel GNSS/INS Sensors","text":"<p>NovAtel GNSS/INS sensors which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List INS Rate Roll, Pitch, Yaw Acc. GNSS ROS 2 Driver\u00a0 Autoware Tested (Y/N) PwrPak7D-E2 200 Hz R (0.013\u00b0)P (0.013\u00b0)Y (0.070\u00b0) 20 HzL1 / L2 / L5 555 Channels Y - Span CPT7 200 Hz R (0.01\u00b0)\u00a0P (0.01\u00b0)\u00a0Y (0.03\u00b0) 20 Hz L1 / L2 / L5 555 Channels Y - <p>Link to ROS 2 driver: https://github.com/swri-robotics/novatel_gps_driver/tree/dashing-devel</p> <p>Link to company website: https://hexagonpositioning.com/</p>"},{"location":"reference-hw/imu_ahrs_gnss_ins/#xsens-gnssins-imu-sensors","title":"XSens GNSS/INS &amp; IMU Sensors","text":"<p>XSens GNSS/INS sensors which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List INS/IMU Rate Roll, Pitch, Yaw Acc. GNSS ROS 2 Driver\u00a0 Autoware Tested (Y/N) MTi-680G 2 kHz R (0.2\u00b0)P (0.2\u00b0)Y (0.5\u00b0) 5 HzL1 / L2\u00a0184 Channels Y - MTi-300 AHRS 2 kHz R (0.2\u00b0)P (0.2\u00b0)Y (1\u00b0) Not Applicable Y - <p>Link to ROS 2 driver: http://wiki.ros.org/xsens_mti_driver</p> <p>Link to company website: https://www.xsens.com/</p>"},{"location":"reference-hw/imu_ahrs_gnss_ins/#sbg-gnssins-imu-sensors","title":"SBG GNSS/INS &amp; IMU Sensors","text":"<p>SBG GNSS/INS sensors which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List INS/IMU Rate Roll, Pitch, Yaw Acc. GNSS ROS 2 Driver\u00a0 Autoware Tested (Y/N) Ellipse-D 200 Hz, 1 kHz (IMU) R (0.1\u00b0)P (0.1\u00b0)Y (0.05\u00b0) 5 HzL1 / L2184 Channels Y Y Ellipse-A (AHRS) 200 Hz, 1 kHz (IMU) R (0.1\u00b0)P (0.1\u00b0)Y (0.8\u00b0) Not Applicable Y - <p>Link to ROS 2 driver: https://github.com/SBG-Systems/sbg_ros2</p> <p>Link to company website: https://www.sbg-systems.com/products/ellipse-series/</p>"},{"location":"reference-hw/imu_ahrs_gnss_ins/#applanix-gnssins-sensors","title":"Applanix GNSS/INS Sensors","text":"<p>SBG GNSS/INS sensors which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List INS/IMU Rate Roll, Pitch, Yaw Acc. GNSS ROS 2 Driver\u00a0 Autoware Tested (Y/N) POSLVX 200 Hz R (0.03\u00b0)P (0.03\u00b0)Y (0.09\u00b0) L1 / L2 / L5336 Channels Y Y POSLV220 200 Hz R (0.02\u00b0)P (0.02\u00b0)Y (0.05\u00b0) L1 / L2 / L5336 Channels Y Y <p>Link to ROS 2 driver: http://wiki.ros.org/applanix_driver</p> <p>Link to company website: https://www.applanix.com/products/poslv.htm</p>"},{"location":"reference-hw/imu_ahrs_gnss_ins/#polyexplore-gnssins-sensors","title":"PolyExplore GNSS/INS Sensors","text":"<p>PolyExplore GNSS/INS sensors which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List INS/IMU Rate Roll, Pitch, Yaw Acc. GNSS ROS 2 Driver\u00a0 Autoware Tested (Y/N) POLYNAV 2000P 100 Hz R (0.01\u00b0)P (0.01\u00b0)Y (0.1\u00b0) L1 / L2240 Channels Y - POLYNAV 2000S 100 Hz R (0.015\u00b0)P (0.015\u00b0)Y (0.08\u00b0) L1 / L240 Channels Y - <p>Link to ROS 2 driver: https://github.com/polyexplore/ROS2_Driver</p> <p>Link to company website: https://www.polyexplore.com/</p>"},{"location":"reference-hw/imu_ahrs_gnss_ins/#fixposition-visual-gnssins-sensors","title":"Fixposition Visual GNSS/INS Sensors","text":"Supported Products List INS/IMU Rate Roll, Pitch, Yaw Acc. GNSS ROS 2 Driver\u00a0 Autoware Tested (Y/N) Vision-RTK 2 200Hz - 5 HzL1 / L2 Y - <p>Link to ROS 2 driver: https://github.com/fixposition/fixposition_driver</p> <p>Link to company website: https://www.fixposition.com/</p> <p>Additional utilities:</p> <ul> <li>Fixposition GNSS transformation lib: https://github.com/fixposition/fixposition_gnss_tf</li> <li>Miscellaneous utilities (logging, software update, ...): https://github.com/fixposition/fixposition_utility</li> </ul>"},{"location":"reference-hw/lidars/","title":"LIDARs","text":""},{"location":"reference-hw/lidars/#lidars","title":"LIDARs","text":""},{"location":"reference-hw/lidars/#velodyne-3d-lidar-sensors","title":"Velodyne 3D LIDAR Sensors","text":"<p>Velodyne Lidars which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List Range FOV (V), (H) ROS 2 Driver Autoware Tested (Y/N) Alpha Prime 245m (+15\u00b0)/(-25\u00b0), (360\u00b0) Y Y Ultra Puck 200m (+15\u00b0)/(-25\u00b0), (360\u00b0) Y Y Puck 100m (+15\u00b0)/(-15\u00b0), (360\u00b0) Y Y Puck Hi-res 100m (+10\u00b0)/(-10\u00b0), (360\u00b0) Y Y <p>Link to ROS 2 drivers: https://github.com/tier4/nebula https://github.com/ros-drivers/velodyne/tree/ros2/velodyne_pointcloud https://gitlab.com/autowarefoundation/autoware.auto/AutowareAuto/-/tree/master/src/drivers/velodyne_nodes https://github.com/autowarefoundation/awf_velodyne/tree/tier4/universe</p> <p>Link to company website: https://velodynelidar.com/</p>"},{"location":"reference-hw/lidars/#robosense-3d-lidar-sensors","title":"RoboSense 3D LIDAR Sensors","text":"<p>RoboSense Lidars which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List Range FOV (V), (H) ROS 2 Driver Autoware Tested (Y/N) M1 200m 25\u00b0/120\u00b0 - - E1 30m 90\u00b0/120\u00b0 - - Bpearl 100m 90\u00b0/360\u00b0 Y Y Ruby Plus 250m 40\u00b0/360\u00b0 Y ? Helios 32 150m 70\u00b0/360\u00b0 31\u00b0/360\u00b0 26\u00b0/360\u00b0 Y Y Helios 16 150m 30\u00b0/360\u00b0 Y ? <p>Link to ROS 2 driver: https://github.com/RoboSense-LiDAR/rslidar_sdk</p> <p>Link to company website: https://www.robosense.ai/</p>"},{"location":"reference-hw/lidars/#hesai-3d-lidar-sensors","title":"HESAI 3D LIDAR Sensors","text":"<p>Hesai Lidars which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List Range FOV (V), (H) ROS 2 Driver Autoware Tested (Y/N) Pandar 128 200m (+15\u00b0)/(-25\u00b0), (360\u00b0) Y - Pandar 64 200m (+15\u00b0)/(-25\u00b0), (360\u00b0) Y Y Pandar 40P 200m (+15\u00b0)/(-25\u00b0), (360\u00b0) Y Y QT 128 50m (-52.6\u00b0/+52.6\u00b0), (360\u00b0) Y Y QT 64 20m (-52.1\u00b0/+52.1\u00b0), (360\u00b0) Y Y AT128 200m (25.4\u00b0), (120\u00b0) Y Y XT32 120m (-16\u00b0/+15\u00b0), (360\u00b0) Y Y XT16 120m (-15\u00b0/+15\u00b0), (360\u00b0) Y - FT120 100m (75\u00b0), (100\u00b0) - - ET25 250m (25\u00b0), (120\u00b0) - - <p>Link to ROS 2 drivers: https://github.com/tier4/nebula https://github.com/HesaiTechnology/HesaiLidar_General_ROS</p> <p>Link to company website: https://www.hesaitech.com/en/</p>"},{"location":"reference-hw/lidars/#leishen-3d-lidar-sensors","title":"Leishen 3D LIDAR Sensors","text":"<p>Leishen Lidars which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List Range FOV (V), (H) ROS 2 Driver Autoware Tested (Y/N) LS C16 150m (+15\u00b0/-15\u00b0), (360\u00b0) Y - LS C32\u00a0 150m (+15\u00b0/-15\u00b0), (360\u00b0) Y - CH 32 120m (+3.7\u00b0/-6.7\u00b0),(120\u00b0) Y - CH 128 20m (+14\u00b0/-17\u00b0)/(150\u00b0) Y - C32W 160m (+15\u00b0/-55\u00b0), (360\u00b0) Y - <p>Link to ROS 2 driver: https://github.com/leishen-lidar</p> <p>Link to company website: http://www.lslidar.com/</p>"},{"location":"reference-hw/lidars/#livox-3d-lidar-sensors","title":"Livox 3D LIDAR Sensors","text":"<p>Livox Lidars which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List Range FOV (V), (H) ROS 2 Driver Autoware Tested (Y/N) Horizon 260m (81.7\u00b0), (25.1\u00b0) Y Y Mid-40 260m (38.4\u00b0), Circular Y - Mid-70 90m (70.4\u00b0), (77.2\u00b0) Y - Mid-100 260m (38.4\u00b0), (98.4\u00b0) Y - Mid-360 70m (+52\u00b0/-7\u00b0), (360\u00b0) Y - Avia 190m (70.4\u00b0), Circular Y - HAP 150m (25\u00b0), (120\u00b0) - - Tele-15 320m (16.2\u00b0), (14.5\u00b0) - - <p>Link to ROS 2 driver: https://github.com/Livox-SDK/livox_ros2_driver</p> <p>Link to company website: https://www.livoxtech.com/</p>"},{"location":"reference-hw/lidars/#ouster-3d-lidar-sensors","title":"Ouster 3D LIDAR Sensors","text":"<p>Ouster Lidars which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List Range FOV (V), (H) ROS 2 Driver Autoware Tested (Y/N) OSDome 45m (180\u00b0), (360\u00b0) Y - OS0 100m (90\u00b0), (360\u00b0) Y - OS1 200m (45\u00b0), (360\u00b0) Y - OS2 400m (22,5\u00b0), (360\u00b0) Y Y <p>Link to ROS 2 driver: https://github.com/ros-drivers/ros2_ouster_drivers</p> <p>Link to company website: https://ouster.com/</p>"},{"location":"reference-hw/radars/","title":"RADARs","text":""},{"location":"reference-hw/radars/#radars","title":"RADARs","text":""},{"location":"reference-hw/radars/#smartmicro-automotive-radars","title":"Smartmicro Automotive Radars","text":"<p>Smartmicro Radars which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List Range FOV (Azimuth), (Elevation) ROS 2 Driver Autoware Tested (Y/N) DRVEGRD 152 (Dual Mode Medium, Long) M: 0.33...66 m L: 0.9\u2026180 m (100\u00b0), (20\u00b0) Y - DRVEGRD 169 (Ultra-Short, Short, Medium, Long) US: 0.1\u20269.5 m S: 0.2\u202619 m M: 0.6...56 m L: 1.3...130 m US: (140\u00b0), (28\u00b0) S/M/L: (130\u00b0), (15\u00b0) Y - DRVEGRD 171 (Triple Mode Short, Medium Long) S: 0.2...40 m M: 0.5...100 m L: 1.2...240 m (100\u00b0), (20\u00b0) Y - <p>Link to ROS 2 driver: https://github.com/smartmicro/smartmicro_ros2_radars</p> <p>Link to company website: https://www.smartmicro.com/automotive-radar</p>"},{"location":"reference-hw/radars/#aptiv-automotive-radars","title":"Aptiv Automotive Radars","text":"<p>Aptiv Radars which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List Range FOV (Azimuth), (Elevation) ROS 2 Driver Autoware Tested (Y/N) Aptiv MMR (Dual Mode Short, Long) S: 1...40 m L: 3...160 m Short.: (90), (90\u00b0) Long: (90\u00b0), (90\u00b0) Y - Aptiv ESR 2.5 (Dual Mode (Medium, Long)) M: 1...60 m L: 1...175 m Med.: (90\u00b0), (4.4\u00b0) Long: (20\u00b0), (4.4\u00b0) Y - <p>Link to company website: https://autonomoustuff.com/products</p>"},{"location":"reference-hw/radars/#continental-engineering-radars","title":"Continental Engineering Radars","text":"<p>Continental Engineering Radars which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List Range FOV (Azimuth), (Elevation) ROS 2 Driver Autoware Tested (Y/N) ARS404 Near: 70m  Far: 170m Near: (90\u00b0), (18\u00b0)  Far: (18\u00b0), (18\u00b0) - - ARS408 Near: 20m  Far: 250m Near: (120\u00b0), (20\u00b0)  Far: (18\u00b0), (14\u00b0) - - <p>Link to ROS 2 driver: https://github.com/tier4/ars408_driver</p> <p>Link to company website: https://conti-engineering.com/components/ars430/</p>"},{"location":"reference-hw/remote_drive/","title":"Remote Drive","text":""},{"location":"reference-hw/remote_drive/#remote-drive","title":"Remote Drive","text":""},{"location":"reference-hw/remote_drive/#fort-robotics","title":"FORT ROBOTICS","text":"<p>Fort Robotics remote control &amp; E-stop devices which are used for autonomous driving and tested by one or more community members are listed below:</p> Supported Products Op.Frequency Controller ROS 2 Support Autoware Tested (Y/N) Vehicle Safety Controller with E-stop 900 Mhz radio: up to 2km LOS2.4Ghz radio: up to 500m LOS IP 66 EnclosureBuilt-in emergency stop safety control(2) 2-axis joysticks(2) 1-axis finger sticks(8) buttons - - <p>Link to company website: https://fortrobotics.com/vehicle-safety-controller/</p>"},{"location":"reference-hw/remote_drive/#logitech","title":"LOGITECH","text":"<p>Logitech joysticks which are used for autonomous driving and tested by one or more community members are listed below:</p> Supported Products Op.Frequency Controller ROS 2 Support Autoware Tested (Y/N) Logitech F-710 2.4 GHz Wireless, 10m range (2) 2-axis joysticks (18) buttons Y Y <p>Link to ROS driver: http://wiki.ros.org/joy</p> <p>Link to company website: https://www.logitechg.com/en-us/products/gamepads/f710-wireless-gamepad.html</p>"},{"location":"reference-hw/thermal_cameras/","title":"Thermal CAMERAs","text":""},{"location":"reference-hw/thermal_cameras/#thermal-cameras","title":"Thermal CAMERAs","text":""},{"location":"reference-hw/thermal_cameras/#flir-thermal-automotive-dev-kit","title":"FLIR Thermal Automotive Dev. Kit","text":"<p>FLIR ADK Thermal Vision cameras which has ROS 2 driver and tested by one or more community members are listed below:</p> Supported Products List MP FPS Interface Spectral Band FOV ROS 2 Driver Autoware Tested (Y/N) FLIR ADK 640x512 30 USB-GMSL,Ethernet 8-14 um (LWIR) 75\u02da, 50\u02da, 32\u02da, and 24\u02da - -"},{"location":"reference-hw/vehicle_drive_by_wire_suppliers/","title":"Vehicle Drive By Wire Suppliers","text":""},{"location":"reference-hw/vehicle_drive_by_wire_suppliers/#vehicle-drive-by-wire-suppliers","title":"Vehicle Drive By Wire Suppliers","text":""},{"location":"reference-hw/vehicle_drive_by_wire_suppliers/#dataspeed-dbw-solutions","title":"Dataspeed DBW Solutions","text":"<p>Dataspeed DBW Controllers which is used for autonomous driving and tested by one or more community members are listed below:</p> Supported Vehicles Power Remote Control ROS 2 Support Autoware Tested (Y/N) Lincoln MKZ, NautilusFord Fusion, F150, Transit Connect, RangerChrysler PacificaJeep CherokeePolaris GEM, RZR, Lincoln Aviator, Jeep Grand Cherokee 12 Channel PDS,15 A Each at 12 V Optional, Available Y - <p>Link to company website: https://www.dataspeedinc.com/</p>"},{"location":"reference-hw/vehicle_drive_by_wire_suppliers/#astuff-pacmod-dbw-solutions","title":"AStuff Pacmod DBW Solutions","text":"<p>Autonomous Stuff Pacmod DBW Controllers which is used for autonomous driving and tested by one or more community members are listed below:</p> Supported Vehicles Power Remote Control ROS 2 Support Autoware Tested (Y/N) Polaris GEM SeriesPolaris eLXD MY 2016+Polaris Ranger X900International ProStarLexus RX-450h MYFord RangerToyota MinivanFord TransitHonda CR-V Power distribution panel Optional, Available Y Y <p>Link to company website: https://autonomoustuff.com/platform/pacmod</p>"},{"location":"reference-hw/vehicle_drive_by_wire_suppliers/#schaeffler-paravan-space-drive-dbw-solutions","title":"Schaeffler-Paravan Space Drive DBW Solutions","text":"<p>Schaeffler-Paravan Space Drive DBW Controllers which is used for autonomous driving and tested by one or more community members are listed below:</p> Supported Vehicles Power Remote Control ROS 2 Support Autoware Tested (Y/N) Custom Integration with Actuators - Optional, Available Y Y <p>Link to company website: https://www.schaeffler-paravan.de/en/products/space-drive-system/</p>"},{"location":"reference-hw/vehicle_platform_suppliers/","title":"Vehicle Platform Suppliers","text":""},{"location":"reference-hw/vehicle_platform_suppliers/#vehicle-platform-suppliers","title":"Vehicle Platform Suppliers","text":""},{"location":"reference-hw/vehicle_platform_suppliers/#pix-moving-autonomous-vehicle-solutions","title":"PIX MOVING Autonomous Vehicle Solutions","text":"<p>PIX Moving AV solutions which is used for autonomous development and tested by one or more community members are listed below:</p> Vehicle Types Sensors Integrated Autoware Installed ROS 2 Support Autoware Tested (Y/N) Electric DBW Chassis and Platforms Y Y Y - <p>Link to company website: https://www.pixmoving.com/pixkit</p> <p>Different sizes of platforms</p> <p></p>"},{"location":"reference-hw/vehicle_platform_suppliers/#autonomoustuff-av-solutions","title":"Autonomoustuff AV Solutions","text":"<p>Autonomoustuff platform solutions which is used for autonomous development and tested by one or more community members are listed below:</p> Vehicle Types Sensors Integrated Autoware Installed ROS 2 Support Autoware Tested (Y/N) Road Vehicles, Golf Carts &amp; Trucks Y Y Y - <p>Link to company website: https://autonomoustuff.com/platform</p>"},{"location":"support/","title":"Support","text":""},{"location":"support/#support","title":"Support","text":"<p>This page explains several support resources.</p> <ul> <li>Support guidelines pages explain the support mechanisms and guidelines.</li> <li>Troubleshooting pages explain solutions for common issues.</li> <li>Docs guide pages explain related documentation sites.</li> </ul>"},{"location":"support/docs-guide/","title":"Docs guide","text":""},{"location":"support/docs-guide/#docs-guide","title":"Docs guide","text":"<p>This page explains several documentation sites that are useful for Autoware and ROS development.</p> <ul> <li>The Autoware Foundation is the official site of the Autoware Foundation. You can learn about the Autoware community here.</li> <li>Autoware Documentation (this site) is the central documentation site for Autoware maintained by the Autoware community. General software-related information of Autoware is aggregated here.</li> <li>Autoware Universe Documentation has READMEs and design documents of software components.</li> <li>ROS Docs Guide explains the ROS 1 and ROS 2 documentation infrastructure.</li> </ul>"},{"location":"support/support-guidelines/","title":"Support guidelines","text":""},{"location":"support/support-guidelines/#support-guidelines","title":"Support guidelines","text":"<p>This page explains the support mechanisms we provide.</p> <p>Warning</p> <p>Before asking for help, search and read this documentation site carefully. Also, follow the discussion guidelines for discussions.</p> <p>Choose appropriate resources depending on what kind of help you need and read the detailed description in the sections below.</p> <ul> <li>Documentation sites<ul> <li>Gathering information</li> </ul> </li> <li>GitHub Discussions<ul> <li>Questions or unconfirmed bugs -&gt; Q&amp;A</li> <li>Feature requests</li> <li>Design discussions</li> </ul> </li> <li>GitHub Issues<ul> <li>Confirmed bugs</li> <li>Confirmed tasks</li> </ul> </li> <li>Discord<ul> <li>Instant messaging between contributors</li> </ul> </li> <li>ROS Discourse<ul> <li>General topics that should be widely announced</li> </ul> </li> </ul>"},{"location":"support/support-guidelines/#guidelines-for-autoware-community-support","title":"Guidelines for Autoware community support","text":"<p>If you encounter a problem with Autoware, please follow these steps to seek help:</p>"},{"location":"support/support-guidelines/#1-search-for-existing-issues-and-questions","title":"1. Search for existing Issues and Questions","text":"<p>Before creating a new issue or question, check if someone else has already reported or asked about the problem. Use the following resources:</p> <ul> <li> <p>Issues</p> <p>Note that Autoware has multiple repositories listed in autoware.repos. It is recommended to search across all repositories.</p> </li> </ul> <ul> <li>Questions</li> </ul>"},{"location":"support/support-guidelines/#2-create-a-new-question-thread","title":"2. Create a new question thread","text":"<p>If you don't find an existing issue or question that addresses your problem, create a new question thread:</p> <ul> <li> <p>Ask a Question</p> <p>If your question is not answered within a week, mention <code>@autoware-maintainers</code> in a post to remind them.</p> </li> </ul>"},{"location":"support/support-guidelines/#3-participate-in-other-discussions","title":"3. Participate in other discussions","text":"<p>You are also welcome to open or join discussions in other categories:</p> <ul> <li>Feature requests</li> <li>Design discussions</li> </ul>"},{"location":"support/support-guidelines/#additional-resources","title":"Additional resources","text":"<p>If you are unsure how to create a discussion, refer to the GitHub Docs on creating a new discussion.</p>"},{"location":"support/support-guidelines/#documentation-sites","title":"Documentation sites","text":"<p>Docs guide shows the list of useful documentation sites. Visit them and see if there is any information related to your problem.</p> <p>Note that the documentation sites aren't always up-to-date and perfect. If you find out that some information is wrong, unclear, or missing in Autoware docs, feel free to submit a pull request following the contribution guidelines.</p>"},{"location":"support/support-guidelines/#github-discussions","title":"GitHub Discussions","text":"<p>GitHub discussions page is the primary place for asking questions and discussing topics related to Autoware.</p> Category Description Announcements Official updates and news from the Autoware maintainers Design Discussions on Autoware system and software design Feature requests Suggestions for new features and improvements General General discussions about Autoware Ideas Brainstorming and sharing innovative ideas Polls Community polls and surveys Q&amp;A Questions and answers from the community and developers Show and tell Showcase of projects and achievements TSC meetings Minutes and discussions from TSC(Technical Steering Committee) meetings Working group activities Updates on working group activities Working group meetings Minutes and discussions from working group meetings <p>Warning</p> <p>GitHub Discussions is not the right place to track tasks or bugs. Use GitHub Issues for that purpose.</p>"},{"location":"support/support-guidelines/#github-issues","title":"GitHub Issues","text":"<p>GitHub Issues is the designated platform for tracking confirmed bugs, tasks, and enhancements within Autoware's various repositories.</p> <p>Follow these guidelines to ensure efficient issue tracking and resolution:</p>"},{"location":"support/support-guidelines/#reporting-bugs","title":"Reporting bugs","text":"<p>If you encounter a confirmed bug, please report it by creating an issue in the appropriate Autoware repository. Include detailed information such as steps to reproduce, expected outcomes, and actual results to assist maintainers in addressing the issue promptly.</p>"},{"location":"support/support-guidelines/#tracking-tasks","title":"Tracking tasks","text":"<p>GitHub Issues is also the place for managing tasks including:</p> <ul> <li>Refactoring: Propose refactoring existing code to improve efficiency, readability, or maintainability. Clearly describe what and why you propose to refactor.</li> <li>New Features: If you have confirmed the need for a new feature through discussions, use Issues to track its development. Outline the feature's purpose, potential designs, and its intended impact.</li> <li>Documentation: Propose changes to documentation to fix inaccuracies, update outdated content, or add new sections. Specify what changes are needed and why they are important.</li> </ul>"},{"location":"support/support-guidelines/#creating-an-issue","title":"Creating an issue","text":"<p>When creating a new issue, use the following guidelines:</p> <ol> <li>Choose the Correct Repository: If unsure which repository is appropriate, start a discussion in the Q&amp;A category to seek guidance from maintainers.</li> <li>Use Clear, Concise Titles: Clearly summarize the issue or task in the title for quick identification.</li> <li>Provide Detailed Descriptions: Include all necessary details to understand the context and scope of the issue. Attach screenshots, error logs, and code snippets where applicable.</li> <li>Tag Relevant Contributors: Mention contributors or teams that might be impacted by or interested in the issue.</li> </ol>"},{"location":"support/support-guidelines/#linking-issues-and-pull-requests","title":"Linking issues and pull requests","text":"<p>When you start working on an issue, link the related pull request to the issue by mentioning the issue number. This helps maintain a clear and traceable development history.</p> <p>For more details, see the Pull Request Guidelines page.</p> <p>Warning</p> <p>GitHub Issues is not for questions or unconfirmed bugs. If an issue is created for such purposes, it will likely be transferred to GitHub Discussions for further clarification.</p>"},{"location":"support/support-guidelines/#discord","title":"Discord","text":"<p>Autoware has a Discord server for casual communication between contributors.</p> <p>The Autoware Discord server is a good place for the following activities:</p> <ul> <li>Introduce yourself to the community.</li> <li>Chat with contributors.</li> <li>Take a quick straw poll.</li> </ul> <p>Note that it is not the right place to get help for your issues.</p>"},{"location":"support/support-guidelines/#ros-discourse","title":"ROS Discourse","text":"<p>If you want to widely discuss a topic with the general Autoware and ROS community or ask a question not related to Autoware's bugs, post to the Autoware category on ROS Discourse.</p> <p>Warning</p> <p>Do not post questions about bugs to ROS Discourse!</p>"},{"location":"support/troubleshooting/","title":"Troubleshooting","text":""},{"location":"support/troubleshooting/#troubleshooting","title":"Troubleshooting","text":""},{"location":"support/troubleshooting/#setup-issues","title":"Setup issues","text":""},{"location":"support/troubleshooting/#cuda-related-errors","title":"CUDA-related errors","text":"<p>When installing CUDA, errors may occur because of version conflicts. To resolve these types of errors, try one of the following methods:</p> <ul> <li> <p>Unhold all CUDA-related libraries and rerun the setup script.</p> <pre><code>sudo apt-mark unhold  \\\n\"cuda*\"             \\\n\"libcudnn*\"         \\\n\"libnvinfer*\"       \\\n\"libnvonnxparsers*\" \\\n\"libnvparsers*\"     \\\n\"tensorrt*\"         \\\n\"nvidia*\"\n\n./setup-dev-env.sh\n</code></pre> </li> </ul> <ul> <li> <p>Uninstall all CUDA-related libraries and rerun the setup script.</p> <pre><code>sudo apt purge        \\\n\"cuda*\"             \\\n\"libcudnn*\"         \\\n\"libnvinfer*\"       \\\n\"libnvonnxparsers*\" \\\n\"libnvparsers*\"     \\\n\"tensorrt*\"         \\\n\"nvidia*\"\n\nsudo apt autoremove\n\n./setup-dev-env.sh\n</code></pre> </li> </ul> <p>Warning</p> <p>Note that this may break your system and run carefully.</p> <ul> <li> <p>Run the setup script without installing CUDA-related libraries.</p> <pre><code>./setup-dev-env.sh --no-nvidia\n</code></pre> </li> </ul> <p>Warning</p> <p>Note that some components in Autoware Universe require CUDA, and only the CUDA version in the env file is supported at this time. Autoware may work with other CUDA versions, but those versions are not supported and functionality is not guaranteed.</p>"},{"location":"support/troubleshooting/#build-issues","title":"Build issues","text":""},{"location":"support/troubleshooting/#insufficient-memory","title":"Insufficient memory","text":"<p>Building Autoware requires a lot of memory, and your machine can freeze or crash if memory runs out during a build. To avoid this problem, 16-32GB of swap should be configured.</p> <pre><code># Optional: Check the current swapfile\nfree -h\n\n# Remove the current swapfile\nsudo swapoff /swapfile\nsudo rm /swapfile\n\n# Create a new swapfile\nsudo fallocate -l 32G /swapfile\nsudo chmod 600 /swapfile\nsudo mkswap /swapfile\nsudo swapon /swapfile\n\n# Optional: Check if the change is reflected\nfree -h\n</code></pre> <p>For more detailed configuration steps, along with an explanation of swap, refer to Digital Ocean's \"How To Add Swap Space on Ubuntu 20.04\" tutorial</p> <p>If there are too many CPU cores (more than 64) in your machine, it might requires larger memory. A workaround here is to limit the job number while building.</p> <pre><code>MAKEFLAGS=\"-j4\" colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>You can adjust <code>-j4</code> to any number based on your system. For more details, see the manual page of GNU make.</p> <p>By reducing the number of packages built in parallel, you can also reduce the amount of memory used. In the following example, the number of packages built in parallel is set to 1, and the number of jobs used by <code>make</code> is limited to 1.</p> <pre><code>MAKEFLAGS=\"-j1\" colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release --parallel-workers 1\n</code></pre> <p>Note</p> <p>By lowering both the number of packages built in parallel and the number of jobs used by <code>make</code>, you can reduce the memory usage. However, this also means that the build process takes longer.</p>"},{"location":"support/troubleshooting/#errors-when-using-the-latest-version-of-autoware","title":"Errors when using the latest version of Autoware","text":"<p>If you are working with the latest version of Autoware, issues can occur due to out-of-date software or old build files.</p> <p>To resolve these types of problems, first try cleaning your build artifacts and rebuilding:</p> <pre><code>rm -rf build/ install/ log/\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>If the error is not resolved, remove <code>src/</code> and update your workspace according to installation type (Docker / source).</p> <p>Warning</p> <p>Before removing <code>src/</code>, confirm that there are no modifications in your local environment that you want to keep!</p> <p>If errors still persist after trying the steps above, delete the entire workspace, clone the repository once again and restart the installation process.</p> <pre><code>rm -rf autoware/\ngit clone https://github.com/autowarefoundation/autoware.git\n</code></pre>"},{"location":"support/troubleshooting/#errors-when-using-a-fixed-version-of-autoware","title":"Errors when using a fixed version of Autoware","text":"<p>In principle, errors should not occur when using a fixed version. That said, possible causes include:</p> <ul> <li>ROS 2 has been updated with breaking changes.<ul> <li>For confirmation, check the Packaging and Release Management tag on ROS Discourse.</li> </ul> </li> <li>Your local environment is broken.<ul> <li>Confirm your <code>.bashrc</code> file, environment variables, and library versions.</li> </ul> </li> </ul> <p>In addition to the causes listed above, there are two common misunderstandings around the use of fixed versions.</p> <ol> <li> <p>You used a fixed version for <code>autowarefoundation/autoware</code> only.    All of the repository versions in the <code>.repos</code> file must be specified in order to use a completely fixed version.</p> </li> <li> <p>You didn't update the workspace after changing the branch of <code>autowarefoundation/autoware</code>.    Changing the branch of <code>autowarefoundation/autoware</code> does not affect the files under <code>src/</code>. You have to run the <code>vcs import</code> command to update them.</p> </li> </ol>"},{"location":"support/troubleshooting/#error-when-building-python-package","title":"Error when building python package","text":"<p>During building the following issue can occurs</p> <pre><code>pkg_resources.extern.packaging.version.InvalidVersion: Invalid version: '0.23ubuntu1'\n</code></pre> <p>The error is due to the fact that for versions between 66.0.0 and 67.5.0 <code>setuptools</code> enforces the python packages to be PEP-440 conformant. Since version 67.5.1 <code>setuptools</code> has a fallback that makes it possible to work with old packages again.</p> <p>The solution is to update <code>setuptools</code> to the newest version with the following command</p> <pre><code>pip install --upgrade setuptools\n</code></pre>"},{"location":"support/troubleshooting/#dockerrocker-issues","title":"Docker/rocker issues","text":"<p>If any errors occur when running Autoware with Docker or rocker, first confirm that your Docker installation is working correctly by running the following commands:</p> <pre><code>docker run --rm -it hello-world\ndocker run --rm -it ubuntu:latest\n</code></pre> <p>Next, confirm that you are able to access the base Autoware image that is stored on the GitHub Packages website</p> <pre><code>docker run --rm -it ghcr.io/autowarefoundation/autoware-universe:latest\n</code></pre>"},{"location":"support/troubleshooting/#runtime-issues","title":"Runtime issues","text":""},{"location":"support/troubleshooting/#performance-related-issues","title":"Performance related issues","text":"<p>Symptoms:</p> <ul> <li>Autoware is running slower than expected</li> <li>Messages show up late in RViz2</li> <li>Point clouds are lagging</li> <li>Camera images are lagging behind</li> <li>Point clouds or markers flicker on RViz2</li> <li>When multiple subscribers use the same publishers, the message rate drops</li> </ul> <p>If you have any of these symptoms, please the Performance Troubleshooting page.</p>"},{"location":"support/troubleshooting/#map-does-not-display-when-running-the-planning-simulator","title":"Map does not display when running the Planning Simulator","text":"<p>When running the Planning Simulator, the most common reason for the map not being displayed in RViz is because the map path has not been specified correctly in the launch command. You can confirm if this is the case by searching for <code>Could not find lanelet map under {path-to-map-dir}/lanelet2_map.osm</code> errors in the log.</p> <p>Another possible reason is that map loading is taking a long time due to poor DDS performance. For this, please visit the Performance Troubleshooting page.</p>"},{"location":"support/troubleshooting/#died-process-issues","title":"Died process issues","text":"<p>Some modules may not be launched properly at runtime, and you may see \"process has died\" in your terminal. You can use the gdb tool to locate where the problem is occurring.</p> <p>Debug build the module you wish to analyze under your autoware workspace</p> <pre><code>colcon build --cmake-args -DCMAKE_BUILD_TYPE=Debug --packages-up-to &lt;the modules you wish to analyze&gt; --catkin-skip-building-tests --symlink-install\n</code></pre> <p>In this state, when a died process occurs when you run the autoware again, a core file will be created. Remeber to remove the size limit of the core file.</p> <pre><code>ulimit -c unlimited\n</code></pre> <p>Rename the core file as <code>core.&lt;PID&gt;</code>.</p> <pre><code>echo core | sudo tee /proc/sys/kernel/core_pattern\necho -n 1 | sudo tee /proc/sys/kernel/core_uses_pid\n</code></pre> <p>Launch the autoware again. When a died process occurs, a core file will be created. <code>ll -ht</code> helps you to check if it was created.</p> <p>Invoke gdb tool.</p> <pre><code>gdb &lt;executable file&gt; &lt;core file&gt;\n#You can find the `&lt;executable file&gt;` in the error message.\n</code></pre> <p><code>bt</code> backtraces the stack of callbacks where a process dies. <code>f &lt;frame number&gt;</code> shows you the detail of a frame, and <code>l</code> shows you the code.</p>"},{"location":"support/troubleshooting/performance-troubleshooting/","title":"Performance Troubleshooting","text":""},{"location":"support/troubleshooting/performance-troubleshooting/#performance-troubleshooting","title":"Performance Troubleshooting","text":"<p>Overall symptoms:</p> <ul> <li>Autoware is running slower than expected</li> <li>Messages show up late in RViz2</li> <li>Point clouds are lagging</li> <li>Camera images are lagging behind</li> <li>Point clouds or markers flicker on RViz2</li> <li>When multiple subscribers use the same publishers, the message rate drops</li> </ul>"},{"location":"support/troubleshooting/performance-troubleshooting/#diagnostic-steps","title":"Diagnostic Steps","text":""},{"location":"support/troubleshooting/performance-troubleshooting/#check-if-multicast-is-enabled","title":"Check if multicast is enabled","text":""},{"location":"support/troubleshooting/performance-troubleshooting/#target-symptoms","title":"Target symptoms","text":"<ul> <li>When multiple subscribers use the same publishers, the message rate drops</li> </ul>"},{"location":"support/troubleshooting/performance-troubleshooting/#diagnosis","title":"Diagnosis","text":"<p>Make sure that the multicast is enabled for your interface.</p> <p>For example when you run following:</p> <pre><code>source /opt/ros/humble/setup.bash\nros2 run demo_nodes_cpp talker\n</code></pre> <p>If you get the error message <code>selected interface \"{your-interface-name}\" is not multicast-capable: disabling multicast</code>, this should be fixed.</p>"},{"location":"support/troubleshooting/performance-troubleshooting/#solution","title":"Solution","text":"<p>Follow DDS settings for ROS 2 and Autoware</p> <p>Especially the Enable <code>multicast</code> on <code>lo</code> section.</p>"},{"location":"support/troubleshooting/performance-troubleshooting/#check-the-compilation-flags","title":"Check the compilation flags","text":""},{"location":"support/troubleshooting/performance-troubleshooting/#target-symptoms_1","title":"Target symptoms","text":"<ul> <li>Autoware is running slower than expected</li> <li>Point clouds are lagging</li> <li>When multiple subscribers use the same publishers, the message rate drops even further</li> </ul>"},{"location":"support/troubleshooting/performance-troubleshooting/#diagnosis_1","title":"Diagnosis","text":"<p>Check the <code>~/.bash_history</code> file to see if there are any <code>colcon build</code> directives without <code>-DCMAKE_BUILD_TYPE=Release</code> or <code>-DCMAKE_BUILD_TYPE=RelWithDebInfo</code> flags at all.</p> <p>Even if a build starts with these flags but same workspace gets compiled without these flags, it will still be a slow build in the end.</p> <p>In addition, the nodes will run slow in general, especially the <code>pointcloud_preprocessor</code> nodes.</p> <p>Example issue: issue2597</p>"},{"location":"support/troubleshooting/performance-troubleshooting/#solution_1","title":"Solution","text":"<ul> <li>Remove the <code>build</code>, <code>install</code> and optionally <code>log</code> folders in the main <code>autoware</code> folder.</li> <li> <p>Compile the Autoware with either <code>Release</code> or <code>RelWithDebInfo</code> tags:</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n# Or build with debug flags too (comparable performance but you can debug too)\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo\n</code></pre> </li> </ul>"},{"location":"support/troubleshooting/performance-troubleshooting/#check-the-dds-settings","title":"Check the DDS settings","text":""},{"location":"support/troubleshooting/performance-troubleshooting/#target-symptoms_2","title":"Target symptoms","text":"<ul> <li>Autoware is running slower than expected</li> <li>Messages show up late in RViz2</li> <li>Point clouds are lagging</li> <li>Camera images are lagging behind</li> <li>When multiple subscribers use the same publishers, the message rate drops</li> </ul>"},{"location":"support/troubleshooting/performance-troubleshooting/#check-the-rmw-ros-middleware-implementation","title":"Check the RMW (ROS Middleware) implementation","text":""},{"location":"support/troubleshooting/performance-troubleshooting/#diagnosis_2","title":"Diagnosis","text":"<p>Run following to check the middleware used:</p> <pre><code>echo $RMW_IMPLEMENTATION\n</code></pre> <p>The return line should be <code>rmw_cyclonedds_cpp</code>. If not, apply the solution.</p> <p>If you are using a different DDS middleware, we might not have official support for it just yet.</p>"},{"location":"support/troubleshooting/performance-troubleshooting/#solution_2","title":"Solution","text":"<p>Add <code>export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp</code> as a separate line in you <code>~/.bashrc</code> file.</p> <p>More details in: CycloneDDS Configuration</p>"},{"location":"support/troubleshooting/performance-troubleshooting/#check-if-the-cyclonedds-is-configured-correctly","title":"Check if the CycloneDDS is configured correctly","text":""},{"location":"support/troubleshooting/performance-troubleshooting/#diagnosis_3","title":"Diagnosis","text":"<p>Run following to check the configuration <code>.xml</code> file of the <code>CycloneDDS</code>:</p> <pre><code>echo $CYCLONEDDS_URI\n</code></pre> <p>The return line should be a valid path pointing to an <code>.xml</code> file with <code>CycloneDDS</code> configuration.</p> <p>Also check if the file is configured correctly:</p> <pre><code>cat ${CYCLONEDDS_URI#file://}\n</code></pre> <p>This should print the <code>.xml</code> file on the terminal.</p>"},{"location":"support/troubleshooting/performance-troubleshooting/#solution_3","title":"Solution","text":"<p>Follow CycloneDDS Configuration and make sure:</p> <ul> <li>you have <code>export CYCLONEDDS_URI=file:///absolute_path_to_your/cyclonedds.xml</code> as a line on your <code>~/.bashrc</code> file.</li> <li>you have the <code>cyclonedds.xml</code> with the configuration provided in the documentation.</li> </ul>"},{"location":"support/troubleshooting/performance-troubleshooting/#check-the-linux-kernel-maximum-buffer-size","title":"Check the Linux kernel maximum buffer size","text":""},{"location":"support/troubleshooting/performance-troubleshooting/#diagnosis_4","title":"Diagnosis","text":"<p>Validate the sysctl settings</p>"},{"location":"support/troubleshooting/performance-troubleshooting/#solution_4","title":"Solution","text":"<p>Tune system-wide network settings</p>"},{"location":"support/troubleshooting/performance-troubleshooting/#check-if-localhost-only-communication-for-dds-is-enabled","title":"Check if localhost only communication for DDS is enabled","text":"<ul> <li>If you are using multi computer setup, please skip this check.</li> <li>Enabling localhost only communication for DDS can help improve the performance of ROS by reducing network traffic and avoiding potential conflicts with other devices on the network.</li> </ul>"},{"location":"support/troubleshooting/performance-troubleshooting/#target-symptoms_3","title":"Target symptoms","text":"<ul> <li>You see topics that shouldn't exist</li> <li>You see point clouds that don't belong to your machine<ul> <li>They might be from another computer running ROS 2 on your network</li> </ul> </li> <li>Point clouds or markers flicker on RViz2<ul> <li>Another publisher (on another machine) may be publishing on the same topic as your node does.</li> <li>Causing the flickering.</li> </ul> </li> </ul>"},{"location":"support/troubleshooting/performance-troubleshooting/#diagnosis_5","title":"Diagnosis","text":"<p>Run:</p> <pre><code>cat ${CYCLONEDDS_URI#file://}\n</code></pre> <p>And it should return DDS settings for ROS 2 and Autoware: CycloneDDS Configuration this file.</p>"},{"location":"support/troubleshooting/performance-troubleshooting/#solution_5","title":"Solution","text":"<p>Follow DDS settings for ROS 2 and Autoware: Enable localhost-only communication.</p> <p>Also make sure the following returns an empty line:</p> <pre><code>echo $ROS_LOCALHOST_ONLY\n</code></pre>"},{"location":"tutorials/","title":"Simulation tutorials","text":""},{"location":"tutorials/#simulation-tutorials","title":"Simulation tutorials","text":"<p>Simulations provide a way of verifying Autoware's functionality before field testing with an actual vehicle. There are three main types of simulation that can be run ad hoc or via a scenario runner.</p>"},{"location":"tutorials/#simulation-methods","title":"Simulation methods","text":""},{"location":"tutorials/#ad-hoc-simulation","title":"Ad hoc simulation","text":"<p>Ad hoc simulation is a flexible method for running basic simulations on your local machine, and is the recommended method for anyone new to Autoware.</p>"},{"location":"tutorials/#scenario-simulation","title":"Scenario simulation","text":"<p>Scenario simulation uses a scenario runner to run more complex simulations based on predefined scenarios. It is often run automatically for continuous integration purposes, but can also be run on a local machine.</p>"},{"location":"tutorials/#simulation-types","title":"Simulation types","text":""},{"location":"tutorials/#planning-simulation","title":"Planning simulation","text":"<p>Planning simulation uses simple dummy data to test the Planning and Control components - specifically path generation, path following and obstacle avoidance. It verifies that a vehicle can reach a goal destination while avoiding pedestrians and surrounding cars, and is another method for verifying the validity of Lanelet2 maps. It also allows for testing of traffic light handling.</p>"},{"location":"tutorials/#how-does-planning-simulation-work","title":"How does planning simulation work?","text":"<ol> <li>Generate a path to the goal destination</li> <li>Control the car along the generated path</li> <li>Detect and avoid any humans or other vehicles on the way to the goal destination</li> </ol>"},{"location":"tutorials/#rosbag-replay-simulation","title":"Rosbag replay simulation","text":"<p>Rosbag replay simulation uses prerecorded rosbag data to test the following aspects of the Localization and Perception components:</p> <ul> <li>Localization: Estimation of the vehicle's location on the map by matching sensor and vehicle feedback data to the map.</li> <li>Perception: Using sensor data to detect, track and predict dynamic objects such as surrounding cars, pedestrians, and other objects</li> </ul> <p>By repeatedly playing back the data, this simulation type can also be used for endurance testing.</p>"},{"location":"tutorials/#digital-twin-simulation","title":"Digital twin simulation","text":"<p>Digital twin simulation is a simulation type that is able to produce realistic data and simulate almost the entire system. It is also commonly referred to as end-to-end simulation.</p>"},{"location":"tutorials/ad-hoc-simulation/","title":"Ad hoc simulation","text":""},{"location":"tutorials/ad-hoc-simulation/#ad-hoc-simulation","title":"Ad hoc simulation","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/","title":"Planning simulation","text":""},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#planning-simulation","title":"Planning simulation","text":""},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#preparation","title":"Preparation","text":"<p>Download and unpack a sample map.</p> <ul> <li>You can also download the map manually.</li> </ul> <pre><code>gdown -O ~/autoware_map/ 'https://docs.google.com/uc?export=download&amp;id=1499_nsbUbIeturZaDj7jhUownh5fvXHd'\nunzip -d ~/autoware_map ~/autoware_map/sample-map-planning.zip\n</code></pre> <p>Note</p> <p>Sample map: Copyright 2020 TIER IV, Inc.</p> <p>Check if you have <code>~/autoware_data</code> folder and files in it.</p> <pre><code>$ cd ~/autoware_data\n$ ls -C -w 30\nimage_projection_based_fusion\nlidar_apollo_instance_segmentation\nlidar_centerpoint\ntensorrt_yolo\ntensorrt_yolox\ntraffic_light_classifier\ntraffic_light_fine_detector\ntraffic_light_ssd_fine_detector\nyabloc_pose_initializer\n</code></pre> <p>If not, please, follow Manual downloading of artifacts.</p> <p>Change the maximum velocity, that is 15km/h by default.</p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#basic-simulations","title":"Basic simulations","text":"<p>Using Autoware Launch GUI</p> <p>If you prefer a graphical user interface (GUI) over the command line for launching and managing your simulations, refer to the <code>Using Autoware Launch GUI</code> section at the end of this document for a step-by-step guide.</p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#lane-driving-scenario","title":"Lane driving scenario","text":""},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#1-launch-autoware","title":"1. Launch Autoware","text":"<pre><code>source ~/autoware/install/setup.bash\nros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/autoware_map/sample-map-planning vehicle_model:=sample_vehicle sensor_model:=sample_sensor_kit\n</code></pre> <p>Warning</p> <p>Note that you cannot use <code>~</code> instead of <code>$HOME</code> here.</p> <p>If <code>~</code> is used, the map will fail to load.</p> <p></p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#2-set-an-initial-pose-for-the-ego-vehicle","title":"2. Set an initial pose for the ego vehicle","text":"<p>a) Click the <code>2D Pose estimate</code> button in the toolbar, or hit the <code>P</code> key.</p> <p>b) In the 3D View pane, click and hold the left-mouse button, and then drag to set the direction for the initial pose. An image representing the vehicle should now be displayed.</p> <p>Warning</p> <p>Remember to set the initial pose of the car in the same direction as the lane.</p> <p>To confirm the direction of the lane, check the arrowheads displayed on the map.</p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#3-set-a-goal-pose-for-the-ego-vehicle","title":"3. Set a goal pose for the ego vehicle","text":"<p>a) Click the <code>2D Goal Pose</code> button in the toolbar, or hit the <code>G</code> key.</p> <p>b) In the 3D View pane, click and hold the left-mouse button, and then drag to set the direction for the goal pose. If done correctly, you will see a planned path from initial pose to goal pose.</p> <p></p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#4-start-the-ego-vehicle","title":"4. Start the ego vehicle","text":"<p>Now you can start the ego vehicle driving by clicking the <code>AUTO</code> button on <code>OperationMode</code> in <code>AutowareStatePanel</code>. Alteratively, you can manually start the vehicle by running the following command:</p> <pre><code>source ~/autoware/install/setup.bash\nros2 service call /api/operation_mode/change_to_autonomous autoware_adapi_v1_msgs/srv/ChangeOperationMode {}\n</code></pre> <p>After that, you can see <code>AUTONOMOUS</code> sign on <code>OperationMode</code> and <code>AUTO</code> button is grayed out.</p> <p></p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#parking-scenario","title":"Parking scenario","text":"<ol> <li> <p>Set an initial pose and a goal pose, and engage the ego vehicle.</p> <p></p> </li> <li> <p>When the vehicle approaches the goal, it will switch from lane driving mode to parking mode.</p> </li> <li> <p>After that, the vehicle will reverse into the destination parking spot.</p> <p></p> </li> </ol>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#pull-out-and-pull-over-scenario","title":"Pull out and pull over scenario","text":"<ol> <li> <p>In a pull out scenario, set the ego vehicle at the road shoulder.</p> <p></p> </li> <li> <p>Set a goal and then engage the ego vehicle.</p> </li> <li> <p>In a pull over scenario, similarly set the ego vehicle in a lane and set a goal on the road shoulder.</p> </li> </ol>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#lane-change-scenario","title":"Lane change scenario","text":"<ol> <li> <p>Download and unpack Nishishinjuku map.</p> <pre><code>gdown -O ~/autoware_map/ 'https://github.com/tier4/AWSIM/releases/download/v1.1.0/nishishinjuku_autoware_map.zip'\nunzip -d ~/autoware_map ~/autoware_map/nishishinjuku_autoware_map.zip\n</code></pre> </li> <li> <p>Launch autoware with Nishishinjuku map with following command:</p> <pre><code>source ~/autoware/install/setup.bash\nros2 launch autoware_launch planning_simulator.launch.xml map_path:=$HOME/autoware_map/nishishinjuku_autoware_map vehicle_model:=sample_vehicle sensor_model:=sample_sensor_kit\n</code></pre> <p></p> </li> <li> <p>Set an initial pose and a goal pose in adjacent lanes.</p> <p></p> </li> <li> <p>Engage the ego vehicle. It will make a lane change along the planned path.</p> <p></p> </li> </ol>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#avoidance-scenario","title":"Avoidance scenario","text":"<ol> <li> <p>Set an initial pose and a goal pose in the same lane. A path will be planned.</p> <p></p> </li> <li> <p>Set a \"2D Dummy Bus\" on the roadside. A new path will be planned.</p> <p></p> </li> <li> <p>Engage the ego vehicle. It will avoid the obstacle along the newly planned path.</p> </li> </ol>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#advanced-simulations","title":"Advanced Simulations","text":""},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#placing-dummy-objects","title":"Placing dummy objects","text":"<ol> <li>Click the <code>2D Dummy Car</code> or <code>2D Dummy Pedestrian</code> button in the toolbar.</li> <li>Set the pose of the dummy object by clicking and dragging on the map.</li> <li> <p>Set the velocity of the object in <code>Tool Properties -&gt; 2D Dummy Car/Pedestrian</code> panel.</p> <p>!!! note</p> <p>Changes to the <code>velocity</code> parameter will only affect objects placed after the parameter is changed.</p> <p></p> </li> <li> <p>Delete any dummy objects placed in the view by clicking the <code>Delete All Objects</code> button in the toolbar.</p> </li> <li> <p>Click the <code>Interactive</code> button in the toolbar to make the dummy object interactive.</p> <p></p> </li> <li> <p>For adding an interactive dummy object, press <code>SHIFT</code> and click the <code>right click</code>.</p> </li> <li>For deleting an interactive dummy object, press <code>ALT</code> and click the <code>right click</code>.</li> <li> <p>For moving an interactive dummy object, hold the <code>right click</code> drag and drop the object.</p> <p></p> </li> </ol>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#traffic-light-recognition-simulation","title":"Traffic light recognition simulation","text":"<p>By default, traffic lights on the map are all treated as if they are set to green. As a result, when a path is created that passed through an intersection with a traffic light, the ego vehicle will drive through the intersection without stopping.</p> <p>The following steps explain how to set and reset traffic lights in order to test how the Planning component will respond.</p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#set-traffic-light","title":"Set traffic light","text":"<ol> <li> <p>Go to <code>Panels -&gt; Add new panel</code>, select <code>TrafficLightPublishPanel</code>, and then press <code>OK</code>.</p> </li> <li> <p>In <code>TrafficLightPublishPanel</code>, set the <code>ID</code> and color of the traffic light.</p> </li> <li> <p>Click the <code>SET</code> button.    </p> </li> <li> <p>Finally, click the <code>PUBLISH</code> button to send the traffic light status to the simulator. Any planned path that goes past the selected traffic light will then change accordingly.</p> </li> </ol> <p></p> <p>By default, Rviz should display the ID of each traffic light on the map. You can have a closer look at the IDs by zooming in the region or by changing the View type.</p> <p>In case the IDs are not displayed, try the following troubleshooting steps:</p> <p>a) In the <code>Displays</code> panel, find the <code>traffic_light_id</code> topic by toggling the triangle icons next to <code>Map &gt; Lanelet2VectorMap &gt; Namespaces</code>.</p> <p>b) Check the <code>traffic_light_id</code> checkbox.</p> <p>c) Reload the topic by clicking the <code>Map</code> checkbox twice.</p> <p></p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#updatereset-traffic-light","title":"Update/Reset traffic light","text":"<p>You can update the color of the traffic light by selecting the next color (in the image it is <code>GREEN</code>) and clicking <code>SET</code> button. In the image the traffic light in front of the ego vehicle changed from <code>RED</code> to <code>GREEN</code> and the vehicle restarted.</p> <p></p> <p>To remove a traffic light from <code>TrafficLightPublishPanel</code>, click the <code>RESET</code> button.</p> <p>Reference video tutorials</p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#using-autoware-launch-gui","title":"Using Autoware Launch GUI","text":"<p>This section provides a step-by-step guide on using the Autoware Launch GUI for planning simulations, offering an alternative to the command-line instructions provided in the Basic simulations section.</p>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#getting-started-with-autoware-launch-gui","title":"Getting Started with Autoware Launch GUI","text":"<ol> <li> <p>Installation: Ensure you have installed the Autoware Launch GUI. Installation instructions.</p> </li> <li> <p>Launching the GUI: Open the Autoware Launch GUI from your applications menu.</p> <p></p> </li> </ol>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#launching-a-planning-simulation","title":"Launching a Planning Simulation","text":""},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#lane-driving-scenario_1","title":"Lane Driving Scenario","text":"<ol> <li> <p>Set Autoware Path: In the GUI, set the path to your Autoware installation.</p> <p></p> </li> <li> <p>Select Launch File: Choose <code>planning_simulator.launch.xml</code> for the lane driving scenario.</p> <p></p> </li> <li> <p>Customize Parameters: Adjust parameters such as <code>map_path</code>, <code>vehicle_model</code>, and <code>sensor_model</code> as needed.</p> <p> </p> </li> <li> <p>Start Simulation: Click the launch button to start the simulation.</p> <p></p> </li> <li> <p>Any Scenario: From here, you can follow the instructions in the</p> </li> </ol> <ul> <li>Lane driving scenario: Lane Driving Scenario</li> <li>Parking scenario: Parking scenario</li> <li>Lane change scenario: Lane change scenario</li> <li>Avoidance scenario: Avoidance scenario</li> <li>Advanced Simulations: Advanced Simulations</li> </ul>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#monitoring-and-managing-the-simulation","title":"Monitoring and Managing the Simulation","text":"<ul> <li>Real-Time Monitoring: Use the GUI to monitor CPU/Memory usage and Autoware logs in real-time.</li> <li>Profile Management: Save your simulation profiles for quick access in future simulations.</li> <li>Adjusting Parameters: Easily modify simulation parameters on-the-fly through the GUI.</li> </ul>"},{"location":"tutorials/ad-hoc-simulation/planning-simulation/#want-to-try-autoware-with-your-custom-map","title":"Want to Try Autoware with Your Custom Map?","text":"<p>The above content describes the process for conducting some operations in the planning simulator using a sample map. If you are interested in running Autoware with maps of your own environment, please visit the How to Create Vector Map section for guidance.</p> <p></p>"},{"location":"tutorials/ad-hoc-simulation/rosbag-replay-simulation/","title":"Rosbag replay simulation","text":""},{"location":"tutorials/ad-hoc-simulation/rosbag-replay-simulation/#rosbag-replay-simulation","title":"Rosbag replay simulation","text":""},{"location":"tutorials/ad-hoc-simulation/rosbag-replay-simulation/#steps","title":"Steps","text":"<ol> <li> <p>Download and unpack a sample map.</p> <ul> <li>You can also download the map manually.</li> </ul> <pre><code>gdown -O ~/autoware_map/ 'https://docs.google.com/uc?export=download&amp;id=1A-8BvYRX3DhSzkAnOcGWFw5T30xTlwZI'\nunzip -d ~/autoware_map/ ~/autoware_map/sample-map-rosbag.zip\n</code></pre> </li> <li> <p>Download the sample rosbag files.</p> <ul> <li>You can also download the rosbag files manually.</li> </ul> <pre><code>gdown -O ~/autoware_map/ 'https://docs.google.com/uc?export=download&amp;id=1sU5wbxlXAfHIksuHjP3PyI2UVED8lZkP'\nunzip -d ~/autoware_map/ ~/autoware_map/sample-rosbag.zip\n</code></pre> </li> <li> <p>Check if you have <code>~/autoware_data</code> folder and files in it.</p> <pre><code>$ cd ~/autoware_data\n$ ls -C -w 30\nimage_projection_based_fusion\nlidar_apollo_instance_segmentation\nlidar_centerpoint\ntensorrt_yolo\ntensorrt_yolox\ntraffic_light_classifier\ntraffic_light_fine_detector\ntraffic_light_ssd_fine_detector\nyabloc_pose_initializer\n</code></pre> <p>If not, please, follow Manual downloading of artifacts.</p> </li> </ol>"},{"location":"tutorials/ad-hoc-simulation/rosbag-replay-simulation/#note","title":"Note","text":"<ul> <li>Sample map and rosbag: Copyright 2020 TIER IV, Inc.</li> <li>Due to privacy concerns, the rosbag does not contain image data, which will cause:<ul> <li>Traffic light recognition functionality cannot be tested with this sample rosbag.</li> <li>Object detection accuracy is decreased.</li> </ul> </li> </ul>"},{"location":"tutorials/ad-hoc-simulation/rosbag-replay-simulation/#how-to-run-a-rosbag-replay-simulation","title":"How to run a rosbag replay simulation","text":"<p>Using Autoware Launch GUI</p> <p>If you prefer a graphical user interface (GUI) over the command line for launching and managing your simulations, refer to the <code>Using Autoware Launch GUI</code> section at the end of this document for a step-by-step guide.</p> <ol> <li> <p>Launch Autoware.</p> <pre><code>source ~/autoware/install/setup.bash\nros2 launch autoware_launch logging_simulator.launch.xml map_path:=$HOME/autoware_map/sample-map-rosbag vehicle_model:=sample_vehicle sensor_model:=sample_sensor_kit\n</code></pre> <p>Note that you cannot use <code>~</code> instead of <code>$HOME</code> here.</p> <p></p> <p>\u26a0\ufe0f You might encounter error and warning messages in the terminal before playing the <code>rosbag</code>. This is normal behavior. These should cease once the <code>rosbag</code> is played and proper initialization takes place</p> </li> <li> <p>Play the sample rosbag file.</p> <pre><code>source ~/autoware/install/setup.bash\nros2 bag play ~/autoware_map/sample-rosbag/ -r 0.2 -s sqlite3\n</code></pre> <p>\u26a0\ufe0f Due to the discrepancy between the timestamp in the <code>rosbag</code> and the current system timestamp, Autoware may generate warning messages in the terminal alerting to this mismatch. This is normal behavior.</p> <p></p> </li> <li> <p>To focus the view on the ego vehicle, change the <code>Target Frame</code> in the RViz Views panel from <code>viewer</code> to <code>base_link</code>.</p> <p></p> </li> <li> <p>To switch the view to <code>Third Person Follower</code> etc, change the <code>Type</code> in the RViz Views panel.</p> <p></p> </li> </ol> <p>Reference video tutorials</p>"},{"location":"tutorials/ad-hoc-simulation/rosbag-replay-simulation/#using-autoware-launch-gui","title":"Using Autoware Launch GUI","text":"<p>This section provides a step-by-step guide for using the Autoware Launch GUI to launch and manage your rosbag replay simulation. offering an alternative to the command-line instructions provided in the previous section.</p>"},{"location":"tutorials/ad-hoc-simulation/rosbag-replay-simulation/#getting-started-with-autoware-launch-gui","title":"Getting Started with Autoware Launch GUI","text":"<ol> <li> <p>Installation: Ensure you have installed the Autoware Launch GUI. Installation instructions.</p> </li> <li> <p>Launching the GUI: Open the Autoware Launch GUI from your applications menu.    </p> </li> </ol>"},{"location":"tutorials/ad-hoc-simulation/rosbag-replay-simulation/#launching-a-logging-simulation","title":"Launching a Logging Simulation","text":"<ol> <li>Set Autoware Path: In the GUI, set the path to your Autoware installation.    </li> <li>Select Launch File: Choose <code>logging_simulator.launch.xml</code> for the lane driving scenario.    </li> <li> <p>Customize Parameters: Adjust parameters such as <code>map_path</code>, <code>vehicle_model</code>, and <code>sensor_model</code> as needed.</p> <p> </p> </li> <li> <p>Start Simulation: Click the launch button to start the simulation and have access to all the logs.</p> <p></p> </li> <li> <p>Play Rosbag: Move to the <code>Rosbag</code> tab and select the rosbag file you wish to play.</p> <p></p> </li> <li> <p>Adjust Playback Speed: Adjust the playback speed as needed and any other parameters you wish to customize.</p> <p></p> </li> <li> <p>Start Playback: Click the play button to start the rosbag playback and have access to settings such as <code>pause/play</code>, <code>stop</code>, and <code>speed slider</code>5.</p> <p></p> </li> <li> <p>View Simulation: Move to the <code>RViz</code> window to view the simulation.</p> <p></p> </li> <li> <p>To focus the view on the ego vehicle, change the <code>Target Frame</code> in the RViz Views panel from <code>viewer</code> to <code>base_link</code>.</p> <p></p> </li> <li> <p>To switch the view to <code>Third Person Follower</code> etc, change the <code>Type</code> in the RViz Views panel.</p> <p></p> </li> </ol>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/MORAI_Sim-tutorial/","title":"MORAI Sim: Drive","text":""},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/MORAI_Sim-tutorial/#morai-sim-drive","title":"MORAI Sim: Drive","text":"<p>Note</p> <p>Any kind of for-profit activity with the trial version of the MORAI SIM:Drive is strictly prohibited.</p>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/MORAI_Sim-tutorial/#hardware-requirements","title":"Hardware requirements","text":"Minimum PC Specs OS Windows 10, Ubuntu 20.04, Ubuntu 18.04, Ubuntu 16.04 CPU Intel i5-9600KF or AMD Ryzen 5 3500X RAM DDR4 16GB GPU RTX2060 Super Required PC Specs OS Windows 10, Ubuntu 20.04, Ubuntu 18.04, Ubuntu 16.04 CPU Intel i9-9900K or AMD Ryzen 7 3700X (or higher) RAM DDR4 64GB (or higher) GPU RTX2080Ti or higher"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/MORAI_Sim-tutorial/#application-and-download","title":"Application and Download","text":"<p>Only for AWF developers, trial license for 3 months can be issued. Download the application form and send to Hyeongseok Jeon</p> <p>After the trial license is issued, you can login to MORAI Sim:Drive via Launchers (Windows/Ubuntu)</p> <p>CAUTION: Do not use the Launchers in the following manual</p>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/MORAI_Sim-tutorial/#technical-documents","title":"Technical Documents","text":"<p>as Oct. 2022, our simulation version is ver.22.R3 but the english manual is under construction.</p> <p>Be aware that the following manuals are for ver.22.R2</p> <ul> <li>MORAI Sim:Drive Manual</li> <li>ITRI BUS Odd tutorial</li> <li>Tutorial for rosbag replay with Tacoma Airport</li> </ul>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/MORAI_Sim-tutorial/#technical-support","title":"Technical Support","text":"<p>Hyeongseok Jeon will give full technical support</p> <ul> <li>hsjeon@morai.ai</li> <li>Hyeongseok Jeon#2355 in Discord</li> </ul>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/awsim-tutorial/","title":"AWSIM simulator","text":""},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/awsim-tutorial/#awsim-simulator","title":"AWSIM simulator","text":"<p>AWSIM is a simulator for Autoware development and testing, initially developed by TIER IV and still actively maintained.</p> <p>AWSIM Labs is a fork of AWSIM, developed under the Autoware Foundation, providing additional features and lighter resource usage.</p>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/awsim-tutorial/#feature-differences-from-the-awsim-and-awsim-labs","title":"Feature differences from the AWSIM and AWSIM Labs","text":"Simulator Features AWSIM 1.2.1 AWSIM Labs 1.0.0 Rendering Pipeline HDRP URP Resource usage Heavy Light Can reset vehicle position on runtime \u274c \u2705 Multiple scene and vehicle setup \u274c \u2705 Multi-lidars are enabled by default \u274c \u2705 Radar sensor support \u2705 \u274c Can toggle vehicle keyboard control from GUI \u2705 \u274c Development Features AWSIM AWSIM Labs Unity Version Unity 2021.1.7f1 Unity LTS 2022.3.21f1 CI for build \u274c \u2705 CI for documentation generation within PR \u274c \u2705 Main branch is protected with linear history \u274c \u2705"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/awsim-tutorial/#awsim-labs","title":"AWSIM Labs","text":"<p>AWSIM Labs supports Unity LTS 2022.3.21f1 and uses the Universal Render Pipeline (URP), optimized for lighter resource usage. It introduces several enhancements such as the ability to reset vehicle positions at runtime, support for multiple scenes and vehicle setups on runtime, and multi-lidars enabled by default.</p> <p>To get started with AWSIM Labs, please follow the instructions.</p>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/awsim-tutorial/#awsim","title":"AWSIM","text":"<p>AWSIM runs on Unity 2021.1.7f1 using the High Definition Render Pipeline (HDRP), which requires more system resources.</p> <p>To get started with AWSIM, please follow the instructions provided by TIER IV.</p>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/carla-tutorial/","title":"CARLA simulator","text":""},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/carla-tutorial/#carla-simulator","title":"CARLA simulator","text":"<p>CARLA is a famous open-source simulator for the autonomous driving research. Now there is no official support to Autoware.universe, but some projects from communities support it. The document is to list these projects for anyone who wants to run Autoware with Carla. You can report issues to each project if there is any problem.</p>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/carla-tutorial/#project-lists-in-alphabetical-order","title":"Project lists (In alphabetical order)","text":""},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/carla-tutorial/#carla_autoware_bridge","title":"carla_autoware_bridge","text":"<p>An addition package to <code>carla_ros_bridge</code> to connect CARLA simulator to Autoware Universe software.</p> <ul> <li>Project Link: carla_autoware_bridge</li> <li>Tutorial: https://github.com/Robotics010/carla_autoware_bridge/blob/master/getting-started.md</li> </ul>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/carla-tutorial/#open_planner","title":"open_planner","text":"<p>Integrated open source planner and related tools for autonomous navigation of autonomous vehicle and mobile robots</p> <ul> <li>Project Link: open_planner</li> <li>Tutorial: https://github.com/ZATiTech/open_planner/blob/humble/op_carla_bridge/README.md</li> </ul>"},{"location":"tutorials/ad-hoc-simulation/digital-twin-simulation/carla-tutorial/#zenoh_carla_bridge","title":"zenoh_carla_bridge","text":"<p>The project is mainly for controlling multiple vehicles in Carla. It uses Zenoh to bridge the Autoware and Carla and is able to distinguish different messages for different vehicles. Feel free to ask questions and report issues to autoware_carla_launch.</p> <ul> <li>Project Link:<ul> <li>autoware_carla_launch: Integrated environment to run the bridge and Autoware easily.</li> <li>zenoh_carla_bridge: The bridge implementation.</li> </ul> </li> <li>Tutorial: Running Multiple Autoware-Powered Vehicles in Carla using Zenoh</li> </ul>"},{"location":"tutorials/scenario-simulation/","title":"Scenario simulation","text":""},{"location":"tutorials/scenario-simulation/#scenario-simulation","title":"Scenario simulation","text":"<p>Warning</p> <p>Under Construction</p>"},{"location":"tutorials/scenario-simulation/planning-simulation/installation/","title":"Installation","text":""},{"location":"tutorials/scenario-simulation/planning-simulation/installation/#installation","title":"Installation","text":"<p>This document contains step-by-step instruction on how to build AWF Autoware Core/Universe with <code>scenario_simulator_v2</code>.</p>"},{"location":"tutorials/scenario-simulation/planning-simulation/installation/#prerequisites","title":"Prerequisites","text":"<ol> <li>Autoware has been built and installed</li> </ol>"},{"location":"tutorials/scenario-simulation/planning-simulation/installation/#how-to-build","title":"How to build","text":"<ol> <li> <p>Navigate to the Autoware workspace:</p> <pre><code>cd autoware\n</code></pre> </li> <li> <p>Import Simulator dependencies:</p> <pre><code>vcs import src &lt; simulator.repos\n</code></pre> </li> <li> <p>Install dependent ROS packages:</p> <pre><code>source /opt/ros/humble/setup.bash\nrosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO\n</code></pre> </li> <li> <p>Build the workspace:</p> <pre><code>colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> </li> </ol>"},{"location":"tutorials/scenario-simulation/planning-simulation/random-test-simulation/","title":"Random test simulation","text":""},{"location":"tutorials/scenario-simulation/planning-simulation/random-test-simulation/#random-test-simulation","title":"Random test simulation","text":"<p>Note</p> <p>Running the Scenario Simulator requires some additional steps on top of building and installing Autoware, so make sure that Scenario Simulator installation has been completed first before proceeding.</p>"},{"location":"tutorials/scenario-simulation/planning-simulation/random-test-simulation/#running-steps","title":"Running steps","text":"<ol> <li> <p>Move to the workspace directory where Autoware and the Scenario Simulator have been built.</p> </li> <li> <p>Source the workspace setup script:</p> <pre><code>source install/setup.bash\n</code></pre> </li> <li> <p>Run the simulation:</p> <pre><code>ros2 launch random_test_runner random_test.launch.py \\\narchitecture_type:=awf/universe \\\nsensor_model:=sample_sensor_kit \\\nvehicle_model:=sample_vehicle\n</code></pre> </li> </ol> <p></p> <p>For more information about supported parameters, refer to the random_test_runner documentation.</p>"},{"location":"tutorials/scenario-simulation/planning-simulation/scenario-test-simulation/","title":"Scenario test simulation","text":""},{"location":"tutorials/scenario-simulation/planning-simulation/scenario-test-simulation/#scenario-test-simulation","title":"Scenario test simulation","text":"<p>Note</p> <p>Running the Scenario Simulator requires some additional steps on top of building and installing Autoware, so make sure that Scenario Simulator installation has been completed first before proceeding.</p>"},{"location":"tutorials/scenario-simulation/planning-simulation/scenario-test-simulation/#running-steps","title":"Running steps","text":"<ol> <li> <p>Move to the workspace directory where Autoware and the Scenario Simulator have been built.</p> </li> <li> <p>Source the workspace setup script:</p> <pre><code>source install/setup.bash\n</code></pre> </li> <li> <p>Run the simulation:</p> <pre><code>ros2 launch scenario_test_runner scenario_test_runner.launch.py \\\narchitecture_type:=awf/universe \\\nrecord:=false \\\nscenario:='$(find-pkg-share scenario_test_runner)/scenario/sample.yaml' \\\nsensor_model:=sample_sensor_kit \\\nvehicle_model:=sample_vehicle\n</code></pre> </li> </ol> <p></p> <p>Reference video tutorials</p>"},{"location":"tutorials/scenario-simulation/rosbag-replay-simulation/driving-log-replayer/","title":"Driving Log Replayer","text":""},{"location":"tutorials/scenario-simulation/rosbag-replay-simulation/driving-log-replayer/#driving-log-replayer","title":"Driving Log Replayer","text":"<p>Driving Log Replayer is an evaluation tool for Autoware. To get started, follow the official instruction provided by TIER IV.</p>"}]}